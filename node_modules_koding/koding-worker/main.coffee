amqp            = require 'amqp'
hat             = require 'hat'
os              = require 'os'
{argv}          = require 'optimist'
{EventEmitter}  = require 'events'
fs              = require "fs"
nodePath        = require 'path'
{exec}          = require "child_process"

class Worker extends EventEmitter

  constructor:(options = {},data)->
    options.name       or= "worker"
    options.status     or= 3
    options.command    or= ""
    options.option     or= ""
    options.number     or= 1
    options.uuid       or= hat()
    options.hostname   or= os.hostname()
    options.pid        or= process.pid
    options.interval   or= 10
    options.kontrold or=
      mongo         :
        host        : '127.0.0.1'
      rabbitmq      :
        host        : 'localhost'
        port        : '5672'
        login       : 'guest'
        password    : 'guest'
        vhost       : '/'

    super options, data

    @defaultInit options, data

  defaultInit:(options, data)->
    @reporter    = null
    @interval    = options.interval
    @amqpOptions = options.kontrold.rabbitmq
    @worker      =
      name : options.name
      message:
        command : options.command
        option  : options.option
        result  : "result"
      uuid      : options.uuid
      hostname  : @getHostName()
      timestamp : @isoDateString()
      pid       : options.pid
      status    : options.status
      number    : options.number
      version   : parseInt(@getVersion())

  startReporter: () ->
    console.log "Reporter enabled with #{@interval} interval"
    @reporter = setInterval =>
      @fetchWorkerExchange (workerExchange)=>
        @worker.message.command = "ack"
        @worker.timestamp = @isoDateString()
        workerExchange.publish "input.worker", {worker: @worker},
          appId: "#{@worker.uuid}"
    , @interval * 1000

  stopReporter: () ->
    console.log "Reporter disabled"
    clearInterval @reporter

  isoDateString: ->
    d = new Date()
    pad = (n) ->
      (if n < 10 then "0" + n else n)
    d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "Z"

  getVersion:() ->
    version = (fs.readFileSync nodePath.join(__dirname, '../../VERSION'), 'utf-8').trim()

  getHostName:() ->
    if fs.existsSync("/usr/bin/ec2metadata")
      console.log "Using ip from EC2 ..."
      res = @execSync("ec2metadata --public-ipv4")
      hostName = res.trim() + "-" + @getVersion()
    else
      console.log "Using local hostname ..."
      # hostName = os.hostname() + "-" + @getVersion()
      hostName = os.hostname()

  execSync : (cmd) ->
    exec cmd + " > kontrolExecOutput; echo done > kontrolExecSync"
    loop
      #consider a timeout option to prevent infinite loop
      #NOTE: this will max out your cpu too!
      try
        status = fs.readFileSync("kontrolExecSync", "utf8")
        if status.trim() is "done"
          res = fs.readFileSync("kontrolExecOutput", "utf8")
          fs.unlinkSync "kontrolExecOutput" #cleanup temp files
          fs.unlinkSync "kontrolExecSync"
          return res
      catch error
        # console.log error

  handleMessage:(message, headers, deliveryInfo)=>
    messageData = JSON.parse message.data.toString("utf-8")
    if messageData.name?
      if messageData.message.result is "first.start"
        @emit 'permissionToRun'
      else if messageData.uuid is @worker.uuid
        switch messageData.message.result
          when 'added.now'
            @emit 'permissionToRun'
          when 'added.before' then console.log 'No permission to run. Please enable "forceStart" in the Cakefile'
          when 'alive' then #ignore
          when 'deleted.now' or 'deleted.before' then #ignore
          when 'statused.now'   then @emit 'checkProcess'
          when 'started.before' then #ignore
          when 'started.now'
            @emit 'permissionToRun'
          when 'stopped.now'
            @emit 'stopRequest'
          when 'stopped.before' then @emit 'alreadyStopped'
          when 'killed.now'
            @emit 'killWorkerProcess'
          else

  fetchExchange:(name, options, callback)->
    exchangeName  = "#{name}Exchange"
    readyEvent    = "#{exchangeName}Ready"
    if @[exchangeName] is null
      @once readyEvent, => @fetchWorkerExchange callback
    else unless @workerExchange?
      @[exchangeName] = null
      @connection.exchange exchangeName, options,
        (exchange)=>
          @[exchangeName] = exchange
          @emit readyEvent
          callback exchange
    else callback @[exchangeName]

  fetchWorkerExchange:(callback)->
    @fetchExchange 'worker', @getWorkerExchangeOptions(), callback

  getWorkerExchangeOptions:->
    type        : 'topic'
    autoDelete  : no
    durable     : true

  connect: ()->
    {host, port, protocol, login, password, vhost, heartbeat} = @amqpOptions
    port              ?= 5672
    protocol          ?= 'amqp:'
    options           = {host, port, protocol} # but not vhost, because of a bug in node-amqp
    options.login     = login     if login?
    options.password  = password  if password?
    options.vhost     = vhost     if vhost?
    options.heartbeat = heartbeat if heartbeat?
    @connection       = amqp.createConnection options
    @connection.on "ready", =>
      @connection.exchange "workerExchange", @getWorkerExchangeOptions(), (exchange) =>
        @connection.queue "#{@worker.name}-#{@worker.hostname}-#{@worker.uuid}",
          durable: false
          autoDelete: true
        , (queue) =>
          queue.bind 'workerExchange', "output.worker.#{@worker.uuid}"
          queue.on "queueBindOk", =>
            @fetchWorkerExchange (workerExchange)=>
              workerExchange.publish "input.worker", {worker: @worker},
                appId: "#{@worker.uuid}"
            queue.subscribe (message, headers, deliveryInfo) =>
              @handleMessage message, headers, deliveryInfo

module.exports = Worker
