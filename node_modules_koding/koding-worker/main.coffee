amqp            = require 'amqp'
hat             = require 'hat'
os              = require 'os'
{argv}          = require 'optimist'
{EventEmitter}  = require 'events'
fs              = require "fs"
nodePath        = require 'path'
{exec}          = require "child_process"

class Worker extends EventEmitter

  @throwIt = (it) ->
    console.error it  if it?
    process.kill process.pid, 'SIGTERM'

  constructor:(options = {},data)->
    options.name       or= "worker"
    options.status     or= 1
    options.command    or= ""
    options.option     or= "many"
    options.uuid       or= hat()
    options.hostname   or= os.hostname()
    options.pid        or= process.pid
    options.interval   or= 10
    options.port       or= 0
    options.rabbitKey  or= ""
    options.binary     or= no
    options.kontrold   or=
      mongo         :
        host        : '127.0.0.1'
      rabbitmq      :
        host        : 'localhost'
        port        : '5672'
        login       : 'guest'
        password    : 'guest'
        vhost       : '/'

    super options, data

    @defaultInit options, data

  defaultInit:(options, data)->
    @reporter     = null
    @interval     = options.interval
    @amqpOptions  = options.kontrold.rabbitmq
    @binary       = options.binary
    @worker       =
      name      : options.name
      message   :
        command : options.command
        option  : options.option
      uuid      : options.uuid
      hostname  : @getHostName()
      timestamp : @isoDateString()
      pid       : options.pid
      status    : options.status
      version   : parseInt(@getVersion())
      port      : options.port
      rabbitKey : "" #use this if decide to use this feature @getRabbitKey()
      monitor   :
        mem     :
          rss       : 0
          heapTotal : 0
          heapUsed  : 0
          unit      : 'MB'
        uptime : 0


  startReporter: () ->
    @reporter = setInterval =>
      @fetchWorkerExchange (workerExchange)=>
        @worker.message.command = "ack"
        @worker.timestamp = @isoDateString()
        @worker.monitor.uptime += @interval
        workerExchange.publish "input.worker", {worker: @worker},
          appId: "#{@worker.uuid}"
    , @interval * 1000

  stopReporter: () ->
    clearInterval @reporter

  isoDateString: ->
    d = new Date()
    pad = (n) ->
      (if n < 10 then "0" + n else n)
    d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "Z"

  getVersion:() ->
    version = (fs.readFileSync nodePath.join(__dirname, '../../VERSION'), 'utf-8').trim()

  getRabbitKey:() ->
    version = (fs.readFileSync nodePath.join(__dirname, '../../KEY'), 'utf-8').trim()

  getHostName:() ->
    hostName = os.hostname()

  handleMessage:(message, headers, deliveryInfo)=>
    messageData = JSON.parse message.data.toString("utf-8")
    if messageData.name?
      if messageData.command is "first.start"
        @emit 'permissionToRun'
      else if messageData.uuid is @worker.uuid
        switch messageData.command
          when 'add'
            @emit 'permissionToRun'
          when 'added.before' then console.log "[#{@worker.name}] no permission to run. please start as 'force' or 'many' startmode."
          when 'alive' then #ignore
          when 'started.before' then #ignore
          when 'started.now'
            @emit 'permissionToRun'
          when 'kill'
            @emit 'killWorkerProcess'
          when 'killForce'
            @emit 'killForceWorkerProcess'
          else

  fetchExchange:(name, options, callback)->
    exchangeName  = "#{name}Exchange"
    readyEvent    = "#{exchangeName}Ready"
    if @[exchangeName] is null
      @once readyEvent, => @fetchWorkerExchange callback
    else unless @workerExchange?
      @[exchangeName] = null
      @connection.exchange exchangeName, options,
        (exchange)=>
          @[exchangeName] = exchange
          @emit readyEvent
          callback exchange
    else callback @[exchangeName]

  fetchWorkerExchange:(callback)->
    @fetchExchange 'worker', @getWorkerExchangeOptions(), callback

  getWorkerExchangeOptions:->
    type        : 'topic'
    autoDelete  : no
    durable     : true

  connect: ()->
    {host, port, protocol, login, password, vhost, heartbeat, autoReconnect} = @amqpOptions
    port              ?= 5672
    protocol          ?= 'amqp:'
    options           = {host, port, protocol} # but not vhost, because of a bug in node-amqp
    options.login     = login     if login?
    options.password  = password  if password?
    options.vhost     = vhost     if vhost?
    options.heartbeat = heartbeat if heartbeat?
    options.autoReconnect = autoReconnect ? no
    @connection = amqp.createConnection options
    @connection.on "error", Worker.throwIt
    @connection.on "ready", =>
      @connection.exchange "workerExchange", @getWorkerExchangeOptions(), (exchange) =>
        @connection.queue "#{@worker.name}-#{@worker.hostname}-#{@worker.uuid}",
          durable: false
          autoDelete: true
        , (queue) =>
          queue.bind 'workerExchange', "output.worker.#{@worker.uuid}"
          queue.on "queueBindOk", =>
            unless @binary
              @fetchWorkerExchange (workerExchange)=>
                workerExchange.publish "input.worker", {worker: @worker},
                  appId: "#{@worker.uuid}"
            else
              @emit 'permissionToRun'
            queue.subscribe (message, headers, deliveryInfo) =>
              @handleMessage message, headers, deliveryInfo

module.exports = Worker
