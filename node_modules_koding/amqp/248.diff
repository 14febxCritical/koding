diff --git a/lib/connection.js b/lib/connection.js
index d3b5228..c24014a 100644
--- a/lib/connection.js
+++ b/lib/connection.js
@@ -337,6 +337,19 @@ Connection.prototype.publish = function (routingKey, body, options, callback) {
   return this._defaultExchange.publish(routingKey, body, options, callback);
 };

+Connection.prototype.end = function() {
+  if (this.socket) {
+    // According to AMQP spec, send connectionClose to server.
+    // Socket will be closed when server responds connectionCloseOk.
+    this._sendMethod(0, methods.connectionClose, {
+      replyCode: 200,
+      replyText: 'ok',
+      classId: 0,
+      methodId: 0
+    });
+  }
+}
+
 Connection.prototype._bodyToBuffer = function (body) {
   // Handles 3 cases
   // - body is utf8 string
@@ -473,6 +486,12 @@ Connection.prototype._onMethod = function (channel, method, args) {
       this.socket.destroy(e);
       break;

+    case methods.connectionCloseOk:
+      if (this.socket) {
+        this.socket.end();
+      }
+      break;
+
     default:
       throw new Error("Uncaught method '" + method.name + "' with args " +
           JSON.stringify(args));
@@ -556,7 +575,7 @@ Connection.prototype._createSocket = function() {
   });

   // Proxy a few methods that we use / previously used.
-  var methods = ['end', 'destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];
+  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];
   _.each(methods, function(method){
     self[method] = function(){
       self.socket[method].apply(self.socket, arguments);
diff --git a/test/test-connection-end.js b/test/test-connection-end.js
new file mode 100644
index 0000000..faa7c72
--- /dev/null
+++ b/test/test-connection-end.js
@@ -0,0 +1,25 @@
+require('./harness').run();
+var assert = require('assert');
+var cbcnt = 0;
+
+// Only way to test if we disconnect cleanly is to look for
+// connectionCloseOk response from server.
+var oldOnMethod = connection._onMethod;
+connection._onMethod = function (channel, method, args) {
+  if (method.name === 'connectionCloseOk') {
+    cbcnt++;
+  }
+  oldOnMethod.apply(connection, arguments);
+};
+
+// And verify that we do really call end on the socket.
+connection.on('end', function() {
+ cbcnt++;
+});
+
+connection.on('ready', function(){
+    connection.end();
+});
+process.addListener('exit', function () {
+  assert.equal(cbcnt, 2);
+});
