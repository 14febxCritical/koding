#!/usr/local/bin/coffee
# core
fs          = require 'fs'

# contrib
{argv}      = require 'optimist'
traverse    = require 'traverse'
{parse}     = require 'esprima'
{generate}  = require 'escodegen'
coffee      = require 'coffee-script'

# helpers
log         = console.log.bind(console)

# cli arguments
{infix, indent, magicword, minify} = argv

# the magic word is usually "pistachio", but it can be user-defined.
magicword or= 'pistachio'

# the infix is usually "pjs" but it can be user-defined.
infix or= 'pjs'

_indent = do ->
  return '  ' unless indent?
  return indent if isNaN indent
  return Array(indent+1).join ' '
indent = _indent
# pistachio expression capturer
pistachios =
  ///             
  \{                # first { (begins symbol)
    ((?:\w*)?       # optional custom html tag name
    (?:\#\w*)?      # optional id - #-prefixed
    (?:(?:\.\w*)*)  # optional class names - .-prefixed
    (?:\[           # optional [ begins the attributes
      (?:\b\w*\b)   # the name of the attribute
      (?:\=         # optional assignment operator =
                    # TODO: this will tolerate fuzzy quotes for now. "e.g.'
        [\"|\']?    # optional quotes 
        .*          # optional value
        [\"|\']?    # optional quotes
      )             
    \])*)           # optional ] closes the attribute tag(s). there can be many attributes.
    \{              # second { (begins expression)
      ([^{}]*)      # practically anything can go between the braces, except {}
    \}\s*           # closing } (ends expression)
  \}                # closing } (ends symbol)
  ///g

minifyCode =do ->
  {parser, uglify} = require 'uglify-js'
  (code)->
    ast = parser.parse code
    ast = uglify.ast_mangle ast
    ast = uglify.ast_squeeze ast
    return uglify.gen_code ast

compileLiteral =do ->
  literalId = 0
  (literal)->
    unless 'string' is typeof literal
      return literal
    else
      dataExprs = {}
      dataExprCount = 0
      compiledExpr = literal.replace pistachios, (_, markup, expr)->
        embedView = no
        if /^> /.test expr
          expr = expr.substr 2
          embedView = yes
        preparedExpr = expr.replace /#\((?:[^)]*)\)/g, (dataExpr)->
          dataExprId = "__expr-#{literalId}-#{dataExprCount}"
          dataExprs[dataExprId] = dataExpr
          dataExprCount++
          return "'#{dataExprId}'"
        compiledExpr = coffee.compile(preparedExpr, bare: yes)
        if compiledExpr.match(/;/g).length > 1
          throw new SyntaxError 'Only one expression is allowed.'
        else compiledExpr = compiledExpr.replace(/\n|;/g, '')
        processedExpr = compiledExpr
          .replace /\'(__expr-[0-9]+-[0-9]+)\'/g, (_, placeholder)->
            return dataExprs[placeholder]
        return "{#{markup}{#{if embedView then '> ' else ''}#{processedExpr}}}"
      literalId++
      return compiledExpr

compileAllLiterals =(obj)->
  traverse(obj).map (node)->
    if node?.type is 'Literal'
      node.value = compileLiteral(node.value)
      @update node, yes
    else @update node

compileAll =(type, node)->
  switch type
    when 'property'
      switch node.value.type
        when 'FunctionExpression'
          node.value = compileAllLiterals(node.value)
        when 'Literal'
          node.value = compileLiteral(node.value)
    when 'assignment'
      switch node.right.type
        when 'FunctionExpression'
          node.right = compileAllLiterals(node.right)
        when 'Literal'
          node.value = compileLiteral(node.right)
  return node

api =
  postProcess : (options)->  
    {source,minify} = options
    processed = traverse(parse source).map (node)->
      if not @isLeaf and node.type
        switch node.type
          when 'Property' then if node.key.name is magicword
            compiled = compileAll('property', node)
            @update compiled, yes
          when 'AssignmentExpression'
            if node.left.property?.name is magicword
              compiled = compileAll('assignment', node)
              @update compiled, yes
          else @update node
      else @update node
    code = generate processed, {indent}
    #code = minifyCode code if minify
    return code


argv._.forEach (file)->
  source = fs.readFileSync file, 'utf-8'
  code = api.postProcess {source,minify}
  [name, suffix...] = file.split '.'
  fs.writeFileSync [name, infix].concat(suffix).join('.'), code, 'utf-8'

module.exports = api