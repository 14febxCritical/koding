'use strict'
###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
###
###
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
@foo
###
isBrowser = 'undefined' isnt typeof window
###
@class: bongo (client)
@description: client-side bongo.
###
# core
{EventEmitter} = require 'microemitter'

class Bongo extends EventEmitter
  # bongo     = new EventEmitter
  # contrib
  Traverse  = require 'traverse'
  createId  = @createId = require 'hat'

  JsPath    = @JsPath = require 'jspath'

  {Store} = require 'koding-dnode-protocol'
  Scrubber = require './src/scrubber'
  @dnodeProtocol = {Store, Scrubber}

  @EventEmitter = EventEmitter
  Model     = @Model = require './src/model'
  @ListenerTree = require './src/listenertree'
  EventBus  = @EventBus = require './src/eventbus'

  # mixin the event emitter for the AMQP broker
  Model::mixin require './src/eventemitter/broker'
  # need these aliases:
  Model::off = Model::removeListener
  Model::addGlobalListener = Model::on

  # TODO: temporary hack
  @KDML = require 'kdml'

  {slice} = []

  {extend} = require './src/util'
  
  {race, sequence, dash} = require 'sinkrow'
  {@daisy, @dash, @sequence, @race, @future} = require 'sinkrow'

  createBongoName =-> 'bongo.'+createId()

  constructor:(options)->
    EventEmitter this
    {@mq, @getSessionToken, @getUserArea, @fetchName} = options
    @getUserArea  ?= ->
    @bongoName    = createBongoName()
    @channelName  = 'private-'+@bongoName
    @localStore   = new Store
    @remoteStore  = new Store
    #@updateInstanceChannel = @mq.subscribe 'updateInstances'
    @readyState   = 0
    @stack = []
    @eventBus = new EventBus @mq
    @mq.on 'disconnected', @emit.bind @, 'disconnected'
    @on 'newListener', (event, listener)=>
      if event is 'ready' and @readyState is 1
        process.nextTick =>
          @emit 'ready'
          @removeAllListeners 'ready'

  cacheable:require './src/cacheable'

  createRemoteApiShims:(api)->
    shimmedApi = {}
    for name, {statik, instance, options} of api
      shimmedApi[name] = @createConstructor name, statik, instance, options
    shimmedApi

  wrapStaticMethods:do ->
    optimizeThese = ['on','off']
    (constructor, constructorName, statik)->
      bongo = @
      statik.forEach (method)->
        method += '_' if method in optimizeThese
        constructor[method] =->
          rpc = {
            type: 'static'
            constructorName
            method
          }
          bongo.send rpc, [].slice.call arguments

  wrapInstanceMethods:do ->
    optimizeThese = ['on','addListener','off','removeListener','save']
    (constructor, constructorName, instance)->
      bongo = @
      instance.forEach (method)->
        method += '_' if method in optimizeThese
        constructor::[method] =->
          id = @getId()
          data = @data unless id?
          rpc = {
            type: 'instance'
            constructorName
            method
            id
            data
          }
          bongo.send rpc, [].slice.call arguments

  registerInstance:(inst)->
    inst.on 'listenerRemoved', (event, listener)=>
      @eventBus.off inst, event, listener.bind(inst)
    inst.on 'newListener', (event, listener)=>
      @eventBus.on inst, event, listener.bind(inst)

  getEventChannelName =(name)-> "event-#{name}"

  getRevivingListener =(bongo, ctx, listener)->
    (rest...)-> listener.apply ctx, bongo.revive rest

  addGlobalListener =(konstructor, event, listener)->
    channelName = getEventChannelName konstructor.name
    revivingListener = getRevivingListener @, konstructor, listener
    channel = @mq.channels[channelName]
    if channel?
      channel.on event, revivingListener
    else
      channel = @mq.subscribe channelName
      channel.on 'broker:bind_succeeded', ->
        channel.on event, revivingListener

  createConstructor:(name, staticMethods, instanceMethods, options)->
    konstructor = Function('bongo', """
      return function #{name} () {
        bongo.registerInstance(this);
        this.init.apply(this, [].slice.call(arguments));
        this.bongo_.constructorName = '#{name}';
      }
      """) this
    EventEmitter konstructor
    @wrapStaticMethods konstructor, name, staticMethods
    konstructor extends Model
    konstructor::updateInstanceChannel = @updateInstanceChannel
    konstructor.on 'newListener', addGlobalListener.bind @, konstructor
    konstructor[option] = options[option] for own option of options
    @wrapInstanceMethods konstructor, name, instanceMethods
    konstructor

  getInstancesById:->

  getInstanceMethods:-> ['changeLoggedInState']

  revive:(obj)->
    bongo = @
    hasEncoder = Encoder?.XSSEncode?
    new Traverse(obj).map (node)->
      if node?.bongo_?
        {constructorName, instanceId} = node.bongo_
        instance = bongo.getInstancesById instanceId
        return @update instance, yes if instance?
        konstructor = bongo.api[node.bongo_.constructorName]
        unless konstructor?
          @update node
        else
          @update new konstructor(node)
      else if hasEncoder and 'string' is typeof node
        @update Encoder.XSSEncode(node)
      else
        @update node

  # auth:->
  #   @channel.emit 'client-auth', @getSessionToken()

  reviveFromSnapshots:do ->
    # TODO: fix this properly, but it avoids clobbering the _events property
    snapshotReviver =(k, v)->
      return  if k is '_events'
      return v
    (instances, callback)->
      callback null, instances.map (instance)=>
        @revive JSON.parse instance.snapshot, snapshotReviver if instance.snapshot?

  handleRequest:(message)->
    if message?.method is 'defineApi'
      @defineApi message.arguments[0]
    else
      {method, context} = message
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub message, (callbackId)=>
        unless @remoteStore.has(callbackId)
          @remoteStore.add callbackId, (args...)=>
            @send callbackId, args
        @remoteStore.get callbackId
      revived = @revive unscrubbed
      if method in @getInstanceMethods()
        @[method] revived...
      else unless isNaN +method
        callback = @localStore.get(method)
        callback?.apply null, revived
      else
        console.log method

  connect:(callback)->
    @channel = @mq.subscribe @channelName
    @channel.once 'broker:bind_succeeded', =>
      @mq.once 'connected', callback.bind @  if callback?
      if @mq.autoReconnect
        @mq.once 'disconnected', => @mq.once 'connected', => @connect()
      @channel.on 'server-message', @handleRequest.bind(@)
      unless @readyState
        setTimeout (=>
          @emit 'connected'
          @channel.emit 'client-join', @getSessionToken()
        ), 75
      else @emit 'connected'
      # apply the middleware
      @stack.forEach (fn)=> fn.call @

  messageFailed:(message)->
    console.log 'MESSAGE FAILED', message

  getTimeout:(message, clientTimeout=5000)->
    setTimeout @messageFailed.bind(@, message), clientTimeout

  ping:(callback)-> @send 'ping', callback

  send:(method, args)->
    args = [args] unless Array.isArray(args)
    unless @channel
      throw new Error 'No channel!'
    else
      scrubber = new Scrubber @localStore
      scrubber.scrub args, =>
        message = scrubber.toDnodeProtocol()
        message.method = method
        message.sessionToken = @getSessionToken()
        message.userArea = @getUserArea()
        messageString = JSON.stringify(message)
        @channel.emit 'client-message', messageString

  disconnect:(callback)->
    @mq.once 'disconnected', callback.bind @  if callback?
    @mq.disconnect()

  defineApi:(api)->
    @api = @createRemoteApiShims api
    @readyState = 1
    @emit 'ready'

  changeLoggedInState:(state)->
    @emit 'loggedInStateChanged', state

  fetchChannel:(channelName, callback)->
    channel = @mq.subscribe channelName
    channel.on 'broker:bind_succeeded', -> callback channel

  use:(fn)->
    @stack.push fn
    
if not isBrowser and module
  module.exports = Bongo
else if window?
  window['Bongo'] = Bongo