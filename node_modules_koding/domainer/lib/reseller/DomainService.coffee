ServiceManager = require './ServiceManager.coffee'
{race}         = require 'bongo'

# cache for functions with no parameters
# and a callback with err and response
memoize = (func) ->
  ttl = 10000
  lastQueryTime = 0
  memo = undefined
  (callback) ->
    current = new Date().getTime()
    if lastQueryTime < current - ttl
      lastQueryTime = current
      func.call this, (err, result) ->
        if err
          return callback err, null
        memo = result
        return callback null, memo
      return
    return callback null, memo

splitDomain = (domainName) ->
  splitted =  domainName.split "."
  return {
    first: splitted[0],
    extension: if splitted.length > 1 then splitted[1..].join "." else ""
  }

module.exports = class DomainService extends ServiceManager

  request = require 'request'

  # TODO : nameservers should change according to koding.com NS
  # nameservers = ["ns29.domaincontrol.in","ns30.domaincontrol.in"]
  nameservers = [
    "sina482303.mercury.orderbox-dns.com",
    "sina482303.venus.orderbox-dns.com",
    "sina482303.earth.orderbox-dns.com",
    "sina482303.mars.orderbox-dns.com"
  ]

  availableTLDs = ["com","net","org"] # look for TODO (1) if you add something here

  isDomainAvailable: (domainName, tld, callback)->
    if tld not in availableTLDs
      return "Tld is blank or not supported", null
    params =
      "domain-name"         : domainName
      "tlds"                : tld
      "suggest-alternative" : false

    options =
      service    : "domains"
      action     : "available"
      parameters : params
    @makeRequestToResellerApi options, (err, apiResponseBody) =>
      if err
        return callback err, null
      domainKey   = domainName + "." + tld
      status      = apiResponseBody?[domainKey]?.status
      @getTldPrice tld, (err, price) =>
        if err
          return callback err, null
        @getDomainSuggestion domainName, tld, (err, suggestions)->
          if err
            return callback err, null
          else
            return callback err, {status:status, price:price, suggestions:suggestions}

  getDomainSuggestion: (domainName, tld, callback) ->
    suggestions = []
    collectResults = race (i, item, fin) =>
      @getTldPrice splitDomain(item.domain).extension, (err, price) ->
        if err
          return callback err, null
        suggestions.push {domain:item.domain, price:price}
        fin()
    , ->
      return callback null, suggestions
    
    @makeSuggestionRequestToDomainr domainName, (err, suggestionResponse)->
      if err
        return callback err, null
      suggestionResponse.results = (result for result in suggestionResponse.results when \
        result.availability is "available" and 
        splitDomain(result.domain).extension in availableTLDs and
        result.domain isnt domainName + "." + tld)

      if suggestionResponse.results.length is 0
        return callback null, suggestions
      else
        for domain in suggestionResponse.results
          collectResults domain


  getTldPrice: (tld, callback) ->
    @getTldPrices (err, priceList) ->
      if err
        return callback err, null
      
      return callback null, priceList[tld]

  getTldPrices: memoize (callback) ->
    params =
      "resellerid": @authUserId
    options =
      service    : "products"
      action     : "reseller-price"
      parameters : params
    @makeRequestToResellerApi options, (err, apiResponseBody) =>
      if err
        return callback err, null
      priceList = {}
      for key, value of apiResponseBody
        # TODO (1) tld parsing is not so easy :(
        # This logic needs to be extended when new domains are added to
        # the support list
        currentTld = key.match(/^do[mt]([a-z]+)$/)?[1]
        if key is "domcno"
          # com is named domcno
          priceList["com"] = value[0].pricing.addnewdomain[1]
        else if currentTld and (currentTld in availableTLDs)
          priceList[currentTld] = value[0].pricing.addnewdomain[1]
      return callback null, priceList


  registerDomain: (domainInfo, callback)->
    #invoice option may change, but for now NoInvoice parameter is given,
    params =
      "domain-name"        : domainInfo.domainName
      "years"              : domainInfo.years
      "ns"                 : nameservers
      "customer-id"        : domainInfo.customerId
      "reg-contact-id"     : domainInfo.regContactId
      "admin-contact-id"   : domainInfo.adminContactId
      "tech-contact-id"    : domainInfo.techContactId
      "billing-contact-id" : domainInfo.billingContactId
      "invoice-option"     : domainInfo.invoiceOption
      "protect-privacy"    : domainInfo.protectPrivacy

    options =
      service              : "domains"
      action               : "register"
      parameters           : params

    @makeRequestToResellerApi options, callback

  fetchProxyFilters:(callback)->


  createProxyFilter:(params, callback)->
    options =
      method  : 'POST'
      uri     : "http://kontrol.in.koding.com/filters/#{params.filterInfo.name}"
      body    : JSON.stringify params.filterInfo

      headers : {'content-type': 'application/json'}

    request.post options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  fetchProxyRules:(domainName, callback)->
    options =
      uri : "http://kontrol.in.koding.com/restrictions/#{domainName}"

    request.get options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  createProxyRule: (params, callback)->
    options =
      method : 'POST'
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"
      body   : JSON.stringify params.behaviorInfo

    request.post options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  deleteProxyRule: (params, callback)->
    options =
      method : "DELETE"
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"

    request.del options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  updateProxyRule: (params, callback)->
    options =
      method : 'PUT'
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"
      body   : JSON.stringify params.behaviorInfo

    request.put options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  _returnResponse:(error, response, body, callback)->
    if error
      console.log "ERROR", error
      callback error

    console.log body

    resBody = JSON.parse body

    callback resBody.err if response.statusCode is 400
    callback null, resBody if response.statusCode is 200


  getDomainDetails:(domain, callback)->
    params =
      "domain-name"        : domain.address
      "options"            : "All"

    options =
      service              : "domains"
      action               : "details-by-name"
      parameters           : params

    data = @makeRequestToResellerApi options, callback


  updateDomainContactDetails:(domain, callback)->
    params =
      "domain-name"        : domain.address
      "options"            : "All"
      "order-id"           : domain.orderId
      "reg-contact-id"     : domain.registrantContactId
      "admin-contact-id"   : domain.adminContactId
      "tech-contact-id"    : domain.techContactId
      "billing-contact-id" : domain.billingContactId

    options =
      service              : "domains"
      action               : "modify-contact"
      parameters           : params

    data = @makeRequestToResellerApi options, callback


  updateDomainCName:(params, callback)->
    updateOptions =
      service : "dns"
      action  : "activate"
      parameters :
        "order-id" : params.orderId

    @makeRequestToResellerApi updateOptions, (err, response)=>
      unless err

        options =
          service : "dns/manage"
          action  : "add-cname-record"
          parameters:
            "domain-name" : params.domainName
            value         : "kontrol.in.koding.com"

        @makeRequestToResellerApi options, callback
