ServiceManager = require './ServiceManager.coffee'
{race}         = require 'bongo'

splitDomain = (domainName) ->
  splitted  = domainName.split "."
  return {
    domain    : splitted[0]
    extension : if splitted.length > 1 then splitted[1..].join "." else ""
  }

module.exports = class DomainService extends ServiceManager

  request = require 'request'

  # TODO : nameservers should change according to koding.com NS
  # nameservers = ["ns29.domaincontrol.in","ns30.domaincontrol.in"]
  nameservers = [
    "sina482303.mercury.orderbox-dns.com",
    "sina482303.venus.orderbox-dns.com",
    "sina482303.earth.orderbox-dns.com",
    "sina482303.mars.orderbox-dns.com"
  ]

  prices        = {} # Prices will be updated with first request
  availableTLDs = [
    "com","net","org","co","me"
    "info","in","ca","us","ru"
    "ws","eu","cn","cc","biz"
  ]

  getAvailableTlds: (callback=->)-> callback availableTLDs

  getDomainInfo: (domainName, callback)->

    {domain, extension} = splitDomain domainName

    if extension not in availableTLDs
      return callback "Tld is blank or not supported", null

    options =
      action          : "available"
      service         : "domains"
      parameters      :
        tlds          : extension
        "domain-name" : domain

    @makeRequestToResellerApi options, (err, res)=>
      return callback err if err
      available = res[domainName]?.status is 'available'
      if not available then callback err, {available}
      else
        @getTldPrice extension, (err, price)->
          return callback err, {available}  if err
          callback err, {available, price}

  getDomainSuggestions: (domainName, callback) ->
    suggestions = []

    attachPrice = race (i, {domain, extension}, fin) =>
      @getTldPrice extension, (err, price) ->
        return callback err, null  if err
        suggestions.push {domain, price}
        fin()
    , ->
      return callback null, suggestions

    {domain, extension} = splitDomain domainName

    @makeSuggestionRequestToDomainr domain, (err, suggestionResponse)->
      return callback err, suggestions  if err

      if suggestionResponse.results.length is 0
        return callback null, suggestions

      for result in suggestionResponse.results
        if result.availability is 'available'
          {domain, extension} = splitDomain result.domain
          if extension in availableTLDs and result.domain isnt domainName
            attachPrice {domain:result.domain, extension}
            foundASuggestion = yes

      unless foundASuggestion
        callback null, suggestions

  getTldPrice: (tld, callback) ->
    if prices[tld]? then callback null, prices[tld]
    else @getTldPrices (err, prices) ->
      return callback err, null  if err
      callback null, prices[tld]

  getTldPrices: (callback) ->

    options =
      service    : "products"
      action     : "reseller-price"
      parameters : resellerid : @authUserId

    @makeRequestToResellerApi options, (err, apiResponseBody) =>
      return callback err, null  if err
      priceList = {}
      for key, value of apiResponseBody
        # TODO (1) tld parsing is not so easy :(
        # This logic needs to be extended when new domains are added to
        # the support list
        currentTld = key.match(/^do[mt]([a-z]+)$/)?[1]
        if key is "domcno" # com is named domcno
          priceList["com"] = value[0].pricing.addnewdomain[1]
        else if currentTld and (currentTld in availableTLDs)
          priceList[currentTld] = value[0].pricing.addnewdomain[1]

      # TODO: Invalidate this prices information after sometime.
      DomainService.prices = priceList
      return callback null, priceList


  registerDomain: (domainInfo, callback)->
    #invoice option may change, but for now NoInvoice parameter is given,
    params =
      "domain-name"        : domainInfo.domainName
      "years"              : domainInfo.years
      "ns"                 : nameservers
      "customer-id"        : domainInfo.customerId
      "reg-contact-id"     : domainInfo.regContactId
      "admin-contact-id"   : domainInfo.adminContactId
      "tech-contact-id"    : domainInfo.techContactId
      "billing-contact-id" : domainInfo.billingContactId
      "invoice-option"     : domainInfo.invoiceOption
      "protect-privacy"    : domainInfo.protectPrivacy

    options =
      service              : "domains"
      action               : "register"
      parameters           : params

    @makeRequestToResellerApi options, callback

  fetchProxyFilters:(callback)->


  createProxyFilter:(params, callback)->
    options =
      method  : 'POST'
      uri     : "http://kontrol.in.koding.com/filters/#{params.filterInfo.name}"
      body    : JSON.stringify params.filterInfo

      headers : {'content-type': 'application/json'}

    request.post options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  fetchProxyRules:(domainName, callback)->
    options =
      uri : "http://kontrol.in.koding.com/restrictions/#{domainName}"

    request.get options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  createProxyRule: (params, callback)->
    options =
      method : 'POST'
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"
      body   : JSON.stringify params.behaviorInfo

    request.post options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  deleteProxyRule: (params, callback)->
    options =
      method : "DELETE"
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"

    request.del options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  updateProxyRule: (params, callback)->
    options =
      method : 'PUT'
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"
      body   : JSON.stringify params.behaviorInfo

    request.put options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  _returnResponse:(error, response, body, callback)->
    if error
      console.log "ERROR", error
      callback error

    console.log body

    resBody = JSON.parse body

    callback resBody.err if response.statusCode is 400
    callback null, resBody if response.statusCode is 200


  getDomainDetails:(domain, callback)->
    params =
      "domain-name"        : domain.address
      "options"            : "All"

    options =
      service              : "domains"
      action               : "details-by-name"
      parameters           : params

    data = @makeRequestToResellerApi options, callback


  updateDomainContactDetails:(domain, callback)->
    params =
      "domain-name"        : domain.address
      "options"            : "All"
      "order-id"           : domain.orderId
      "reg-contact-id"     : domain.registrantContactId
      "admin-contact-id"   : domain.adminContactId
      "tech-contact-id"    : domain.techContactId
      "billing-contact-id" : domain.billingContactId

    options =
      service              : "domains"
      action               : "modify-contact"
      parameters           : params

    data = @makeRequestToResellerApi options, callback


  updateDomainCName:(params, callback)->
    updateOptions =
      service : "dns"
      action  : "activate"
      parameters :
        "order-id" : params.orderId

    @makeRequestToResellerApi updateOptions, (err, response)=>
      unless err

        options =
          service : "dns/manage"
          action  : "add-cname-record"
          parameters:
            "domain-name" : params.domainName
            value         : "kontrol.in.koding.com"

        @makeRequestToResellerApi options, callback
