ServiceManager = require './ServiceManager.coffee'
{race}         = require 'bongo'

# cache for functions with no parameters
# and a callback
memoize = (func) ->
  ttl = 1000
  lastQueryTime = new Date().getTime() - ttl
  memo = undefined
  (callback) ->
    current = new Date().getTime()
    if lastQueryTime <= current - ttl
      lastQueryTime = current
      func.call this, (result) ->
        memo = result
        callback memo
    return callback memo

splitDomain = (domainName) ->
  splitted =  domainName.split "."
  return {
    first: splitted[0..-2],
    extension: splitted[splitted.length-1] ? splitted.length > 1 : ""
  }

module.exports = class DomainService extends ServiceManager

  request = require 'request'
  domainr = require 'Domai.nr'

  # TODO : nameservers should change according to koding.com NS
  # nameservers = ["ns29.domaincontrol.in","ns30.domaincontrol.in"]
  nameservers = [
    "sina482303.mercury.orderbox-dns.com",
    "sina482303.venus.orderbox-dns.com",
    "sina482303.earth.orderbox-dns.com",
    "sina482303.mars.orderbox-dns.com"
  ]

  availableTLDs = ["com","net","org"] # look for TODO (1) if you add something here

  isDomainAvailable:(domainName, tld, callback)->
    params =
      "domain-name"         : domainName
      "tlds"                : tld
      "suggest-alternative" : false

    options =
      service    : "domains"
      action     : "available"
      parameters : params

    @makeRequestToResellerApi options, (err, apiResponseBody) =>
      domainKey   = "#{domainName}.#{tld}"
      status      = apiResponseBody?[domainKey]?.status
      @getTldPrice tld, (price) =>
        @getDomainSuggestion domainName, "tld", (suggestions)->
          console.log(status, price, suggestions)
          callback err, status, price, suggestions

  getDomainSuggestion: (domainName, tld, callback) ->
    domainr.search domainName, (suggestionResponse) =>
      console.log(suggestionResponse)
      suggestions = []
      collect = race (i, item, fin) =>
        @getTldPrice splitDomain(item.domain).extension, (price) ->
          console.log(splitDomain(item.domain).extension, item)
          console.log(price)
          suggestions.push {domain:item.domain, price:price}
          fin()
      , ->
        console.log(domainName)
        console.log("exit:", suggestions)
        callback suggestions
      console.log("asdsad:"+domainName + "." + tld)
      suggestionResponse.results = (result for result in suggestionResponse.results when \
        result.availability is "available" and 
        splitDomain(result.domain).extension in availableTLDs and
        result.domain isnt domainName + "." + tld)
      for domain in suggestionResponse.results
          collect domain
      if suggestionResponse.results.length is 0
        callback suggestions


  getTldPrice: (tld, callback) ->
    @getTldPrices (priceList) ->
      callback priceList[tld]

  getTldPrices: memoize (callback) ->
    params =
      "resellerid": @authUserId
    options =
      service    : "products"
      action     : "reseller-price"
      parameters : params
    @makeRequestToResellerApi options, (err, apiResponseBody) =>
      priceList = {}
      for key, value of apiResponseBody
        # TODO (1) tld parsing is not so easy :(
        # This logic needs to be extended when new domains are added to
        # the support list
        currentTld = key.match(/^do[mt]([a-z]+)$/)?[1]
        if key is "domcno"
          # com is named domcno
          priceList["com"] = value[0].pricing.addnewdomain[1]
        else if currentTld and (currentTld in availableTLDs)
          priceList[currentTld] = value[0].pricing.addnewdomain[1]
      return callback priceList

  registerDomain: (domainInfo, callback)->
    #invoice option may change, but for now NoInvoice parameter is given,
    params =
      "domain-name"        : domainInfo.domainName
      "years"              : domainInfo.years
      "ns"                 : nameservers
      "customer-id"        : domainInfo.customerId
      "reg-contact-id"     : domainInfo.regContactId
      "admin-contact-id"   : domainInfo.adminContactId
      "tech-contact-id"    : domainInfo.techContactId
      "billing-contact-id" : domainInfo.billingContactId
      "invoice-option"     : domainInfo.invoiceOption
      "protect-privacy"    : domainInfo.protectPrivacy

    options =
      service              : "domains"
      action               : "register"
      parameters           : params

    @makeRequestToResellerApi options, callback

  fetchProxyFilters:(callback)->


  createProxyFilter:(params, callback)->
    options =
      method  : 'POST'
      uri     : "http://kontrol.in.koding.com/filters/#{params.filterInfo.name}"
      body    : JSON.stringify params.filterInfo

      headers : {'content-type': 'application/json'}

    request.post options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  fetchProxyRules:(domainName, callback)->
    options =
      uri : "http://kontrol.in.koding.com/restrictions/#{domainName}"

    request.get options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  createProxyRule: (params, callback)->
    options =
      method : 'POST'
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"
      body   : JSON.stringify params.behaviorInfo

    request.post options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  deleteProxyRule: (params, callback)->
    options =
      method : "DELETE"
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"

    request.del options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  updateProxyRule: (params, callback)->
    options =
      method : 'PUT'
      uri    : "http://kontrol.in.koding.com/restrictions/#{params.domainName}/list/#{params.ruleName}"
      body   : JSON.stringify params.behaviorInfo

    request.put options, (error, response, body)=>
      @_returnResponse error, response, body, callback

  _returnResponse:(error, response, body, callback)->
    if error
      console.log "ERROR", error
      callback error

    console.log body

    resBody = JSON.parse body

    callback resBody.err if response.statusCode is 400
    callback null, resBody if response.statusCode is 200


  getDomainDetails:(domain, callback)->
    params =
      "domain-name"        : domain.address
      "options"            : "All"

    options =
      service              : "domains"
      action               : "details-by-name"
      parameters           : params

    data = @makeRequestToResellerApi options, callback


  updateDomainContactDetails:(domain, callback)->
    params =
      "domain-name"        : domain.address
      "options"            : "All"
      "order-id"           : domain.orderId
      "reg-contact-id"     : domain.registrantContactId
      "admin-contact-id"   : domain.adminContactId
      "tech-contact-id"    : domain.techContactId
      "billing-contact-id" : domain.billingContactId

    options =
      service              : "domains"
      action               : "modify-contact"
      parameters           : params

    data = @makeRequestToResellerApi options, callback


  updateDomainCName:(params, callback)->
    updateOptions =
      service : "dns"
      action  : "activate"
      parameters :
        "order-id" : params.orderId

    @makeRequestToResellerApi updateOptions, (err, response)=>
      unless err

        options =
          service : "dns/manage"
          action  : "add-cname-record"
          parameters:
            "domain-name" : params.domainName
            value         : "kontrol.in.koding.com"

        @makeRequestToResellerApi options, callback
