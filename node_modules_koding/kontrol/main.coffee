amqp           = require 'amqp'
{argv}         = require 'optimist'
hat            = require 'hat'
colors         = require 'colors'
{EventEmitter} = require 'events'
program        = require "commander"
os             = require "os"
fs             = require "fs"
nodePath       = require 'path'
Table          = require 'cli-table'
{kontrold}     = require('koding-config-manager').load("main.#{argv.c}")

tableOptions =
  head: ["Worker", "Hostname", "Version", "Pid", "Uptime", "Mem (MB)", "Status"]
  colWidths: [15, 35, 10, 7, 10, 10, 16]
table = new Table tableOptions
ACTIONS = ["delete", "start", "stop", "kill", "cmd", "cancel"]
DASHBOARD = ["Refresh data", "Select hostname", "Batch actions", "Send Command"]
BATCH = ["On all workers", "On hostname"]

class Kontrol extends EventEmitter

  constructor:(options = {},data)->
    @workersPlain = []
    @workersTable = []
    @currentWorkers = []
    @currentHosts = []
    @monitorMode = null
    @amqpOptions = kontrold
    @clikey = hat()
    @worker =
      name : "worker"
      message:
        command : "status"
        option  : "all"
        result  : "result"
      uuid      : hat()
      hostname  : @getHostName()
      pid       : 0
      status    : 3
      number    : 1
    super options, data

  getVersion:() ->
    version = (fs.readFileSync nodePath.join(__dirname, '../../VERSION'), 'utf-8').trim()

  getHostName:() ->
    hostName = os.hostname() + "-" + @getVersion()

  secondsToTime: (secs) ->
    if secs is 0
      return 0
    secs = parseInt(secs)
    hr = Math.floor(secs / 3600)
    min = Math.floor((secs - (hr * 3600)) / 60)
    sec = secs - (hr * 3600) - (min * 60)
    # hr = "0" + hr  if hr < 10
    min = "0" + min  if min < 10
    sec = "0" + sec  if sec < 10
    hr + ":" + min + ":" + sec

  parseStatusResponse: (messageData) =>
    # if messageData.MonitorMode?.Enabled
    #   @monitorMode = on
    # else
    #   @monitorMode = off

    for hostname of messageData.status
      for worker in messageData.status[hostname]
        switch worker.status
          when 0
            worker.status = "stopped".yellow
          when 1
            worker.status = "running".green
          when 2
            worker.status = "pending".cyan
          when 3
            worker.status = "not started".grey
          when 4
            worker.status = "killed".red
          when 5
            worker.status = "dead".red
          when 6
            worker.status = "waiting".blue

        uptime = @secondsToTime worker.uptime

        tableContent = [worker.name, worker.hostname, worker.version.toString(), worker.pid.toString(), uptime, worker.memory, worker.status, worker.uuid]
        @workersTable.push tableContent

  selectDashboard: (callback) =>
    console.log "What do you want to do? (CTRL+C to exit):"
    program.choose DASHBOARD, 0, (dashIndex) ->
      callback dashIndex

  selectHost: (callback) =>
    console.log "Select hostname:"
    program.choose @currentHosts, (hostIndex) ->
      callback hostIndex

  selectAction: (callback) ->
    console.log "Select action to do:"
    program.choose ACTIONS, 5, (actionIndex) ->
      callback actionIndex

  selectWorker: (callback) =>
    console.log "Select worker:"
    program.choose @currentWorkers, (workerIndex) ->
      callback workerIndex

  selectBatch: (callback) =>
    console.log "How do you want apply your batch action?:"
    program.choose BATCH, (batchIndex) ->
      callback batchIndex

  getDate: ->
    d = new Date()
    pad = (n) ->
      (if n < 10 then "0" + n else n)
    d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "Z"

  createTable:() ->
    # get workers names  in a single array
    for worker, i in @workersTable
      unless worker[0] in @currentWorkers
        @currentWorkers[i] = worker[0]

    # get hostnames in a single array
    for worker, i in @workersTable
      unless worker[1] in @currentHosts
        @currentHosts[i] = worker[1]

    # remove empty elements
    @currentHosts = @currentHosts.filter(->
      true
    )

    @currentWorkers = @currentWorkers.filter(->
      true
    )

    # sort according to host names
    @workersTable.sort (a, b) =>
      (if a[1] > b[1] then 1 else -1)

    # this is needed for a new array copy.. I hate JS
    @workersPlain = JSON.parse JSON.stringify @workersTable

    # now remove messageData.uuid, this will be not showed
    worker.pop() for worker in @workersTable

    # finally create our table
    table.push worker for worker in @workersTable

  clearTerminal: ->
    process.stdout.write '\u001B[2J\u001B[0;0f' # clear terminal window

  cleanVariables: ->
    table = new Table tableOptions
    @workersTable   = []
    @workersPlain    = []
    @currentWorkers = []
    @currentHosts   = []

  showTable: ->
    @clearTerminal()
    @createTable()
    console.log table.toString()

  sendData: (command, hostname, name, data = "") =>
    @fetchInfoExchange (infoExchange) =>
      if name? and hostname?
        for worker in @workersPlain
          if worker[0] is name and worker[1] is hostname
            uuid = worker[7]

      # console.log "#{hostIndex}, #{workerIndex}, #{actionIndex}"
      # console.log "#{hostname}, #{name}, #{command}"

      infoExchange.publish "input.cli", @createRequest(command, hostname, uuid, data),
        appId: "#{@clikey}"
      return true

  createRequest: (command, hostname, uuid, data) ->
    cli        :
      command  : if command? then command else ""
      hostname : if hostname? then hostname else ""
      uuid     : if uuid? then uuid else ""
      data     : if data? then data else ""

  showDashboard : ->
    @selectDashboard (dashIndex) =>
      @clearTerminal()
      console.log table.toString()
      switch dashIndex
        when 0
          @statusAllWorkers()
          console.log "Refreshing data ..."
        when 1
          @selectHost (hostIndex) =>
            @clearTerminal()
            for row, i in table
              if row[1] is @currentHosts[hostIndex]
                row[1] = "#{row[1]}".inverse
            console.log table.toString()

            @selectWorker (workerIndex) =>
              @clearTerminal()
              for row, i in table
                if row[1] is "#{@currentHosts[hostIndex]}".inverse
                  if row[0] is @currentWorkers[workerIndex]
                    row[0] = "#{row[0]}".inverse
                  else
                    row[1] = @currentHosts[hostIndex]
              console.log table.toString()

              @selectAction (actionIndex) =>
                command  = ACTIONS[actionIndex]
                hostname = @currentHosts[hostIndex]
                name     = @currentWorkers[workerIndex]
                if command is "cancel"
                  @statusAllWorkers()
                  console.log "Refreshing data ..."
                else
                  @clearTerminal()
                  console.log table.toString()
                  if @sendData command, hostname, name
                    @statusAllWorkers()
                    console.log "Get and refresh data..."
        when 2
          @selectBatch (batchIndex) =>
            @clearTerminal()
            console.log table.toString()
            switch batchIndex
              when 0 #all
                console.log "WARNING: action will be perfomed on all available workers!".bold
                @selectAction (actionIndex) =>
                  command = ACTIONS[actionIndex]
                  if command is "cancel" #cancel
                    @statusAllWorkers()
                    console.log "Refreshing data ..."
                    return
                  else
                    @clearTerminal()
                    console.log table.toString()
                    if @sendData command, "", ""
                      @statusAllWorkers()
                      console.log "Get and refresh data..."
              when 1 #on same hostname
                @selectHost (hostIndex) =>
                  @clearTerminal()
                  for row, i in table
                    if row[1] is @currentHosts[hostIndex]
                      row[1] = "#{row[1]}".inverse
                  console.log table.toString()

                  @selectAction (actionIndex) =>
                    command  = ACTIONS[actionIndex]
                    hostname = @currentHosts[hostIndex]
                    if command is "cancel" #cancel
                      @statusAllWorkers()
                      console.log "Refreshing data ..."
                      return
                    else
                      @clearTerminal()
                      console.log table.toString()
                      if @sendData command, hostname, ""
                        @statusAllWorkers()
                        console.log "Get and refresh data..."
        when 3
          @selectBatch (batchIndex) =>
            @clearTerminal()
            console.log table.toString()
            switch batchIndex
              when 0 #all
                @clearTerminal
                program.prompt "Please write command to execute for all machines: ", (cmd) =>
                  if @sendData "cmd", "", "", cmd
                        @statusAllWorkers()
                        console.log "Get and refresh data..."
              when 1 #on same hostname
                console.log "Select hostname:"
                @currentHosts.push "custom hostname..."
                program.choose @currentHosts, (hostIndex) =>
                  @clearTerminal()
                  for row, i in table
                    if row[1] is @currentHosts[hostIndex]
                      row[1] = "#{row[1]}".inverse
                  console.log table.toString()
                  hostname = @currentHosts[hostIndex]
                  if hostname is "custom hostname..."
                    program.prompt "Please write hostname for sending command: ", (host) =>
                      @clearTerminal()
                      program.prompt "Please write command to execute for host '#{host}': ", (cmd) =>
                        if @sendData "cmd", host, "", cmd
                              @statusAllWorkers()
                              console.log "Get and refresh data..."
                  else
                    @clearTerminal()
                    program.prompt "Please write command to execute for host '#{hostname}': ", (cmd) =>
                      if @sendData "cmd", hostname, "", cmd
                            @statusAllWorkers()
                            console.log "Get and refresh data..."

        else #ignore
          return

  getInfo: () =>
    @clearTerminal()
    @showTable()
    console.log "Data refreshed at #{@getDate()}"
    @showDashboard()

  fetchExchange:(name, options, callback)->
    exchangeName  = "#{name}Exchange"
    readyEvent    = "#{exchangeName}Ready"
    if @[exchangeName] is null
      @once readyEvent, => @fetchInfoExchange callback
    else unless @infoExchange?
      @[exchangeName] = null
      @connection.exchange exchangeName, options,
        (exchange)=>
          @[exchangeName] = exchange
          @emit readyEvent
          callback exchange
    else callback @[exchangeName]


  fetchInfoExchange:(callback)->
    @fetchExchange 'info', @getInfoExchangeOptions(), callback

  getInfoExchangeOptions:->
    type        : 'topic'
    autoDelete  : no
    durable     : true

  statusAllWorkers: () =>
    @fetchInfoExchange (infoExchange) =>
      @cleanVariables()
      infoExchange.publish "input.cli", @createRequest("status"),
        appId: "#{@clikey}"

  connectApi: () ->
    {host, port, protocol, login, password, vhost, heartbeat} = @amqpOptions
    port              ?= 5672
    protocol          ?= 'amqp:'
    options           = {host, port, protocol} # but not vhost, because of a bug in node-amqp
    options.login     = login     if login?
    options.password  = password  if password?
    options.vhost     = vhost     if vhost?
    options.heartbeat = heartbeat if heartbeat?
    @connection       = amqp.createConnection options
    @connection.on "ready", =>
      @connection.exchange 'infoExchange', @getInfoExchangeOptions(), (exchange) =>
        @connection.queue "workerCli-#{@clikey}",
          durable: false
          autoDelete: true
        , (queue) =>
          queue.bind 'infoExchange', "output.cli.#{@clikey}"
          queue.on "queueBindOk", =>
            @fetchInfoExchange (infoExchange) =>
              infoExchange.publish "input.cli", @createRequest("status"),
                appId: "#{@clikey}"
            queue.subscribe (message, headers, deliveryInfo) =>
              messageData = JSON.parse message.data.toString("utf-8")
              # messageData = message.data.toString("utf-8")
              # console.log messageData
              if messageData.status?
                @parseStatusResponse messageData
                @getInfo()

do ->
  kontrol = new Kontrol
  kontrol.clearTerminal()
  console.log "Get latest data..."
  kontrol.connectApi()

