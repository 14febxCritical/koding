# this is a work in progress.
# it's doing proper cleanup and management of child processes
# use it with care, not all edge cases are covered.
#
# author @devrim

traverse = require 'traverse'
_        = require 'underscore'
fs       = require "fs"
hat      = require 'hat'
{exec,spawn,fork}   = require "child_process"
{EventEmitter} = require "events"


try
  fs.mkdirSync __dirname+"/.tmp/"
catch e
  # do nothing, probably dir is already there.

# guaranteed death.
process.on 'SIGTERM', ->
  console.log "going down"
  process.exit(0)


class Processes extends EventEmitter
  constructor:(options={})->
    {main} = options
    @list = {}
    @childProcessesContainerDir = __dirname+"/.tmp"
    if main
      previouschildProcessesContainerDir = @childProcessesContainerDir+"."+Date.now()
      fs.renameSync @childProcessesContainerDir, previouschildProcessesContainerDir
      fs.mkdirSync @childProcessesContainerDir
      exec "rm -rf #{previouschildProcessesContainerDir}",(err,stdout,stderr)->
        if err
          console.log "couldn't delete previous process tree at #{previouschildProcessesContainerDir}"
        else
          console.log "previous process tree is deleted."
  fork: (options,callback) ->    
    options.fork = yes      
    @run options,callback
  spawn: (options,callback)->
    options.spawn = yes
    @run options,callback

  run  : (options,callback) ->
    {name,monitor,onMessage,modulePath,args,opts,restart,restartInterval,cmd,log,onExit,stdout,stderr,verbose,die} = options
    onExit ?= ->
    
    name            ?= Date.now()
    restartInterval ?= 1000
    verbose         ?= no
    
    if "string" is typeof options.cmd
      cmdA = cmd.split(" ")
    else
      console.log e = "[PROCESSES][ERROR][#{name}] Can't start without a valid cmd param." # if verbose
      return callback e 

    

    if options.fork
      if options.pool
        opts = traverse(options).clone()
        delete opts.pool
        @run opts for i in [0..options.pool.size]
        return
      else
        cp = fork cmdA[0],cmdA[1...],opts      
    else
      cp = spawn cmdA[0],cmdA[1...]
      cp.stdout.pipe stdout if stdout
      cp.stderr.pipe stderr if stderr      

    console.log "[PROCESSES][#{name}]Started the process: #{name} with #{cp.pid}" if verbose
    @createPidFile cp.pid

    childObj = 
      name    : name
      process : cp
      pid     : cp.pid
      verbose : verbose

    if cmd
      childObj.cmd = cmd 
    else if modulePath
      childObj.fork = {modulePath,args,options}

    if @list[name]
      console.log "[WARN][Processes] #{name} is not unique. Provide unique name for every process, so I can kill them properly." 

    @list[name] = childObj          



    
    if die?.after
      console.log "[PROCESSES][#{name}]i will kill this process:#{name} every #{die.after}msecs" if verbose
      setTimeout => 
        console.log "[PROCESSES][#{name}]it's time you die process:#{name}" if verbose      
        @kill name
      ,die.after

    cp.on 'exit',=>
      console.log "[PROCESSES][#{name}] did exit." if verbose
      @emit "exit",cp.pid,name
      delete @list[name]
    cp.on 'close', () =>      
      console.log "[PROCESSES][#{name}] did close." if verbose
      @emit "close",cp.pid,name
      onExit cp.pid,name
      if restart is yes
        restartInterval = 1 unless restartInterval
        setTimeout =>
          @run options
        ,restartInterval
        console.log "[PROCESSES][#{name}] Restarting the process in #{restartInterval} msecs." if verbose   
    cp.on 'message',(msg)->
      onMessage msg if "function" is typeof onMessage        

    return childObj

    # cp.on 'message',(msg)=>
    #   @emit 'message',childObj,msg
    #   onMessage msg if onMessage

  createPidFile : (pid)->
    fs.writeFileSync "#{@childProcessesContainerDir}/#{process.pid}.#{pid}"

  get : (name)->
    if @list[name]
      return @list[name].process
    else
      console.log "[ERROR][Processes] #{name} Can't be found." 


  fetchChildren : (parentPid,callback)->
    findChildren = (arr, pid) ->
      findChildrenRec = (pid,root=yes)->
        c={}
        pid = ""+pid
        i = -1
        arr.forEach (item)->
          [parent,child] = item.split(".")
          if parent is pid
            c[child] = findChildrenRec child,no
        return c

      arr = traverse(findChildrenRec pid).paths()
      arr.forEach (group) -> group.reverse()
      arr = _.sortBy arr,(a)-> a.length*-1
      return _.uniq _.flatten arr,yes

    fs.readdir @childProcessesContainerDir,(err,list)->
      if err
        callback err
      else
        callback null,findChildren list,parentPid

  killAllChildren : (parentPid, callback) ->
    @fetchChildren parentPid,(err,orderedKillList)->
      console.log "ordered kill list:"+orderedKillList
      unless err
        pidPair = []
        orderedKillList.forEach (pid)->
          console.log "killing children: #{pid}"
          try
            pidPair.push pid
            process.kill(pid*1)
            if pidPair.length is 2
              pidPair.reverse()
              deleteFile = pidPair.join(".")
              console.log "deleting"+deleteFile
              fs.unlinkSync deleteFile
              pidPair.shift()
          catch e
            console.log "child process #{pid} did not exist. not killed by me."
        callback null
  
  sendMessage : (name,msg)->
    if @list[name]?.process?.send
      @list[name].process.send msg


  kill :(name,callback=->)->
    console.log "[PROCESSES][#{name}] cant kill #{name}, couldn't find it." unless @list[name]
    pid = @list[name].pid
    console.log "[PROCESSES][#{name}] killing parent: #{pid}"
    @killAllChildren pid,(err,res)->
      console.log "[PROCESSES][#{name}] killing #{name} #{pid}"
      process.kill pid

module.exports = Processes