# this is a work in progress.
# it's doing proper cleanup and management of child processes
# use it with care, not all edge cases are covered.
#
# author @devrim

{argv}              = require 'optimist'
traverse            = require 'traverse'
_                   = require 'underscore'
fs                  = require "fs"
os                  = require "os"
hat                 = require 'hat'
{exec,spawn,fork}   = require "child_process"
{EventEmitter}      = require "events"
Worker              = require 'koding-worker'
{kontrold}          = require('koding-config-manager').load("main.#{argv.c}")

try
  fs.mkdirSync __dirname+"/.tmp/"
catch e
  # do nothing, probably dir is already there.

class Processes extends EventEmitter
  constructor:(options={})->
    {main}        = options
    @list         = {}
    @name         = ''
    @child        = null
    @childProcessesContainerDir = __dirname+"/.tmp"
    if main
      previouschildProcessesContainerDir = @childProcessesContainerDir+"."+Date.now()
      fs.renameSync @childProcessesContainerDir, previouschildProcessesContainerDir
      fs.mkdirSync @childProcessesContainerDir
      exec "rm -rf #{previouschildProcessesContainerDir}",(err,stdout,stderr)->
        if err
          console.log "couldn't delete previous process tree at #{previouschildProcessesContainerDir}"
        #else
        #  console.log "previous process tree is deleted."
  fork: (options,callback) ->
    options.fork = yes
    @name = options.name
    @run options,callback, (cb) =>
      callback cb

  spawn: (options,callback)->
    options.spawn = yes
    @run options,callback

  exec: (cmd,callback)->
    @spawn
      name  : Date.now()
      cmd   : cmd
      restart : no
      stdout : process.stdout
      stderr : process.stderr
      onExit  : callback

  run: (options,callback) ->
    {name,restartInterval,verbose} = options

    name            ?= Date.now()
    restartInterval ?= 1000
    verbose         ?= no

    if options.kontrol?.enabled
      console.log "[PROCESSES][#{name}] kontrold authorization enabled"
      @kontroldProcess options
    else
      console.log "[PROCESSES][#{name}] kontrold authorization disabled"
      @child = @startProcess options
      @populateChildObject options, @child

  getDate: ->
    d = new Date()
    pad = (n) ->
      (if n < 10 then "0" + n else n)
    d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "Z"

  startProcess: (options) ->
    {name,opts,cmd,stdout,stderr} = options

    if "string" is typeof options.cmd
      cmdA = cmd.split(" ")
    else
      console.log e = "[PROCESSES][ERROR][#{name}] Can't start without a valid cmd param." if verbose
      return callback e

    if options.fork
      @child = fork cmdA[0],cmdA[1...],opts
    else
      @child = spawn cmdA[0],cmdA[1...]
      @child.stdout.pipe stdout if stdout
      @child.stderr.pipe stderr if stderr

    return @child

  kontroldProcess: (options) ->
    {name,restart,verbose} = options

    console.log "[PROCESSES][#{@name}] force mode enabled. Trying to stop and kill all other #{name} workers" if verbose and options.kontrol.forceStart


    workerProcess = new Worker {
      kontrold
      command            : if options.kontrol.registerToProxy then "addWithProxy" else "add"
      number             : 1
      name               : options.name
      uuid               : hat()
      option             : if options.kontrol.forceStart then 'force' else ''
      interval           : options.reportInterval
      port               : options.kontrol.port
    }

    # Disable restart for kontrold processes
    options.restart = no

    workerProcess.connect()
    workerProcess.startReporter()
    console.log "[PROCESSES][#{name}] connected to Kontrold. Waiting for instructions..." if verbose

    #############
    ### Start ###
    #############
    workerProcess.on 'permissionToRun', =>
      # Don't create a new fork if we start it again (i.e after a stop)
      unless @list[name]?.name is name
          @child = @startProcess options
          @populateChildObject options, @child

          # Update kontrold worker information with our newly created pid.
          workerProcess.fetchWorkerExchange (workerExchange) =>
            workerProcess.worker.message.command = "update"
            workerProcess.worker.status = 1
            workerProcess.worker.pid = @child.pid
            workerProcess.worker.timestamp = @getDate()
            workerExchange.publish "input.worker", {worker: workerProcess.worker},
              appId: "#{workerProcess.worker.uuid}"

      console.log "[PROCESSES][#{name}] received a 'start' message from Kontrold. Sending SIGCONT to the child_process." if verbose
      @child.kill 'SIGCONT' #If not currently stopped, this signal is ignored by default
      if options.kontrol.nodeProcess
        setTimeout =>
          console.log "[PROCESSES][#{name}] sending 'startRequest' to the child_process " if verbose
          @sendMessage name, 'startRequest'
        , 400 # http://stackoverflow.com/questions/14884495/missing-message-when-using-child-process-send-in-coffeescript
      else
        workerProcess.worker.status = 1

    #############
    ### Stop  ###
    #############
    workerProcess.on 'stopRequest', =>
      console.log "[PROCESSES][#{name}] received 'stop' message from Kontrold." if verbose
      if options.kontrol.nodeProcess
        console.log "[PROCESSES][#{name}] sending 'stopRequest' to child_process" if verbose
        @sendMessage name, 'stopRequest'
      else
        workerProcess.worker.status = 0
        console.log "[PROCESSES][#{name}] sending SIGSTOP to the child_process. Worker is stopped." if verbose
        @child.kill 'SIGSTOP'

    #############
    ### Kill  ###
    #############
    workerProcess.on 'killWorkerProcess', =>
      workerProcess.worker.status = 4
      console.log "[PROCESSES][#{name}] received 'kill' message from Kontrold. Sending SIGTERM to the child_process." if verbose
      # @child.kill 'SIGKILL' #try this in the future
      @kill name

    #############
    ### Check ###
    #############
    workerProcess.on 'checkProcess', =>
      console.log "[PROCESSES][#{name}] Checking worker if alive" if verbose
      unless @list[name]?.name is name
        console.log "[PROCESSES][#{name}] Worker is death" if verbose
      else
        console.log "[PROCESSES][#{name}] Worker is alive" if verbose
        workerProcess.fetchWorkerExchange (workerExchange) =>
          workerProcess.worker.message.command = "ack"
          workerExchange.publish "input.worker", {worker: workerProcess.worker},
            appId: "#{workerProcess.worker.uuid}"

    @on 'childData',(msg) =>
      onMessage msg if "function" is typeof onMessage
      switch msg
        when 'startDone'
          workerProcess.worker.status = 1
          console.log "[PROCESSES][#{name}] received 'startDone' message from child_process. Worker is ready and running." if verbose
        when 'stopDone'
          workerProcess.worker.status = 0
          console.log "[PROCESSES][#{name}] received 'stopDone' message from child_process." if verbose
          console.log "[PROCESSES][#{name}] sending SIGSTOP to the child_process. Worker is stopped." if verbose
          @child.kill 'SIGSTOP'

    @on 'monitorData', (data) =>
      # console.log "[PROCSSES][#{name}] Got monitor data from child process" if verbose
      delete data['process-monitor']
      data['uuid'] = workerProcess.worker.uuid
      workerProcess.fetchWorkerExchange (workerExchange) =>
        workerProcess.worker.message.command = "ack"
        workerExchange.publish "input.worker", {monitor: data},
          appId: "#{workerProcess.worker.uuid}"

    ################################
    ### HANDLE SIGNALS and KILLS ###
    ################################

    # When child_process dies (aka kill -9 <child_pid>, killRequest,etc..)
    @on 'exit', =>
      workerProcess.worker.status = 4
      workerProcess.fetchWorkerExchange (workerExchange) =>
        workerProcess.worker.message.command = "ack"
        workerExchange.publish "input.worker", {worker: workerProcess.worker},
          appId: "#{workerProcess.worker.uuid}"

    # When doing ctrl+c, let kontrold now we are dead
    process.on 'SIGINT', =>
      workerProcess.worker.status = 5
      workerProcess.fetchWorkerExchange (workerExchange) =>
        workerProcess.worker.message.command = "ack"
        workerExchange.publish "input.worker", {worker: workerProcess.worker},
          appId: "#{workerProcess.worker.uuid}"
        process.exit(0)

    # When sending SIGTERM (aka kill -15, killall, ...), let kontrold know we are death
    process.on 'SIGTERM', =>
      workerProcess.worker.status = 5
      workerProcess.fetchWorkerExchange (workerExchange) =>
        workerProcess.worker.message.command = "ack"
        workerExchange.publish "input.worker", {worker: workerProcess.worker},
          appId: "#{workerProcess.worker.uuid}"
        process.exit(0)

  populateChildObject: (options, @child) ->
    {name,onMessage,modulePath,args,restart,restartInterval,cmd,log,onExit,stdout,stderr,verbose,die} = options
    onExit ?= ->
    console.log "[PROCESSES][#{name}] started the process: #{name} with pid: #{@child.pid}" if verbose
    @createPidFile @child.pid,name

    childObj =
      name    : name
      process : @child
      pid     : @child.pid
      verbose : verbose

    if cmd
      childObj.cmd = cmd
    else if modulePath
      childObj.fork = {modulePath,args,options}

    if @list[name]
      d = Date.now()
      console.log "[WARN][Processes] process name '#{name}' not unique. to be able to kill it properly it is now: #{name}-#{d}" if verbose
      name += "-"+d

    @list[name] = childObj

    if die?.after
      console.log "[PROCESSES][#{name}]i will kill this process:#{name} every #{die.after}msecs" if verbose
      setTimeout =>
        console.log "[PROCESSES][#{name}]it's time you die process:#{name}" if verbose
        @kill name
      ,die.after

    @child.on 'exit',=>
      console.log "[PROCESSES][#{name}] did exit." if verbose
      @emit "exit",@child.pid,name
      delete @list[name]
    @child.on 'close', () =>
      console.log "[PROCESSES][#{name}] did close." if verbose
      @emit "close",@child.pid,name
      onExit @child.pid,name
      if restart is yes
        restartInterval = 1 unless restartInterval
        setTimeout =>
          @run options
        ,restartInterval
        console.log "[PROCESSES][#{name}] restarting the process in #{restartInterval} msecs." if verbose
    @child.on 'message',(msg) =>
      onMessage msg if "function" is typeof onMessage
      if msg['process-monitor']
        @emit "monitorData", msg
      else if options.kontrol.enabled and options.kontrol.nodeProcess
        @emit "childData", msg

    # console.log @list
    return childObj

  createPidFile : (pid,name)->
    fs.writeFileSync "#{@childProcessesContainerDir}/#{process.pid}.#{pid}",""

  get : (name)->
    if @list[name]
      return @list[name].process
    else
      console.log "[ERROR][Processes] #{name} Can't be found."

  fetchChildren: (parentPid,callback)->
    findChildren = (arr, pid) ->
      findChildrenRec = (pid,root=yes)->
        c={}
        pid = ""+pid
        i = -1
        arr.forEach (item)->
          [parent,child] = item.split(".")
          if parent is pid
            c[child] = findChildrenRec child,no
        return c

      arr = traverse(findChildrenRec pid).paths()
      arr.forEach (group) -> group.reverse()
      arr = _.sortBy arr,(a)-> a.length*-1
      return _.uniq _.flatten arr,yes

    fs.readdir @childProcessesContainerDir,(err,list)->
      if err
        callback err
      else
        callback null,findChildren list,parentPid

  killAllChildren: (parentPid, callback) ->
    @fetchChildren parentPid,(err,orderedKillList)->
      console.log "ordered kill list:"+orderedKillList
      unless err
        pidPair = []
        orderedKillList.forEach (pid)->
          console.log "killing children: #{pid}"
          try
            pidPair.push pid
            process.kill(pid*1)
            if pidPair.length is 2
              pidPair.reverse()
              deleteFile = pidPair.join(".")
              console.log "deleting"+deleteFile
              fs.unlinkSync deleteFile
              pidPair.shift()
          catch e
            console.log "child process #{pid} did not exist. not killed by me."
        callback null

  sendMessage: (name,msg)->
    if @list[name]?.process?.send
      @list[name].process.send msg

  kill: (name,callback=->)->
    unless @list[name]
      console.log "[PROCESSES][#{name}] cant kill #{name}, couldn't find it."
    else
      pid = @list[name].pid
      console.log "[PROCESSES][#{name}] killing parent: #{pid}"
      @killAllChildren pid,(err,res)->
        console.log "[PROCESSES][#{name}] killing #{name} #{pid}"
        process.kill pid

module.exports = Processes
