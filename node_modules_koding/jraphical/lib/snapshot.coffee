{EventEmitter} = require 'events'
{Model,daisy,dash} = require 'bongo'
Traverse = require 'traverse'


class SnapshotFeed extends Model
  
  @share()
  
  @set
    sharedMethods :
      static      : ['joinFeed']
    schema        :
      items       : [String]
    
  
  @joinFeed =(name, callback)->
    @one {name}, (err, feed)->
      if err
        callback err
      else unless feed?
        callback new Error 'No feed.'
      else
        out = []
        Object
          .keys(feed.items)
          .sort((a, b)-> a - b)
          .forEach (key)->
            out.push feed.items[key]
        
        callback null, "feed:#{out.join('\n')}"

module.exports = class Snapshot
  
  watchedConstructors_ = []
  
  @watchConstructor =(constructor)->
    watchedConstructors_.push constructor
  
  @isWatching =(constructor)->
    constructor in watchedConstructors_
  
  createSnapshot =(model, errs, callback)->
    if model.fetchSubject?
      model.fetchSubject (err, subject)->
        if err
          errs.push err
          callback()
        else
          unless subject?
            console.log 'There was no subject', model
          else unless 'function' is typeof subject.fetchTeaser
            model.update $set: snapshot: JSON.stringify(subject), -> callback()
          else
            subject.fetchTeaser? (err, teaser)->
              if err
                errs.push err
              else
                model.update $set: snapshot: JSON.stringify(teaser), -> callback()
    else
      model.update $set: snapshot: JSON.stringify(model)
      callback()

  updateSnapshots =(errs, queue, models)->
    for model in models
      queue.push createSnapshot.bind null, model, errs, -> queue.fin()
  
  updateAllSnapshots =(id, callback)->
    queue = []
    errs = []
    constructor = watchedConstructors_[0]
    constructor?.all snapshotIds: id, (err, models)->
      updateSnapshots errs, queue, models if models.length
      dash queue, ->
        if errs.length
          [err] = errs
        else
          err = null
        callback? err
  
  @clearById =(id, callback)->
    updateAllSnapshots id, callback
  
  @create = (node, callback=->)->
    createSnapshot node, [], callback

  @capture = (node, teaser, index, callback)->
    
    delete node.data?.snapshot unless teaser?
    
    snapshot = new Snapshot(teaser ? node)
    
    # {encapsulatedBy, name} = node.constructor
    # {name} = encapsulatedBy if encapsulatedBy
    
    node.update $set:
      snapshot    : snapshot.json
      snapshotIds : snapshot.ids
    , (err)->
      if err
        callback err
      else
        callback null, snapshot.json
        # operation = $set: {}
        # operation.$set["items.#{index}"] = snapshot.json
        # SnapshotFeed.update {name}, operation, {
        #   upsert: yes
        # }, (err)->
        #   if err
        #     callback err
        #   else
        #     callback null, snapshot.json
  
  collectIds =(teaser, ids=[])->
    new Traverse(teaser).map (node)->
      if @key is '_id' then ids.push node
    return ids
  
  constructor:(@teaser)->
    @json = JSON.stringify teaser
    @ids = collectIds(teaser)
  
  toString:-> @json
  