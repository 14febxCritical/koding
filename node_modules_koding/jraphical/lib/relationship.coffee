{Base, Model, ObjectId} = require 'bongo'

module.exports = class Relationship extends Model

  {Base, dash} = require 'bongo'

  @share()

  @set
    feedable:             yes
    broadcastable:        no
    indexes:
      sourceName:         'sparse'
      sourceId:           'sparse'
      targetName:         'sparse'
      targetId:           'sparse'
      as:                 'sparse'
      timestamp:          'sparse'
    sharedMethods:
      static:             ['within']
    schema:
      sourceName:         String
      abstractSourceName: String
      sourceId:           ObjectId
      targetName:         String
      abstractTargetName: String
      targetId:           ObjectId
      as:                 String
      data:               Object
      timestamp:
        type:             Date
        default:          -> new Date

  @getDeleteHelper =(selector, orientation, callback)->
    -> Relationship.all selector, (err, rels)->
      if err
        callback err
      else
        queue = []
        rels.forEach (rel)->
          queue.push ->
            constructor = Base.constructors[rel.getAt orientation+'Name']
            constructor.remove _id: rel.getAt(orientation+'Id'), -> queue.fin()
        dash queue, callback

  @within =(sourceIds, options, callback)->
    [callback, options] = [options, callback] unless callback
    options or= {}
    {as} = options
    delete options.as

    shared = $in: Object.keys(Base.sharedConstructors)

    selector = {
      sourceId:
        $in: sourceIds.map (id)->
          if 'string' is typeof id then ObjectId(id)
          else id
      $or: [
        {targetName: shared}
        {sourceName: shared}
      ]
    }

    selector.as = as if as?

    Relationship.some selector, options, callback

  flag:(prop, bool=yes)->
    flag = {}
    flag["data.#{prop}"] = bool
    @update $set: flag

  unflag:(prop)->
    @flag prop, no

  archive:-> #TODO: implement Archiver

  fetchOther =(name, _id, callback)->
    unless name and _id
      callback new Error "Couldn't resolve relation."
    else
      constructor = Base.constructors[name]
      if constructor?.one?
        constructor.one {_id}, callback

  fetchSource:(callback)->
    fetchOther @sourceName, @sourceId, callback

  fetchTarget:(callback)->
    fetchOther @targetName, @targetId, callback

  fetchTeaser:(callback)->
    sourceConstructor = Base.constructors[@sourceName]
    targetConstructor = Base.constructors[@targetName]
    unless sourceConstructor or targetConstructor
      callback new Error 'Invalid relationship!'
    else
      sourceConstructor.one _id: @sourceId, (err, @source)=>
        if err
          callback err
        else
          targetConstructor.one _id: @targetId, (err, @target)=>
            if err
              callback err
            else
              callback null, @


  save_ = @::save
  save:(callback)->
    save_.call this, (err, model)=>
      console.log "save called"
      console.log @
#      console.log arguments
      return callback err if err
      #      @constructor.emit 'RelationshipRemoved', this
      callback model

  remove_ = @::remove
  remove:(selector, callback)->
    remove_.call this, selector, (err)=>
      console.log "instance remove called"
#      console.log @
      return callback err if err
      @constructor.emit 'RelationshipRemoved', this
      callback err


  @remove_ = @remove
  @remove:(selector, callback)->
    console.log selector
    @remove_.call null, selector, (err)->
      console.log "static remove called"
#      console.log @
      return callback err if err

#      @emit 'hebele', selector
      callback err
