{Base, Model, ObjectId} = require 'bongo'

module.exports = class Relationship extends Model

  {Base, dash} = require 'bongo'

  @share()

  #TODO: implement data slugs

  @set
    softDelete:           yes
    feedable:             yes
    broadcastable:        no
    indexes:
      sourceName:         'sparse'
      sourceId:           'sparse'
      targetName:         'sparse'
      targetId:           'sparse'
      as:                 'sparse'
      timestamp:          'sparse'
    sharedMethods:
      static:             ['within']
    sharedEvents:
      instance:           []
      static:             []
    schema:
      sourceName:         String
      abstractSourceName: String
      sourceId:           ObjectId
      # sourceSlug:         String
      targetName:         String
      abstractTargetName: String
      targetId:           ObjectId
      # targetSlug:         String
      as:                 String
      data:               Object
      timestamp:
        type:             Date
        default:          -> new Date

  @getDeleteHelper =(selector, orientation, callback)->
    -> Relationship.all selector, (err, rels)->
      if err
        callback err
      else
        queue = []
        rels.forEach (rel)->
          queue.push ->
            constructor = Base.constructors[rel.getAt orientation+'Name']
            constructor.remove _id: rel.getAt(orientation+'Id'), -> queue.fin()
        dash queue, callback

  @within =(sourceIds, options, callback)->
    [callback, options] = [options, callback] unless callback
    options or= {}
    {as} = options
    delete options.as

    shared = $in: Object.keys(Base.sharedConstructors)

    selector = {
      sourceId:
        $in: sourceIds.map (id)->
          if 'string' is typeof id then ObjectId(id)
          else id
      $or: [
        {targetName: shared}
        {sourceName: shared}
      ]
    }

    selector.as = as if as?

    Relationship.some selector, options, callback

  flag:(prop, bool=yes)->
    flag = {}
    flag["data.#{prop}"] = bool
    @update $set: flag

  unflag:(prop)->
    @flag prop, no

  archive:-> #TODO: implement Archiver

  fetchOther =(name, _id, callback)->
    unless name and _id
      callback new Error "Couldn't resolve relation."
    else
      constructor = Base.constructors[name]
      if constructor?.one?
        constructor.one {_id}, callback

  fetchSource:(callback)->
    fetchOther @sourceName, @sourceId, callback

  fetchTarget:(callback)->
    fetchOther @targetName, @targetId, callback

  fetchTeaser:(callback)->
    sourceConstructor = Base.constructors[@sourceName]
    targetConstructor = Base.constructors[@targetName]
    unless sourceConstructor or targetConstructor
      callback new Error 'Invalid relationship!'
    else
      sourceConstructor.one _id: @sourceId, (err, @source)=>
        if err
          callback err
        else
          targetConstructor.one _id: @targetId, (err, @target)=>
            if err
              callback err
            else
              callback null, @


  save_ = @::save
  save:(callback)->
    save_.call this, (err, model)=>
      return callback err if err
      @constructor.emit 'RelationshipSaved', this
      callback err, model

  remove_ = @::remove
  remove:(callback)->
    remove_.call this, (err)=>
      return callback err if err
      @constructor.emit 'RelationshipRemoved', this
      callback err

  @oldStaticRemove = @remove
  @remove =(selector, callback)->
    Relationship.all selector, (err, res)=>
      @oldStaticRemove selector, (err)->
        return callback err if err
        if res.length > 0
          for rel in res
            Relationship.emit "RelationshipRemoved", rel
        callback err

  update_ = @::update
  update:(operation, callback)->
    update_.call this, operation, (err)=>
      return callback err if err
      @constructor.emit 'RelationshipUpdated', this
      callback err

  @oldStaticUpdate = @update
  @update =(selector, operation, callback)->
    Relationship.all selector, (err, res)=>
      @oldStaticUpdate selector, operation, (err)->
        return callback err if err
        if res.length > 0
          for rel in res
            Relationship.emit "RelationshipUpdated", rel
        callback err
