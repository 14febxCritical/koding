{Base, Model, ObjectId, Inflector, Register, race, daisy, dash} = require 'bongo'
{extend, groupBy} = require 'underscore'

Relationship = require './relationship'
Graphlet = require './graphlet'
Snapshot = require './snapshot'

module.exports = class Module extends Model

  @limitEdges = (max, args)->
    switch args.length
      when 1
        [callback] = args
        selector = {}
        options = limit: 10
      when 2
        [selector, callback] = args
        options = limit: 10
      when 3
        [selector, options, callback] = args
        options.limit = Math.min options.limit ? 10, 100
      else
        throw new TypeError """
          Module#limitEdges: expected 1, 2 or 3 parameters.
          """
    return [selector, options, callback]

  @attachInterface =(verb, noun, isPlural, fn)->
    [fn, lowFirstLetter] = [lowFirstLetter, fn] unless fn
    name = @getInterfaceName verb, noun, isPlural, yes
    @::[name] = fn
    @

  @getDefaultRole =-> 'related'

  @setRelationships = do ->
    needsPopulated =(type)->
      'string' is typeof type or \
      Array.isArray(type) and type.filter((item)->'string' is typeof item).length
    setRelationships = (constructor, relationships)->
      if 'function' is typeof relationships
        relationships = relationships.call constructor
      constructor.relationships = relationships
      for own name, def of relationships
        if needsPopulated(def.targetType)
          do (def)->
            process.nextTick -> constructor.emit 'needsPopulated', def, 'targetType'
        chain = def.inheritanceChain?()
        if chain and Module in chain
          def = targetType: def
        def.as or= def.targetType.getDefaultRole()
        constructor
        .attachInterface('add', name, no, getAdder_ constructor, name, def)
        .attachInterface('assure', name, no, getAssurer_ constructor, name, def)
        .attachInterface('remove', name, no, getRemover_ constructor, name, def)
        .attachInterface('fetch', name, yes, getFetcher_ constructor, name, def)
        .attachInterface('fetch', name, no, getFetcher_ constructor, name, def, yes)
        .attachInterface('count', name, yes, getCounter_ constructor, name, def)
    (relationships)->
      constructor = @
      if 'function' is typeof relationships
        # when you pass "relationships" as a function, it will be defered until the next tick.
        # this can be useful for resolving circular dependencies (a requirement for graphs).
        process.nextTick setRelationships.bind null, constructor, relationships
      else
        setRelationships constructor, relationships
      constructor

  # fetchSubject:(callback)-> callback null, @ # this is the stub version.

  @collectTeasersCallback = (callback, skip=0)->
    (err, nodes)->
      teasers = []
      collectTeasers = race (i, node, fin)->
        if node.snapshot?
          process.nextTick ->
            teasers[i] = node.snapshot.replace(/^json:/, '')
            fin()
        else
          unless node.fetchSubject?
            # process.nextTick ->
            #Snapshot.capture node, null, i, (err, snapshot)->
            process.nextTick ->
              teasers[i] = JSON.stringify(node)
              fin()
          else
            node.fetchSubject (err, subject)->
              if err
                callback err
              else
                subject.fetchTeaser (err, teaser)->
                  if err
                    callback err
                  else
                    Snapshot.capture node, teaser, i, (err, snapshot)->
                      teasers[i] = snapshot
                      fin()
      , ->
        out = 'feed:'+teasers.join '|||'
        callback null, out
      if nodes.length
        collectTeasers node for node in nodes
      else
        callback null
      return

  @collectTeasersAllCallback = (callback)->
    (err, nodes)->
      teasers = []
      collectTeasersAll = race (i, node, fin)->
        teasers[i] = []
        node.fetchSubjects (err, subjects)->
          if err
            callback err
          else
            collectTeasers = race (j, subject, fin)->
              subject.fetchTeaser (err, teaser)->
                if err
                  callback err
                else
                  teasers[i][j] = teaser
                  fin()
            , -> fin()
            collectTeasers subject for subject in subjects
      , -> callback null, teasers
      collectTeasersAll node for node in nodes when node.fetchSubject?
      return

  getOrientation =(def)->
    orientation =
      if def.sourceType? then ['source', 'target']
      else if def.targetType? then ['target','source']
      else throw new Error 'Invalid relationship!'

  getCounter_ =(constructor, name, def)->
    ->
      model = this

      switch arguments.length
        when 1
          [callback] = arguments
        when 2
          [selector, callback] = arguments
        when 3
          [selector, targetSelector, callback] = arguments

      selector ?= {}
      selector.as ?=
        if 'string' is typeof def.as then def.as
        else $in: def.as
      orientation   = getOrientation(def)
      outgoingName  = "#{orientation[0]}Name"
      outgoingType  = "#{orientation[0]}Type"
      incomingName  = "#{orientation[1]}Name"
      incomingId    = "#{orientation[1]}Id"

      [orientation] = orientation

      selector[outgoingName] or= \
        if Array.isArray(def[outgoingType])
          types = def[outgoingType].map((type)->
            if type.encapsulatedSubclasses?
              type.encapsulatedSubclasses.map (subtype)-> subtype.name
            else
              type.name
          )
          types = types.reduce ((acc, item)-> (acc).concat item), []
          $in: types
        else if def[outgoingType].encapsulatedSubclasses?
          $in: def[outgoingType].encapsulatedSubclasses.map (type)-> type.name
        else
          def[outgoingType].name

      selector[incomingName] = constructor.name
      selector[incomingId]   = model.getId()

      unless targetSelector
        Relationship.count selector, callback
      else
        Relationship.someData selector, {targetId:1, targetName:1}, (err, cursor)->
          if err then callback err
          else
            cursor.toArray (err, docs)->
              if err then callback err
              else unless docs?.length then callback null, 0
              else

                groups = groupBy docs, outgoingName
                totalCount = 0
                queue = Object.keys(groups).map (constructorName)->->
                  groupedDocs = groups[constructorName]
                  idSelector = {_id: $in: (doc.targetId for doc in groupedDocs)}
                  extend targetSelector, idSelector
                  konstructor = Base.constructors[constructorName]
                  konstructor.count targetSelector, (err, count)->
                    if err then queue.fin err
                    else
                      totalCount += count
                      queue.fin()
                dash queue, -> callback null, totalCount


  getFetcher_ =(constructor, name, def, onlyOne=no)->
    if onlyOne
      limit = 1
    ->
      model = @
      args = arguments
      switch args.length
        when 1
          [callback] = args
        when 2
          [selector, callback] = args
        when 3
          [selector, options, callback] = args
          if options.targetOptions
            {options, targetOptions} = options
            options or= {}
      if 'string' is typeof selector
        selector = as: selector
      selector or= {}
      selector.as or=
        if 'string' is typeof def.as
          def.as
        else
          $in: def.as
      orientation   = getOrientation(def)
      outgoingName  = "#{orientation[0]}Name"
      outgoingType  = "#{orientation[0]}Type"
      incomingName  = "#{orientation[1]}Name"
      incomingId    = "#{orientation[1]}Id"

      [orientation] = orientation

      selector[outgoingName] or= \
        if Array.isArray(def[outgoingType])
          types = def[outgoingType].map((type)->
            if type.encapsulatedSubclasses?
              type.encapsulatedSubclasses.map (subtype)-> subtype.name
            else
              type.name
          )
          types = types.reduce ((acc, item)-> (acc).concat item), []
          $in: types
        else if def[outgoingType].encapsulatedSubclasses?
          $in: def[outgoingType].encapsulatedSubclasses.map (type)-> type.name
        else
          def[outgoingType].name

      selector[incomingName] = constructor.name
      selector[incomingId]   = model.getId()
      idField = "#{orientation}Id"
      fields = {}
      fields[idField] = 1
      fields['data.flags'] = 1
      fields["#{orientation}Name"] = 1
      fields['timestamp'] = 1

      Relationship.someData selector, fields, options, (err, cursor)->
        if err
          callback err
        else
          cursor.toArray (err, docs)->
            if err
              callback err
            else unless docs?.length
              callback null, unless limit then []
            else
              ordered = {}
              (doc[idField] for doc in docs).forEach (id, index)->
                ordered[id] = index unless ordered[id]?

              groups = groupBy docs, outgoingName

              results = []
              collectOthers = race (i, type, group, next)->
                ids = (rel[idField] for rel in group)
                flags = {}
                timestamps = {}
                ids.forEach (id, index)->
                  flag = group[index].data?.flags
                  flags[id] = flag if flag
                  timestamps[id] = group[index].timestamp
                targetOptions or= {}
                if targetSelector = targetOptions.selector or targetOptions.query
                  delete targetOptions.selector
                  delete targetOptions.query
                else
                  targetSelector = {}

                if targetOptions.options?
                  targetOptions = targetOptions.options

                Base.constructors[type]#.inCollectionBySource(model)
                  .some extend(targetSelector,
                    _id: $in: ids
                  ), targetOptions, (err, others)->
                    if others?
                      others = for other in others
                        other.flags_ = flags[other.getId()]
                        other.timestamp_ = timestamps[other.getId()]
                        other
                      results = results.concat others
                    next()
              , ->
                if limit
                  [results] = results
                else
                  sortedResults = []
                  results.forEach (result)->
                    sortedResults[ordered[result.getId()]] = result
                  results = sortedResults.filter (value)-> value?
                callback null, results

              for own type, group of groups
                collectOthers type, group

  getAdder_ =(constructor, name, def)->
    (target, options, callback)->
      if 'function' is typeof options
        callback = options
        options = {}
      else unless callback
        callback = ->
      {targetType, as} = def
      if options
        if 'string' is typeof options
          as = options
        else if options.as
          {as} = options
      if Array.isArray as
        throw new Error \
          """
          You must specify the role when there are multiple options available!
          """
      unless target.constructor is targetType or
             target.constructor.encapsulatedBy is targetType
        if Array.isArray(targetType)
          if target.constructor in targetType
            targetType = target.constructor
          else if target.constructor.encapsulatedBy in targetType
            targetType = target.constructor.encapsulatedBy
          else
            return callback new TypeError 'Type mismatch'
        else
          return callback new TypeError 'Type mismatch'
      rdef = {
        targetId    : target.getId()
        targetName  : targetType.name
        sourceId    : @getId()
        sourceName  : constructor.name
        as
      }
      if target.constructor isnt targetType
        rdef.abstractTargetName = targetType.name
        rdef.targetName = target.constructor.name
      unless target.getId()
        callback new Error 'No target id!'
      else
        new Relationship(rdef).save (err, docs)->
          if err
            callback err
          else if options?.respondWithCount
            delete rdef.targetId
            Relationship.count rdef, (err, count)->
              if err
                callback err
              else
                callback null, docs, count
          else
            callback err, docs

  getRemover_ =(constructor, name, def)->
    (target, options, callback)->
      [callback, options] = [options, callback] unless callback
      {targetType, as} = def
      as = as[0] if Array.isArray as
      if options
        if 'string' is typeof options
          as = options
        else if options.as
          {as} = options
      rdef =
        targetId    : target.getId()
        targetName  : targetType.name
        sourceId    : @getId()
        sourceName  : constructor.name
      unless as is '*'
        rdef.as = as

      # TODO: I am implementing a hack here for the time being. Fix for real.
      Object.keys(rdef).forEach (key)->
        delete rdef[key]  unless rdef[key]?
      # TODO: end dirty hack

      Relationship.remove rdef,
        unless options?.respondWithCount
          callback
        else ->
          delete rdef.targetId
          Relationship.count rdef, callback

  getAssurer_ = do ->
    addIt =(context, adder, target, callback)->
      context[adder] target, (err)->
        if err
          callback err
        else
          callback null, target
    (constructor, name, def)->
      (target, callback)->
        [callback, target] = [target, callback] unless callback
        fetcher = @getInterfaceName 'fetch', name
        adder = @getInterfaceName 'add', name
        selector =
          if target?
            targetId    : target.getId()
          else {}
        @[fetcher] selector, (err, module)=>
          if err
            callback err
          else unless def.targetType
            callback new Error 'No target type!'
          else if module
            # update the timestamp on this relationship to reflect the
            # fact that it is being assured again, so the timestamp always
            # shows the most recent
            Relationship.update {
              targetId  : target.getId()
              sourceId  : @getId()
              as        : def.as
            },{
              $set: timestamp: new Date
            }, (err)->
              callback null, module
          else
            if target
              addIt this, adder, target, callback
            else
              target = new def.targetType
              target.save (err)=>
                if err
                  callback err
                else
                  addIt this, adder, target, callback

  remove_ = @::remove
  remove:(callback=->)->
    id = @getId()
    Relationship.remove $or: [{sourceId: id}, {targetId: id}], (err, rels)=>
      return callback err if err
      remove_.call this, (err)=>
        return callback err if err
        @constructor.emit 'RemovedFromCollection', this
        callback err



  beginGraphlet:-> new Graphlet nodes: [@]

  getFlag = (key, val)->
    flag = {}
    flag["data.flags.#{key}"] = val
    flag

  getAs =(as)->
    if Array.isArray as then $in: as else as

  updateFlag = (sourceId, targetId, as, flag, callback)->
    Relationship.update {targetId, sourceId, as}, flag, callback

  unflag:(key, sourceId, as, callback)->
    flag = $unset: getFlag key, 1
    updateFlag sourceId, @getId(), getAs(as), flag, callback

  flag:(key, val, sourceId, as, callback)->
    flag = $set: getFlag key, val
    updateFlag sourceId, @getId(), getAs(as), flag, callback

  save:(callback)->
    Model::save.call @, callback

  update:(rest..., callback)->
    kallback =(rest...)=>
      Snapshot.clearById @getId(), -> callback? rest...
    Model::update.apply @, rest.concat kallback

  parseTargetOptions =(options={})->
    if selector = options.selector or options.query
      delete options.selector
      delete options.query
    else
      selector = {}
    {options, selector}

  collectOthers =(orientation, as, options, onlyOne, callback, err, cursor)->
    idField   = "#{orientation}Id"
    nameField = "#{orientation}Name"
    if err then callback err
    else cursor.toArray (err, docs)->
      if err then callback err
      else
        ordered = {}
        docs.forEach (doc, index)->
          id = doc[idField]
          ordered[id] = index unless ordered[id]?
        groups = groupBy(docs, nameField)
        {options, selector} = parseTargetOptions(options)
        results = []
        queue = for own type, group of groups
          ->
            flags = {}
            ids = group.map (rel, index)->
              id = rel[idField]
              flag = rel.data?.flags
              flags[id] = flag if flag
              id
            selector = extend(selector,
              _id: $in: ids
            )
            otherConstructor = Base.constructors[type]
            otherConstructor.some selector, options, (err, others)->
              others = others.map (other)->
                other.flags_ = flags[other.getId()]
                other
              results = results.concat others
              queue.fin()
        dash queue, ->
          if onlyOne
            [results] = results
          else
            sortedResults = []
            results.forEach (result)->
              sortedResults[ordered[result.getId()]] = result
            results = sortedResults.filter (value)-> value?
          callback null, results

  filterRelatedIds:(ids, as, orientation, callback)->
    [callback, orientation] = [orientation, callback]  unless callback
    selector = {as}
    id = @getId()
    search = if Array.isArray ids then $in: ids else ids
    if orientation is 'source'
      selector.targetId = search
      selector.sourceId = id
    else
      selector.sourceId = search
      selector.targetId = id
    Relationship.someData selector, {sourceId:1}, (err, cursor)->
      if err then callback err
      else
        cursor.toArray (err, docs)->
          if err
            callback err
          else
            callback null, (doc.sourceId for doc in docs)

  fetch:(orientation, name, as, options, callback)->
    [callback, options] = [options, callback] unless callback
    currentPosition = switch orientation
      when 'target' then 'source'
      when 'source' then 'target'
    options   ?= {}
    callback  ?= ->
    if options.targetOptions?
      {options, targetOptions} = options
    onlyOne = options.onlyOne ? no
    options.limit = 1 if onlyOne
    edgeSelector = if Array.isArray(as) then {as:$in:as} else {as}
    edgeSelector["#{orientation}Name"]      = name
    edgeSelector["#{currentPosition}Name"]  = @constructor.name
    edgeSelector["#{currentPosition}Id"]    = @getId()
    fields = {}
    fields["#{orientation}Id"]  = 1
    fields["#{orientation}Name"]  = 1
    fields['data.flags']        = 1
    Relationship.someData edgeSelector, fields, options, collectOthers.bind(
      this, orientation, as, targetOptions, onlyOne, callback
    )