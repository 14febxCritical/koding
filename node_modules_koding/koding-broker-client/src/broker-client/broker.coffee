{EventEmitter} = require 'microemitter'

module.exports = class Broker extends EventEmitter
  
  [NOTREADY, READY] = [0,1]

  Channel = require './channel'

  constructor:(ws, options)->
    @sockURL = ws
    {@autoReconnect} = options
    @readyState = NOTREADY
    @channels = {}
    @connect()
    @initBackoff options  if @autoReconnect

  bound: require 'koding-bound'

  connect:->
    @ws = new SockJS @sockURL
    @ws.addEventListener 'open', =>
      @readyState = READY
      @emit 'ready'
      @emit 'connected'
    @ws.addEventListener 'close', =>
      @readyState = NOTREADY
      @emit "disconnected", Object.keys @channels
      @channels = {}
      if @autoReconnect
        @setBackoffTimeout @connect.bind @
    @ws.addEventListener 'message', @bound 'handleMessageEvent'

  disconnect:(reconnect)->
    # reconnect or (reconnect = no)
    # @autoReconnect = no  unless reconnect
    @ws.close()
  
  initBackoff:(options)->
    backoff = options.backoff ? {}
    totalReconnectAttempts = 0
    initalDelayMs = backoff.initialDelayMs ? 700
    multiplyFactor = backoff.multiplyFactor ? 1.4
    maxDelayMs = backoff.maxDelayMs ? 1000 * 15 # 15 seconds
    maxReconnectAttempts = backoff.maxReconnectAttempts ? 10

    @clearBackoffTimeout =->
      totalReconnectAttempts = 0

    @setBackoffTimeout = (fn)=>
      if totalReconnectAttempts < maxReconnectAttempts
        timeout = Math.min initalDelayMs * Math.pow(
          multiplyFactor, totalReconnectAttempts
        ), maxDelayMs
        setTimeout fn, timeout
        totalReconnectAttempts++
      else
        @emit "connectionFailed"

  createRoutingKeyPrefix:(name, isReadOnly)->
    if isReadOnly then name
    else "client.#{name}"

  createChannel:(name, isReadOnly)->
    return @channels[name]  if @channels[name]?
    routingKeyPrefix = @createRoutingKeyPrefix name, isReadOnly
    channel = new Channel name, routingKeyPrefix, isReadOnly
    # when listeners are added to the channel object, we need to add the "real"
    # listeners to the broker.
    channel.on 'newListener', (event)=>
      if event is 'broker.subscribed'
        # broker.subscribed event should only be forwarded to the channel that
        # was just opened, so filter out the other "broker.subscribed" events
        @once event, (routingKeyPrefix)=>
          if routingKeyPrefix is channel.routingKeyPrefix
            @authenticate channel
            channel.emit event, routingKeyPrefix
      else
        # add the namespaced listener, but forward the event only
        @on "#{routingKeyPrefix}.#{event}", (rest...)->
          channel.emit event, rest...
    # messages that are routed to the bare routingKey will be interpretted
    # as "message" events
    @on routingKeyPrefix, (rest...)-> channel.emit 'message', rest...
    # when the channel emits a publish event, we want to actually publish the
    # message to the broker.
    unless isReadOnly
      channel.on 'publish', (payload)=>
        exchange = channel.exchange ? channel.name
        @publish {exchange, routingKey: channel.name}, payload

    channel.on 'close', => @unsubscribe channel.name
    @channels[name] = channel
    return channel

  authenticate:(channel)->
    authInfo = {}
    authInfo[key] = val  for own key, val of channel.getAuthenticationInfo()
    authInfo.routingKey = channel.routingKeyPrefix
    @publish 'auth', authInfo

  handleMessageEvent:(event)->
    message = event.data
    @emit 'rawMessage', message
    if message.routingKey and message.payload
      @emit message.routingKey, message.payload
    return

  ready:(listener)->
    if @readyState is READY then listener()
    else @on 'ready', listener

  send:(data)->
    @ready => @ws._transport.doSend JSON.stringify data
    return this

  publish:(options, payload)->
    if 'string' is typeof options
      routingKey = exchange = options
    else
      {routingKey, exchange} = options
    routingKey = @createRoutingKeyPrefix routingKey
    payload = JSON.stringify payload  unless 'string' is typeof payload
    @send {
      action: 'publish'
      exchange
      routingKey
      payload
    }
    return this

  subscribe:(name, options={}, callback)->
    return @channels[name]  if @channels[name]
    {isReadOnly} = options
    routingKeyPrefix = @createRoutingKeyPrefix name, isReadOnly
    @send {
      action: 'subscribe'
      routingKeyPrefix
    }
    if callback?
      @on 'broker.subscribed', handler = (prefix)=>
        if prefix is routingKeyPrefix
          @off 'broker.subscribed', handler
          callback prefix
    return @channels[name] = @createChannel name, isReadOnly

  unsubscribe:(name)->
    @send {
      action: 'unsubscribe'
      routingKeyPrefix: @createRoutingKeyPrefix name
    }
    return this
