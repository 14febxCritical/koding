
module.exports = class Broker extends `KDEventEmitter.Wildcard`

  [NOTREADY, READY, CLOSED] = [0,1,3]

  Channel = require './channel'

  createId = require 'hat'

  { emitToChannel } = require './util'

  constructor:(ws, options)->
    super
    @sockURL = ws
    {@autoReconnect, @authChannelName, @overlapDuration} = options
    @overlapDuration ?= 3000
    @authChannelName ?= 'auth'
    @readyState = NOTREADY
    @channels = {}
    @namespacedEvents = {}
    @subscriptions = {}
    @initBackoff options  if @autoReconnect
    @connect()

  setP2PKeys:(channelName, { routingKey, bindingKey }, serviceType)->
    channel = @channels[channelName]
    return  unless channel

    channel.close()

    consumerChannel = @subscribe bindingKey,
      exchange    :'chat'
      isReadOnly  : yes
      isSecret    : yes
    consumerChannel.setAuthenticationInfo { serviceType }
    consumerChannel.pipe channel

    producerChannel = @subscribe routingKey,
      exchange    : 'chat'
      isReadOnly  : no
      isSecret    : yes
    producerChannel.setAuthenticationInfo { serviceType }

    channel.off 'publish'
    channel.on 'publish', producerChannel.bound 'publish'

    channel.consumerChannel = consumerChannel
    channel.producerChannel = producerChannel

    return channel

  bound: require 'koding-bound'

  onopen:->
    @clearBackoffTimeout()

    @once 'broker.connected', (newSocketId) => @socketId = newSocketId

    @resubscribe()  if @readyState is CLOSED

    @readyState = READY

    @emit 'ready'
    @emit 'connected'

  onclose:->
    @readyState = CLOSED
    @emit "disconnected", Object.keys @channels
    if @autoReconnect
      process.nextTick => @setBackoffTimeout @connect.bind this

  connect:->
    @ws = new SockJS @sockURL
    @ws.addEventListener 'open', @bound 'onopen'
    @ws.addEventListener 'close', @bound 'onclose'
    @ws.addEventListener 'message', @bound 'handleMessageEvent'

  disconnect:(reconnect=true)->
    @autoReconnect = !!reconnect  if reconnect?
    @ws.close()

  initBackoff:(options)->
    backoff = options.backoff ? {}
    totalReconnectAttempts = 0
    initalDelayMs = backoff.initialDelayMs ? 700
    multiplyFactor = backoff.multiplyFactor ? 1.4
    maxDelayMs = backoff.maxDelayMs ? 1000 * 15 # 15 seconds
    maxReconnectAttempts = backoff.maxReconnectAttempts ? 50

    @clearBackoffTimeout =->
      totalReconnectAttempts = 0

    @setBackoffTimeout = (fn)=>
      if totalReconnectAttempts < maxReconnectAttempts
        timeout = Math.min initalDelayMs * Math.pow(
          multiplyFactor, totalReconnectAttempts
        ), maxDelayMs
        setTimeout fn, timeout
        totalReconnectAttempts++
      else
        @emit "connectionFailed"

  createRoutingKeyPrefix:(name, options = {})->
    {isReadOnly, suffix} = options
    name += suffix or ''
    if isReadOnly then name
    else "client.#{name}"

  wrapPrivateChannel:(channel)->
    channel.on 'cycle', => @authenticate channel
    channel.on 'setSecretNames', (secretName)=>

      {isReadOnly} = channel

      channel.setSecretName secretName
      channel.close() # close the channelâ€”no more messages from upstream

      consumerChannel = @subscribe secretName.publishingName, {
        isReadOnly
        isSecret: yes
        exchange: channel.exchange
      }
      consumerChannel.setAuthenticationInfo {
        serviceType: 'secret'
        wrapperRoutingKeyPrefix: channel.routingKeyPrefix
      }

      channel.consumerChannel = consumerChannel

      consumerChannel.on 'cycleChannel', ->
        channel.oldConsumerChannel = channel.consumerChannel
        channel.cycle()

      unless isReadOnly
        channel.on 'publish', (rest...)-> consumerChannel.publish rest...

      @swapPrivateSourceChannel channel

      channel.emit 'ready'

  swapPrivateSourceChannel:(channel)->
    {consumerChannel, oldConsumerChannel} = channel
    if oldConsumerChannel?
      setTimeout =>

        oldConsumerChannel.close().off()
        delete channel.oldConsumerChannel

        consumerChannel.pipe channel

      , @overlapDuration
    else
      consumerChannel.pipe channel

  registerNamespacedEvent: (name) ->
    register = @namespacedEvents
    register[name] ?= 0
    register[name] += 1
    return register[name] is 1

  createChannel: (name, options) ->
    return @channels[name]  if @channels[name]?

    # TODO: let's try to trim the fat a bit; the below has too many options:
    { isReadOnly, isSecret, isExclusive,
      isPrivate, isP2P, suffix, exchange } = options

    suffix ?= if isExclusive then ".#{createId 32}" else ''

    routingKeyPrefix = @createRoutingKeyPrefix name, { suffix, isReadOnly }
    channel = new Channel name, routingKeyPrefix, {
      isReadOnly
      isSecret
      isP2P
      isExclusive: isExclusive ? isPrivate
      exchange
    }

    # handle authentication once the broker is subscribed.
    @on 'broker.subscribed', handler = (routingKeyPrefixes) =>
      for prefix in routingKeyPrefixes.split ' ' when prefix is routingKeyPrefix
        @authenticate channel
        # @off 'broker.subscribed', handler
        channel.emit 'broker.subscribed', channel.routingKeyPrefix
        return
    # messages that are routed to the bare routingKey will be interpretted
    # as "message" events
    @on routingKeyPrefix, (rest...) -> channel.emit 'message', rest...

    channel.on 'newListener', (event, listener) =>
      if channel.isExclusive or channel.isP2P
        channel.trackListener event, listener
      unless event is 'broker.subscribed'
        namespacedEvent = "#{routingKeyPrefix}.#{event}"
        needsToBeRegistered = @registerNamespacedEvent namespacedEvent
        if needsToBeRegistered
          # add the namespaced listener, but forward the event only
          @on namespacedEvent, (rest...) =>
            emitToChannel this, channel, event, rest...

    unless isSecret
      channel.on 'auth.authOk', -> channel.isAuthenticated = yes

    channel.once 'error', channel.bound 'close'
    channel.once 'close', => @unsubscribe channel.name
    @wrapPrivateChannel channel  if isExclusive or isPrivate

    # when the channel emits a publish event, we want to actually publish the
    # message to the broker.
    unless isPrivate or isReadOnly
      channel.on 'publish', (options, payload) =>
        [payload, options] = [options, payload]  unless payload?

        exchange = options?.exchange ? channel.exchange ? channel.name

        @publish { exchange, routingKey: channel.name }, payload

    @channels[name] = channel
    return channel

  authenticate: (channel) ->
    authInfo = {}
    authInfo[key] = val  for own key, val of channel.getAuthenticationInfo()
    authInfo.routingKey = channel.routingKeyPrefix
    @publish @authChannelName, authInfo

  handleMessageEvent: (event) ->
    message = event.data
    @emit 'rawMessage', message
    @emit message.routingKey, message.payload  if message.routingKey
    return

  ready: (listener) ->
    if @readyState is READY then process.nextTick listener
    else @once 'ready', listener

  send: (data) ->
    @ready =>
      try @ws._transport.doSend JSON.stringify data
      catch e then @disconnect()
    return this

  publish: (options, payload) ->
    if 'string' is typeof options
      routingKey = exchange = options
    else
      { routingKey, exchange } = options
    routingKey = @createRoutingKeyPrefix routingKey
    payload = JSON.stringify payload  unless 'string' is typeof payload
    @send {
      action: 'publish'
      exchange
      routingKey
      payload
    }
    return this

  resubscribeBySocketId: ->
    @send { action: 'resubscribe', @socketId }
    @once 'broker.resubscribed', (found) =>
      if found
        channel.emit 'broker.subscribed'  for own _, channel of @channels
      else @resubscribeBySubscriptions()

  resubscribeBySubscriptions: ->
    # replay any existing subscriptions after reconnecting.

    routingKeyPrefix =
      (rk  for own _, { routingKeyPrefix : rk } of @subscriptions).join ' '

    @send {
      action: 'subscribe'
      routingKeyPrefix
    }

  resubscribe: (callback) ->
    if @socketId?
    then @resubscribeBySocketId()
    else @resubscribeBySubscriptions()

  subscribe: (name, options={}, callback) ->
    channel = @channels[name]
    unless channel?
      isSecret    = !!options.isSecret
      isExclusive = !!options.isExclusive
      isReadOnly  =
        if options.isReadOnly?
        then !!options.isReadOnly
        else isExclusive
      isPrivate   = !!options.isPrivate
      isP2P       = !!options.isP2P
      {suffix, exchange} = options
      routingKeyPrefix = @createRoutingKeyPrefix name, {isReadOnly}
      @subscriptions[name] = { name, routingKeyPrefix, arguments }
      channel = @channels[name] = @createChannel name, {
        isReadOnly, isSecret, isExclusive, isPrivate, isP2P, suffix, exchange
      }
    @send {
      action: 'subscribe'
      routingKeyPrefix: channel.routingKeyPrefix
    }
    if callback?
      @on 'broker.subscribed', handler = (routingKeyPrefixes)=>
        for prefix in routingKeyPrefixes.split ' ' when prefix is routingKeyPrefix
          @off 'broker.subscribed', handler
          callback prefix
          return
    return channel

  unsubscribe: (name) ->
    @send {
      action: 'unsubscribe'
      routingKeyPrefix: @createRoutingKeyPrefix name
    }
    delete @channels[name]
    delete @subscriptions[name]

    return this

  ping: (callback) ->
    @send { action: "ping" }
    @once "broker.pong", callback  if callback?
