{EventEmitter} = require 'microemitter'

Channel = require './channel'

module.exports = class Broker extends EventEmitter
  
  constructor:(ws)->
    @ws = if 'string' is typeof ws then new SockJS ws else ws
    @ws.addEventListener 'message', @bound 'handleMessageEvent'

  bound: require 'koding-bound'

  handleMessageEvent:(event)->
    {data} = event
    message =\
      try JSON.parse data
      catch e then data
    @emit 'message', message

    if message.routingKey and message.payload
      @emit message.routingKey,
        try JSON.parse message.payload
        catch e then message.payload

    return this

  createChannel:(routingKeyPrefix)->
    channel = new Channel routingKeyPrefix
    @on routingKeyPrefix, channel.bound 'emit', routingKeyPrefix.split('.').pop()

  send:(data) ->
    throw new Error 'INVALID_STATE_ERR'  if @ws.readyState is SockJS.CONNECTING
    @ws._transport.doSend JSON.stringify data  if @ws.readyState is SockJS.OPEN

  publish:(exchange, routingKey, payload)->
    payload = JSON.stringify payload  unless 'string' is typeof payload
    @send {
      action: 'publish'
      exchange
      routingKey
      payload
    }
    return this

  subscribe:(routingKeyPrefix, callback)->
    @send { action: 'subscribe', routingKeyPrefix }
    if callback?
      @on 'broker.subscribed', handler = (prefix)=>
        if prefix is routingKeyPrefix
          @off 'broker.subscribed', handler
          callback()
    return createChannel routingKeyPrefix

  unsubscribe:(routingKeyPrefix)->
    @send { action: 'unsubscribe', routingKeyPrefix }
    return this

window['Broker'] = Broker  if window?