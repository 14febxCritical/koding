var Broker,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

module.exports = Broker = (function(_super) {
  var CLOSED, Channel, NOTREADY, READY, createId, emitToChannel, _ref;

  __extends(Broker, _super);

  _ref = [0, 1, 3], NOTREADY = _ref[0], READY = _ref[1], CLOSED = _ref[2];

  Channel = require('./channel');

  createId = require('hat');

  emitToChannel = require('./util').emitToChannel;

  function Broker(ws, options) {
    Broker.__super__.constructor.call(this);
    this.sockURL = ws;
    this.autoReconnect = options.autoReconnect, this.authExchange = options.authExchange, this.overlapDuration = options.overlapDuration, this.servicesEndpoint = options.servicesEndpoint;
    if (this.overlapDuration == null) {
      this.overlapDuration = 3000;
    }
    if (this.authExchange == null) {
      this.authExchange = 'auth';
    }
    this.readyState = NOTREADY;
    this.channels = {};
    this.namespacedEvents = {};
    this.subscriptions = {};
    this.pendingSubscriptions = [];
    this.pendingUnsubscriptions = [];
    this.subscriptionThrottleMs = 2000;
    this.unsubscriptionThreshold = 40;
    if (this.autoReconnect) {
      this.initBackoff(options.backoff);
    }
    this.connect();
  }

  Broker.prototype.initBackoff = require('koding-backoff');

  Broker.prototype.setP2PKeys = function(channelName, _arg, serviceType) {
    var bindingKey, channel, consumerChannel, producerChannel, routingKey;
    routingKey = _arg.routingKey, bindingKey = _arg.bindingKey;
    channel = this.channels[channelName];
    if (!channel) {
      return;
    }
    channel.close();
    consumerChannel = this.subscribe(bindingKey, {
      exchange: 'chat',
      isReadOnly: true,
      isSecret: true
    });
    consumerChannel.setAuthenticationInfo({
      serviceType: serviceType
    });
    consumerChannel.pipe(channel);
    producerChannel = this.subscribe(routingKey, {
      exchange: 'chat',
      isReadOnly: false,
      isSecret: true
    });
    producerChannel.setAuthenticationInfo({
      serviceType: serviceType
    });
    channel.off('publish');
    channel.on('publish', producerChannel.bound('publish'));
    channel.consumerChannel = consumerChannel;
    channel.producerChannel = producerChannel;
    return channel;
  };

  Broker.prototype.bound = require('koding-bound');

  Broker.prototype.onopen = function() {
    var _this = this;
    this.clearBackoffTimeout();
    this.once('broker.connected', function(newSocketId) {
      return _this.socketId = newSocketId;
    });
    if (this.readyState === CLOSED) {
      this.resubscribe();
    }
    this.readyState = READY;
    this.emit('ready');
    return this.emit('connected');
  };

  Broker.prototype.onclose = function() {
    var _this = this;
    this.readyState = CLOSED;
    this.emit("disconnected", Object.keys(this.channels));
    if (this.autoReconnect) {
      return process.nextTick(function() {
        return _this.connectAttemptFail();
      });
    }
  };

  Broker.prototype.connectAttemptFail = function() {
    return this.setBackoffTimeout(this.bound("connect"), this.bound("connectFail"));
  };

  Broker.prototype.selectAndConnect = function() {
    var xhr,
      _this = this;
    xhr = new XMLHttpRequest;
    xhr.open('GET', this.servicesEndpoint);
    xhr.onreadystatechange = function() {
      var response, _ref1;
      if (xhr.status === 0 || xhr.status >= 400) {
        _this.connectAttemptFail();
        return _this;
      }
      if (xhr.readyState !== 4) {
        return;
      }
      if ((_ref1 = xhr.status) !== 200 && _ref1 !== 304) {
        return;
      }
      response = JSON.parse(xhr.responseText);
      _this.sockURL = "" + (Array.isArray(response) ? response[0] : response) + "/subscribe";
      return _this.connectDirectly();
    };
    return xhr.send();
  };

  Broker.prototype.connectDirectly = function() {
    var _this = this;
    this.ws = new SockJS(this.sockURL);
    this.ws.addEventListener('open', this.bound('onopen'));
    this.ws.addEventListener('close', this.bound('onclose'));
    this.ws.addEventListener('message', this.bound('handleMessageEvent'));
    return this.ws.addEventListener('message', function() {
      return _this.emit('messageArrived');
    });
  };

  Broker.prototype.disconnect = function(reconnect) {
    if (reconnect == null) {
      reconnect = true;
    }
    if (reconnect != null) {
      this.autoReconnect = !!reconnect;
    }
    return this.ws.close();
  };

  Broker.prototype.connect = function() {
    if (this.servicesEndpoint != null) {
      return this.selectAndConnect();
    } else {
      return this.connectDirectly();
    }
  };

  Broker.prototype.connectFail = function() {
    return this.emit('connectFailed');
  };

  Broker.prototype.createRoutingKeyPrefix = function(name, options) {
    var isReadOnly, suffix;
    if (options == null) {
      options = {};
    }
    isReadOnly = options.isReadOnly, suffix = options.suffix;
    name += suffix || '';
    if (isReadOnly) {
      return name;
    } else {
      return "client." + name;
    }
  };

  Broker.prototype.wrapPrivateChannel = function(channel) {
    var _this = this;
    channel.on('cycle', function() {
      return _this.authenticate(channel);
    });
    return channel.on('setSecretNames', function(secretName) {
      var consumerChannel, isReadOnly;
      isReadOnly = channel.isReadOnly;
      channel.setSecretName(secretName);
      channel.isForwarder = true;
      consumerChannel = _this.subscribe(secretName.publishingName, {
        isReadOnly: isReadOnly,
        isSecret: true,
        exchange: channel.exchange
      });
      consumerChannel.setAuthenticationInfo({
        serviceType: 'secret',
        wrapperRoutingKeyPrefix: channel.routingKeyPrefix
      });
      channel.consumerChannel = consumerChannel;
      consumerChannel.on('cycleChannel', function() {
        channel.oldConsumerChannel = channel.consumerChannel;
        return channel.cycle();
      });
      if (!isReadOnly) {
        channel.on('publish', function() {
          var rest;
          rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return consumerChannel.publish.apply(consumerChannel, rest);
        });
      }
      _this.swapPrivateSourceChannel(channel);
      return channel.emit('ready');
    });
  };

  Broker.prototype.swapPrivateSourceChannel = function(channel) {
    var consumerChannel, oldConsumerChannel,
      _this = this;
    consumerChannel = channel.consumerChannel, oldConsumerChannel = channel.oldConsumerChannel;
    if (oldConsumerChannel != null) {
      return setTimeout(function() {
        oldConsumerChannel.close().off();
        delete channel.oldConsumerChannel;
        return consumerChannel.pipe(channel);
      }, this.overlapDuration);
    } else {
      return consumerChannel.pipe(channel);
    }
  };

  Broker.prototype.registerNamespacedEvent = function(name) {
    var register;
    register = this.namespacedEvents;
    if (register[name] == null) {
      register[name] = 0;
    }
    register[name] += 1;
    return register[name] === 1;
  };

  Broker.prototype.createChannel = function(name, options) {
    var channel, exchange, handler, isExclusive, isP2P, isPrivate, isReadOnly, isSecret, routingKeyPrefix, suffix,
      _this = this;
    if (this.channels[name] != null) {
      return this.channels[name];
    }
    isReadOnly = options.isReadOnly, isSecret = options.isSecret, isExclusive = options.isExclusive, isPrivate = options.isPrivate, isP2P = options.isP2P, suffix = options.suffix, exchange = options.exchange;
    if (suffix == null) {
      suffix = isExclusive ? "." + (createId(32)) : '';
    }
    routingKeyPrefix = this.createRoutingKeyPrefix(name, {
      suffix: suffix,
      isReadOnly: isReadOnly
    });
    channel = new Channel(name, routingKeyPrefix, {
      isReadOnly: isReadOnly,
      isSecret: isSecret,
      isP2P: isP2P,
      isExclusive: isExclusive != null ? isExclusive : isPrivate,
      exchange: exchange
    });
    this.on('broker.subscribed', handler = function(routingKeyPrefixes) {
      var prefix, _i, _len, _ref1;
      _ref1 = routingKeyPrefixes.split(' ');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        prefix = _ref1[_i];
        if (!(prefix === routingKeyPrefix)) {
          continue;
        }
        _this.authenticate(channel);
        channel.emit('broker.subscribed', channel.routingKeyPrefix);
        return;
      }
    });
    this.on(routingKeyPrefix, function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!channel.isForwarder) {
        return channel.emit.apply(channel, ['message'].concat(__slice.call(rest)));
      }
    });
    channel.on('newListener', function(event, listener) {
      var namespacedEvent, needsToBeRegistered;
      if (channel.isExclusive || channel.isP2P) {
        channel.trackListener(event, listener);
      }
      if (event !== 'broker.subscribed') {
        namespacedEvent = "" + routingKeyPrefix + "." + event;
        needsToBeRegistered = _this.registerNamespacedEvent(namespacedEvent);
        if (needsToBeRegistered) {
          return _this.on(namespacedEvent, function() {
            var rest;
            rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return emitToChannel.apply(null, [_this, channel, event].concat(__slice.call(rest)));
          });
        }
      }
    });
    if (!isSecret) {
      channel.on('auth.authOk', function() {
        return channel.isAuthenticated = true;
      });
    }
    channel.once('error', channel.bound('close'));
    channel.once('close', function() {
      return _this.unsubscribe(channel.name);
    });
    if (isExclusive || isPrivate) {
      this.wrapPrivateChannel(channel);
    }
    if (!(isPrivate || isReadOnly)) {
      channel.on('publish', function(options, payload) {
        var _ref1, _ref2, _ref3;
        if (payload == null) {
          _ref1 = [options, payload], payload = _ref1[0], options = _ref1[1];
        }
        exchange = (_ref2 = (_ref3 = options != null ? options.exchange : void 0) != null ? _ref3 : channel.exchange) != null ? _ref2 : channel.name;
        return _this.publish({
          exchange: exchange,
          routingKey: channel.name
        }, payload);
      });
    }
    this.channels[name] = channel;
    return channel;
  };

  Broker.prototype.authenticate = function(channel) {
    var authInfo, key, val, _ref1;
    authInfo = {};
    _ref1 = channel.getAuthenticationInfo();
    for (key in _ref1) {
      if (!__hasProp.call(_ref1, key)) continue;
      val = _ref1[key];
      authInfo[key] = val;
    }
    authInfo.routingKey = channel.routingKeyPrefix;
    return this.publish(this.authExchange, authInfo);
  };

  Broker.prototype.handleMessageEvent = function(event) {
    var message;
    message = event.data;
    this.emit('rawMessage', message);
    if (message.routingKey) {
      this.emit(message.routingKey, message.payload);
    }
  };

  Broker.prototype.ready = function(listener) {
    if (this.readyState === READY) {
      return process.nextTick(listener);
    } else {
      return this.once('ready', listener);
    }
  };

  Broker.prototype.send = function(data) {
    var _this = this;
    this.emit('send', data);
    this.ready(function() {
      var e;
      try {
        return _this.ws._transport.doSend(JSON.stringify(data));
      } catch (_error) {
        e = _error;
        return _this.disconnect();
      }
    });
    return this;
  };

  Broker.prototype.publish = function(options, payload) {
    var exchange, routingKey;
    this.emit('messagePublished');
    if ('string' === typeof options) {
      routingKey = exchange = options;
    } else {
      routingKey = options.routingKey, exchange = options.exchange;
    }
    routingKey = this.createRoutingKeyPrefix(routingKey);
    if ('string' !== typeof payload) {
      payload = JSON.stringify(payload);
    }
    this.send({
      action: 'publish',
      exchange: exchange,
      routingKey: routingKey,
      payload: payload
    });
    return this;
  };

  Broker.prototype.resubscribeBySocketId = function() {
    var _this = this;
    this.send({
      action: 'resubscribe',
      socketId: this.socketId
    });
    return this.once('broker.resubscribed', function(found) {
      var channel, _, _ref1, _results;
      if (found) {
        _ref1 = _this.channels;
        _results = [];
        for (_ in _ref1) {
          if (!__hasProp.call(_ref1, _)) continue;
          channel = _ref1[_];
          _results.push(channel.emit('broker.subscribed'));
        }
        return _results;
      } else {
        return _this.resubscribeBySubscriptions();
      }
    });
  };

  Broker.prototype.resubscribeBySubscriptions = function() {
    var rk, routingKeyPrefix, _;
    routingKeyPrefix = ((function() {
      var _ref1, _results;
      _ref1 = this.subscriptions;
      _results = [];
      for (_ in _ref1) {
        if (!__hasProp.call(_ref1, _)) continue;
        rk = _ref1[_].routingKeyPrefix;
        _results.push(rk);
      }
      return _results;
    }).call(this)).join(' ');
    return this.send({
      action: 'subscribe',
      routingKeyPrefix: routingKeyPrefix
    });
  };

  Broker.prototype.resubscribe = function(callback) {
    if (this.socketId != null) {
      return this.resubscribeBySocketId();
    } else {
      return this.resubscribeBySubscriptions();
    }
  };

  Broker.prototype.subscribe = function(name, options, callback) {
    var channel, exchange, handler, isExclusive, isP2P, isPrivate, isReadOnly, isSecret, routingKeyPrefix, suffix,
      _this = this;
    if (options == null) {
      options = {};
    }
    channel = this.channels[name];
    if (channel == null) {
      isSecret = !!options.isSecret;
      isExclusive = !!options.isExclusive;
      isReadOnly = options.isReadOnly != null ? !!options.isReadOnly : isExclusive;
      isPrivate = !!options.isPrivate;
      isP2P = !!options.isP2P;
      suffix = options.suffix, exchange = options.exchange;
      routingKeyPrefix = this.createRoutingKeyPrefix(name, {
        isReadOnly: isReadOnly
      });
      this.subscriptions[name] = {
        name: name,
        routingKeyPrefix: routingKeyPrefix,
        arguments: arguments
      };
      channel = this.channels[name] = this.createChannel(name, {
        isReadOnly: isReadOnly,
        isSecret: isSecret,
        isExclusive: isExclusive,
        isPrivate: isPrivate,
        isP2P: isP2P,
        suffix: suffix,
        exchange: exchange
      });
    }
    this.enqueueSubscription(channel.routingKeyPrefix);
    if (callback != null) {
      this.on('broker.subscribed', handler = function(routingKeyPrefixes) {
        var prefix, _i, _len, _ref1;
        _ref1 = routingKeyPrefixes.split(' ');
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          prefix = _ref1[_i];
          if (!(prefix === routingKeyPrefix)) {
            continue;
          }
          _this.off('broker.subscribed', handler);
          callback(prefix);
          return;
        }
      });
    }
    return channel;
  };

  Broker.prototype.enqueueSubscription = function(routingKeyPrefix) {
    var len;
    len = this.pendingSubscriptions.push(routingKeyPrefix);
    if (len === 1) {
      this.triggerSubscriptions();
    }
    return this;
  };

  Broker.prototype.triggerSubscriptions = function() {
    var _this = this;
    setTimeout(function() {
      var pendingSubscriptions;
      pendingSubscriptions = _this.pendingSubscriptions;
      _this.pendingSubscriptions = [];
      return _this.send({
        action: 'subscribe',
        routingKeyPrefix: pendingSubscriptions.join(' ')
      });
    }, this.subscriptionThrottleMs);
    return this;
  };

  Broker.prototype.enqueueUnsubscription = function(routingKeyPrefix) {
    var i, len;
    i = this.pendingSubscriptions.indexOf(routingKeyPrefix);
    if (i === -1) {
      this.pendingSubscriptions.splice(i, 1);
    } else {
      len = this.pendingUnsubscriptions.push(routingKeyPrefix);
      if (len === this.unsubscriptionThreshold) {
        this.sendUnsubscriptions();
      }
    }
    return this;
  };

  Broker.prototype.sendUnsubscriptions = function() {
    var key, pendingUnsubscriptions, _i, _len;
    pendingUnsubscriptions = this.pendingUnsubscriptions;
    this.send({
      action: 'unsubscribe',
      routingKeyPrefix: pendingUnsubscriptions.join(' ')
    });
    for (_i = 0, _len = pendingSubscriptions.length; _i < _len; _i++) {
      key = pendingSubscriptions[_i];
      this.removeSubscriptionKey(key);
    }
    return this;
  };

  Broker.prototype.unsubscribe = function(name) {
    var prefix;
    prefix = this.createRoutingKeyPrefix(name);
    this.send({
      action: 'unsubscribe',
      routingKeyPrefix: prefix
    });
    this.removeSubscriptionKey(prefix);
    return this;
  };

  Broker.prototype.removeSubscriptionKey = function(key) {
    delete this.channels[name];
    delete this.subscriptions[name];
    return this;
  };

  Broker.prototype.ping = function(callback) {
    this.send({
      action: "ping"
    });
    if (callback != null) {
      return this.once("broker.pong", callback);
    }
  };

  return Broker;

})(KDEventEmitter.Wildcard);
