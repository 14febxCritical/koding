var Broker, EventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

EventEmitter = require('microemitter').EventEmitter;

module.exports = Broker = (function(_super) {
  var Channel, NOTREADY, READY, _ref;

  __extends(Broker, _super);

  _ref = [0, 1], NOTREADY = _ref[0], READY = _ref[1];

  Channel = require('./channel');

  function Broker(ws, options) {
    this.autoReconnect = options.autoReconnect;
    this.readyState = NOTREADY;
    this.channels = {};
    this.connect(ws);
    if (this.autoReconnect) {
      this.initBackoff(options);
    }
  }

  Broker.prototype.bound = require('koding-bound');

  Broker.prototype.connect = function(ws) {
    var _this = this;
    this.ws = 'string' === typeof ws ? new SockJS(ws) : ws;
    this.ws.addEventListener('open', function() {
      _this.readyState = READY;
      _this.emit('ready');
      return _this.emit('connected');
    });
    this.ws.addEventListener('close', function() {
      _this.readyState = NOTREADY;
      _this.emit("disconnected", Object.keys(_this.channels));
      _this.channels = {};
      if (_this.autoReconnect) {
        return _this.setBackoffTimeout(_this.connect.bind(_this));
      }
    });
    return this.ws.addEventListener('message', this.bound('handleMessageEvent'));
  };

  Broker.prototype.disconnect = function(reconnect) {
    reconnect || (reconnect = false);
    if (!reconnect) {
      this.autoReconnect = false;
    }
    return this.ws.close();
  };

  Broker.prototype.initBackoff = function(options) {
    var backoff, initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref1, _ref2, _ref3, _ref4, _ref5,
      _this = this;
    backoff = (_ref1 = options.backoff) != null ? _ref1 : {};
    totalReconnectAttempts = 0;
    initalDelayMs = (_ref2 = backoff.initialDelayMs) != null ? _ref2 : 700;
    multiplyFactor = (_ref3 = backoff.multiplyFactor) != null ? _ref3 : 1.4;
    maxDelayMs = (_ref4 = backoff.maxDelayMs) != null ? _ref4 : 1000 * 60 * 15;
    maxReconnectAttempts = (_ref5 = backoff.maxReconnectAttempts) != null ? _ref5 : 10;
    this.clearBackoffTimeout = function() {
      return totalReconnectAttempts = 0;
    };
    return this.setBackoffTimeout = function(fn) {
      if (totalReconnectAttempts < maxReconnectAttempts) {
        setTimeout(fn, Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs));
        return totalReconnectAttempts++;
      } else {
        return _this.emit("connectionFailed");
      }
    };
  };

  Broker.prototype.createRoutingKeyPrefix = function(name) {
    return "client." + name;
  };

  Broker.prototype.createChannel = function(name) {
    var channel, routingKeyPrefix,
      _this = this;
    if (this.channels[name] != null) {
      return this.channels[name];
    }
    routingKeyPrefix = this.createRoutingKeyPrefix(name);
    channel = new Channel(name, routingKeyPrefix);
    channel.on('newListener', function(event) {
      if (event === 'broker.subscribed') {
        return _this.on(event, function(routingKeyPrefix) {
          if (routingKeyPrefix === channel.routingKeyPrefix) {
            return channel.emit(event, routingKeyPrefix);
          }
        });
      } else {
        return _this.on("" + routingKeyPrefix + "." + event, function() {
          var rest;
          rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return channel.emit.apply(channel, [event].concat(__slice.call(rest)));
        });
      }
    });
    this.on(routingKeyPrefix, function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return channel.emit.apply(channel, ['message'].concat(__slice.call(rest)));
    });
    channel.on('publish', function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _this.publish.apply(_this, [channel.name].concat(__slice.call(rest)));
    });
    this.channels[name] = channel;
    return channel;
  };

  Broker.prototype.handleMessageEvent = function(event) {
    var data, message;
    console.log(event);
    data = event.data;
    message = (function() {
      try {
        return JSON.parse(data);
      } catch (e) {
        return data;
      }
    })();
    this.emit('message', message);
    if (message.routingKey && message.payload) {
      this.emit(message.routingKey, (function() {
        try {
          return JSON.parse(message.payload);
        } catch (e) {
          return message.payload;
        }
      })());
    }
  };

  Broker.prototype.ready = function(listener) {
    if (this.readyState === READY) {
      return listener();
    } else {
      return this.on('ready', listener);
    }
  };

  Broker.prototype.send = function(data) {
    var _this = this;
    this.ready(function() {
      if (_this.ws.readyState === SockJS.CONNECTING) {
        throw new Error('INVALID_STATE_ERR');
      }
      if (_this.ws.readyState === SockJS.OPEN) {
        return _this.ws._transport.doSend(JSON.stringify(data));
      }
    });
    return this;
  };

  Broker.prototype.publish = function() {
    var event, exchange, payload, routingKey, _i;
    routingKey = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), payload = arguments[_i++];
    exchange = routingKey[0], event = routingKey[1];
    routingKey = this.createRoutingKeyPrefix(routingKey.join('.'));
    if ('string' !== typeof payload) {
      payload = JSON.stringify(payload);
    }
    this.send({
      action: 'publish',
      exchange: exchange,
      routingKey: routingKey,
      payload: payload
    });
    return this;
  };

  Broker.prototype.subscribe = function(name, callback) {
    var handler, routingKeyPrefix,
      _this = this;
    routingKeyPrefix = this.createRoutingKeyPrefix(name);
    this.send({
      action: 'subscribe',
      routingKeyPrefix: routingKeyPrefix
    });
    if (callback != null) {
      this.on('broker.subscribed', handler = function(prefix) {
        if (prefix === routingKeyPrefix) {
          _this.off('broker.subscribed', handler);
          return callback(prefix);
        }
      });
    }
    return this.createChannel(name);
  };

  Broker.prototype.unsubscribe = function(name) {
    this.send({
      action: 'unsubscribe',
      routingKeyPrefix: this.createRoutingKeyPrefix(name)
    });
    return this;
  };

  return Broker;

})(EventEmitter);
