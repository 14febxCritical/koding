var Broker, EventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

EventEmitter = require('microemitter').EventEmitter;

module.exports = Broker = (function(_super) {
  var CLOSED, Channel, NOTREADY, READY, createId, _ref;

  __extends(Broker, _super);

  _ref = [0, 1, 3], NOTREADY = _ref[0], READY = _ref[1], CLOSED = _ref[2];

  Channel = require('./channel');

  createId = require('hat');

  function Broker(ws, options) {
    var _ref1;

    this.sockURL = ws;
    this.autoReconnect = options.autoReconnect, this.authChannelName = options.authChannelName;
    if ((_ref1 = this.authChannelName) == null) {
      this.authChannelName = 'auth';
    }
    this.readyState = NOTREADY;
    this.channels = {};
    this.subscriptions = [];
    if (this.autoReconnect) {
      this.initBackoff(options);
    }
    this.connect();
  }

  Broker.prototype.bound = require('koding-bound');

  Broker.prototype.onopen = function() {
    var args, oldSubscriptions, _i, _len, _ref1;

    if (this.readyState === CLOSED) {
      oldSubscriptions = this.subscriptions.slice();
      this.subscriptions.length = 0;
      _ref1 = oldSubscriptions || [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        args = _ref1[_i];
        this.subscribe.apply(this, args);
      }
    }
    this.readyState = READY;
    this.emit('ready');
    return this.emit('connected');
  };

  Broker.prototype.onclose = function() {
    var _this = this;

    this.readyState = CLOSED;
    this.emit("disconnected", Object.keys(this.channels));
    this.channels = {};
    if (this.autoReconnect) {
      return process.nextTick(function() {
        return _this.setBackoffTimeout(_this.connect.bind(_this));
      });
    }
  };

  Broker.prototype.connect = function() {
    this.clearBackoffTimeout();
    this.ws = new SockJS(this.sockURL);
    this.ws.addEventListener('open', this.bound('onopen'));
    this.ws.addEventListener('close', this.bound('onclose'));
    return this.ws.addEventListener('message', this.bound('handleMessageEvent'));
  };

  Broker.prototype.disconnect = function(reconnect) {
    if (reconnect != null) {
      this.autoReconnect = !!reconnect;
    }
    this.channels = {};
    return this.ws.close();
  };

  Broker.prototype.initBackoff = function(options) {
    var backoff, initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref1, _ref2, _ref3, _ref4, _ref5,
      _this = this;

    backoff = (_ref1 = options.backoff) != null ? _ref1 : {};
    totalReconnectAttempts = 0;
    initalDelayMs = (_ref2 = backoff.initialDelayMs) != null ? _ref2 : 700;
    multiplyFactor = (_ref3 = backoff.multiplyFactor) != null ? _ref3 : 1.4;
    maxDelayMs = (_ref4 = backoff.maxDelayMs) != null ? _ref4 : 1000 * 15;
    maxReconnectAttempts = (_ref5 = backoff.maxReconnectAttempts) != null ? _ref5 : 10;
    this.clearBackoffTimeout = function() {
      return totalReconnectAttempts = 0;
    };
    return this.setBackoffTimeout = function(fn) {
      var timeout;

      if (totalReconnectAttempts < maxReconnectAttempts) {
        timeout = Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs);
        setTimeout(fn, timeout);
        return totalReconnectAttempts++;
      } else {
        return _this.emit("connectionFailed");
      }
    };
  };

  Broker.prototype.createRoutingKeyPrefix = function(name, options) {
    var isReadOnly, suffix;

    if (options == null) {
      options = {};
    }
    isReadOnly = options.isReadOnly, suffix = options.suffix;
    name += suffix || '';
    if (isReadOnly) {
      return name;
    } else {
      return "client." + name;
    }
  };

  Broker.prototype.wrapPrivateChannel = function(channel) {
    var _this = this;

    channel.on('cycle', function() {
      return _this.authenticate(channel);
    });
    return channel.on('setSecretName', function(secretName) {
      var isReadOnly, privateChannel;

      isReadOnly = channel.isReadOnly;
      channel.setSecretName(secretName);
      channel.close();
      privateChannel = _this.subscribe(secretName, {
        isReadOnly: isReadOnly,
        isSecret: true
      });
      privateChannel.setAuthenticationInfo({
        serviceType: 'secret'
      });
      channel.privateChannel = privateChannel;
      privateChannel.on('cycleChannel', function() {
        channel.oldPrivateChannel = channel.privateChannel;
        return channel.cycle();
      });
      _this.swapPrivateSourceChannel(channel);
      return channel.emit('ready');
    });
  };

  Broker.prototype.swapPrivateSourceChannel = function(channel) {
    var _this = this;

    if (channel.oldPrivateChannel != null) {
      return setTimeout(function() {
        channel.oldPrivateChannel.close().off();
        channel.privateChannel.pipe(channel);
        return delete channel.oldPrivateChannel;
      }, 3000);
    } else {
      return channel.privateChannel.pipe(channel);
    }
  };

  Broker.prototype.createChannel = function(name, _arg) {
    var channel, handler, isExclusive, isReadOnly, isSecret, routingKeyPrefix, suffix,
      _this = this;

    isReadOnly = _arg.isReadOnly, isSecret = _arg.isSecret, isExclusive = _arg.isExclusive, suffix = _arg.suffix;
    if (this.channels[name] != null) {
      return this.channels[name];
    }
    if (suffix == null) {
      suffix = isExclusive ? "." + (createId(32)) : '';
    }
    routingKeyPrefix = this.createRoutingKeyPrefix(name, {
      suffix: suffix,
      isReadOnly: isReadOnly
    });
    channel = new Channel(name, routingKeyPrefix, {
      isReadOnly: isReadOnly,
      isSecret: isSecret,
      isExclusive: isExclusive
    });
    this.on('broker.subscribed', handler = function(routingKeyPrefix1) {
      if (routingKeyPrefix === routingKeyPrefix1) {
        _this.authenticate(channel);
        _this.off('broker.subscribed', handler);
        return channel.emit('broker.subscribed', channel.routingKeyPrefix);
      }
    });
    this.on(routingKeyPrefix, function() {
      var rest;

      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return channel.emit.apply(channel, ['message'].concat(__slice.call(rest)));
    });
    channel.on('newListener', function(event) {
      var namespacedEvent;

      if (event !== 'broker.subscribed') {
        namespacedEvent = "" + routingKeyPrefix + "." + event;
        return _this.on(namespacedEvent, function() {
          var rest;

          rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return channel.emit.apply(channel, [event].concat(__slice.call(rest)));
        });
      }
    });
    if (!isSecret) {
      channel.on('authOk', function() {
        return channel.isAuthenticated = true;
      });
    }
    channel.on('error', channel.bound('close'));
    channel.on('close', function() {
      return _this.unsubscribe(channel.name);
    });
    if (isExclusive) {
      this.wrapPrivateChannel(channel);
    }
    if (!isReadOnly) {
      channel.on('publish', function(payload) {
        var exchange, _ref1;

        exchange = (_ref1 = channel.exchange) != null ? _ref1 : channel.name;
        return _this.publish({
          exchange: exchange,
          routingKey: channel.name
        }, payload);
      });
    }
    this.channels[name] = channel;
    return channel;
  };

  Broker.prototype.authenticate = function(channel) {
    var authInfo, key, val, _ref1;

    authInfo = {};
    _ref1 = channel.getAuthenticationInfo();
    for (key in _ref1) {
      if (!__hasProp.call(_ref1, key)) continue;
      val = _ref1[key];
      authInfo[key] = val;
    }
    authInfo.routingKey = channel.routingKeyPrefix;
    return this.publish(this.authChannelName, authInfo);
  };

  Broker.prototype.handleMessageEvent = function(event) {
    var message;

    message = event.data;
    this.emit('rawMessage', message);
    if (message.routingKey) {
      this.emit(message.routingKey, message.payload);
    }
  };

  Broker.prototype.ready = function(listener) {
    if (this.readyState === READY) {
      return listener();
    } else {
      return this.on('ready', listener);
    }
  };

  Broker.prototype.send = function(data) {
    var _this = this;

    this.ready(function() {
      return _this.ws._transport.doSend(JSON.stringify(data));
    });
    return this;
  };

  Broker.prototype.publish = function(options, payload) {
    var exchange, routingKey;

    if ('string' === typeof options) {
      routingKey = exchange = options;
    } else {
      routingKey = options.routingKey, exchange = options.exchange;
    }
    routingKey = this.createRoutingKeyPrefix(routingKey);
    if ('string' !== typeof payload) {
      payload = JSON.stringify(payload);
    }
    this.send({
      action: 'publish',
      exchange: exchange,
      routingKey: routingKey,
      payload: payload
    });
    return this;
  };

  Broker.prototype.subscribe = function(name, options, callback) {
    var channel, handler, isExclusive, isReadOnly, isSecret, routingKeyPrefix, suffix,
      _this = this;

    if (options == null) {
      options = {};
    }
    if (this.channels[name]) {
      return this.channels[name];
    }
    this.subscriptions.push(arguments);
    isReadOnly = !!options.isReadOnly;
    isSecret = !!options.isSecret;
    isExclusive = !!options.isExclusive;
    suffix = options.suffix;
    routingKeyPrefix = this.createRoutingKeyPrefix(name, {
      isReadOnly: isReadOnly
    });
    channel = this.channels[name] = this.createChannel(name, {
      isReadOnly: isReadOnly,
      isSecret: isSecret,
      isExclusive: isExclusive,
      suffix: suffix
    });
    this.send({
      action: 'subscribe',
      routingKeyPrefix: channel.routingKeyPrefix
    });
    if (callback != null) {
      this.on('broker.subscribed', handler = function(prefix) {
        if (prefix === routingKeyPrefix) {
          _this.off('broker.subscribed', handler);
          return callback(prefix);
        }
      });
    }
    return channel;
  };

  Broker.prototype.unsubscribe = function(name) {
    this.send({
      action: 'unsubscribe',
      routingKeyPrefix: this.createRoutingKeyPrefix(name)
    });
    return this;
  };

  return Broker;

})(EventEmitter);
