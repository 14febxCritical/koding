var Channel, EventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

EventEmitter = require('./microemitter').EventEmitter;

module.exports = Channel = (function(_super) {
  __extends(Channel, _super);

  function Channel(name, routingKeyPrefix, _arg) {
    this.name = name;
    this.routingKeyPrefix = routingKeyPrefix;
    this.isReadOnly = _arg.isReadOnly, this.isSecret = _arg.isSecret, this.isExclusive = _arg.isExclusive;
  }

  Channel.prototype.publish = function() {
    var rest;

    rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!this.isReadOnly) {
      return this.emit.apply(this, ['publish'].concat(__slice.call(rest)));
    }
  };

  Channel.prototype.close = function() {
    return this.emit('close');
  };

  Channel.prototype.cycle = function() {
    return this.emit('cycle');
  };

  Channel.prototype.pipe = function(channel) {
    return this.on('message', function(message) {
      return channel.emit('message', message);
    });
  };

  Channel.prototype.setAuthenticationInfo = function(authenticationInfo) {
    this.authenticationInfo = authenticationInfo;
  };

  Channel.prototype.getAuthenticationInfo = function() {
    return this.authenticationInfo;
  };

  Channel.prototype.isListeningTo = function(event) {
    var listeners, _ref;

    listeners = (_ref = this._events) != null ? _ref[event] : void 0;
    return listeners && (Object.keys(listeners)).length > 0;
  };

  Channel.prototype.setSecretName = function(secretName) {
    this.secretName = secretName;
  };

  Channel.prototype.bound = require('koding-bound');

  return Channel;

})(EventEmitter);
