xml2js   = require 'xml2js'
https    = require 'https'
createId = require 'hat'
{argv}   = require 'optimist'
KONFIG   = require('koding-config-manager').load("main.#{argv.c}")

getUniqueId = -> createId 64
API_KEY     = KONFIG.recurly.apiKey

module.exports = class Recurly

  ifString = (str)-> if typeof str is 'string' then str else ''

  # Recurly's error entry structure. I'll use the same structure
  # for socket/http errors.
  errorObj = (short='', message='', field='')-> {short, message, field}

  summarizeErrors = (errors)->
    billing = 0
    for e in errors
      if e.field.indexOf('subscription.account.billing_info') > -1 and ++billing > 2
        return errorObj 'billing', 'Credit card information required.'

  # If requested list of records are longer than 50 items, recurly
  # paginates them. This method gets the URL path of next page.
  parseNextUrl = (res)->
    links = {}
    for link in res.headers.link.split(', ')
      linkData = link.split('; ')
      rel = linkData[1].substring(5, linkData[1].length - 1)
      url = linkData[0].substring(1, linkData[0].length - 1)
      links[rel] = url.substring(url.indexOf('v2') + 3)
    return links

  # This method makes a request to Recurly. If the page is chunked,
  # it waits for the last chunk and returns output as JS object.
  request = (method, operation, data, callback)->
    options =
      host     : 'api.recurly.com'
      port     : 443
      path     : '/v2/' + operation
      method   : method
      auth     : API_KEY + ':'
      headers  :
        Accept           : 'application/xml'
        'Content-Length' : Buffer.byteLength data, 'utf8'

    if data.length > 0
      options.headers['Content-Type'] = 'application/xml; charset=UTF-8'

    req = https.request options, (res)->
      res.setEncoding 'utf8'
      body = ''

      res.on 'data', (chunk)-> body += chunk
      res.on 'end',  ->
        return callback null, {}  unless body.length > 0

        # Parse XML and build JS object, or list of errors.
        xml2js.parseString body, (err, result)->
          if err
            callback [errorObj 'xml', 'Invalid XML']
          else if result.error
            callback [errorObj result.error.symbol[0], result.error.description[0]._]
          else if result.errors
            # See https://docs.recurly.com/api/basics/validation-errors for XML format
            errors = []
            for err1 in result.errors.error
              if err1.$
                errors.push errorObj err1.$.symbol, err1._, err1.$.field
              else
                errors.push errorObj err1, err1
            callback errors
          else
            # Find next page's URL if necessary
            nextUrl = parseNextUrl res  if res.headers.link
            callback null, result, nextUrl

    req.on 'error', (e)->
      callback [errorObj 'connection', 'Unable to connect to payment backend.']

    req.end(data, 'utf8')

  # POST request
  post = (operation, data, callback) ->
    request 'POST', operation, data, callback
  # PUT request
  put = (operation, data, callback) ->
    request 'PUT', operation, data, callback
  # DELETE request
  del = (operation, callback) ->
    request 'DELETE', operation, '', callback

  # GET request.
  # If there are multiple pages, this method requests all pages.
  # Returns list of XML/JS objects, not a single XML/JS object!
  # TODO: support buffering, return pages separately
  get = (operation, callback)->
    if operation.indexOf('per_page') == -1
      operation += "#{if operation.indexOf('?') > -1 then '&' else '?'}per_page=50"

    # Collect all GET responses before calling CB
    allData = []
    collect = (err, result, nextUrl)->
      return callback err  if err

      allData.push result

      if nextUrl
        request 'GET', nextUrl, '', collect
      else
        callback null, allData

    request 'GET', operation, '', collect

  #
  # concrete API methods
  #

  #
  # PLANS
  # See https://docs.recurly.com/api/plans for documentation
  #

  planObj = (plan)->
    title       : plan.name[0]
    code        : plan.plan_code[0]
    desc        : ifString plan.description[0]
    feeMonthly  : parseInt plan.unit_amount_in_cents[0]['USD'][0]._, 10
    feeInitial  : parseInt plan.setup_fee_in_cents[0]['USD'][0]._, 10
    feeInterval : parseInt plan.plan_interval_length[0]._, 10

  @getPlans: (callback)->
    get 'plans', (err, res)->
      return callback err  if err

      plans = []
      for page in res when page.plans?.plan
        plans.push planObj p  for p in page.plans.plan

      callback null, plans

  @getPlan: (data, callback)->
    get "plans/#{data.code}", (err, res)->
      return callback err  if err

      if res[0]?.plan
        callback null, planObj res[0].plan
      else
        callback errorObj 'plan', 'Requested plan not found'

  @createPlan: (data, callback)->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <plan_code>#{data.code}</plan_code>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeMonthly, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    post 'plans', xml, (err, res)->
      callback err, unless err then planObj res.plan

  @updatePlan: (data, callback)->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeMonthly, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    put "plans/#{data.code}", xml, (err, res)->
      callback err, unless err then planObj res.plan

  @deletePlan: (data, callback)->
    del "plans/#{data.code}", callback

  #
  # SUBSCRIPTIONS
  # See https://docs.recurly.com/api/subscriptions for documentation
  #

  subObj = (sub)->
    sub =
      plan        : sub.plan[0].plan_code[0]
      quantity    : sub.quantity[0]._
      uuid        : sub.uuid[0]
      currency    : sub.currency[0]
      status      : sub.state[0]
      datetime    : sub.activated_at[0]._
      expires     : sub.expires_at[0]._
      renew       : sub.current_period_ends_at[0]._
      amount      : sub.unit_amount_in_cents[0]._

    if s.pending_subscription
      sub.pending =
        plan      : sub.pending_subscription[0].plan[0].plan_code[0]
        quantity  : sub.pending_subscription[0].quantity[0]._

    return sub

  @getSubscriptions: (accountCode, callback)->
    get "accounts/#{accountCode}/subscriptions", (err, res)->
      return callback err  if err

      subs = []
      for page in res
        subs.push subObj s  for s in page.subscriptions

      callback null, subs

  @getSubscription: (accountCode, data, callback)->
    get "subscriptions/#{data.uuid}", (err, res)->
      return callback err  if err

      if res[0]?.subscription
        callback null, subObj res[0].subscription
      else
        callback errorObj 'subscription', 'Requested subscription not found'

  @createSubscription: (accountCode, data, callback)->
    data.quantity ?= 1

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <plan_code>#{data.plan}</plan_code>
        <currency>USD</currency>
        <quantity>#{data.quantity}</quantity>
        <account>
          <account_code>#{accountCode}</account_code>
        </account>
      </subscription>
      """

    post 'subscriptions', xml, (err, res)->
      callback err, unless err then subObj res.subscription

  @updateSubscription: (accountCode, data, callback)->
    data.quantity ?= 1
    timeframe      = 'now'

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <timeframe>#{timeframe}</timeframe>
        <plan_code>#{data.plan}</plan_code>
        <quantity>#{data.quantity}</quantity>
      </subscription>
      """

    put "subscriptions/#{data.uuid}", xml, (err, res)->
      callback err, unless err then subObj res.subscription

  @terminateSubscription: (accountCode, data, callback)->
    data.refund ?= 'none'

    put "subscriptions/#{data.uuid}/terminate?refund=#{data.refund}", '', (err, res)->
      callback err, unless err then subObj res.subscription

  @cancelSubscription: (accountCode, data, callback)->
    put "subscriptions/#{data.uuid}/cancel", '', (err, res)->
      callback err, unless err then subObj res.subscription

  @reactivateUserSubscription: (accountCode, data, callback)->
    put "subscriptions/#{data.uuid}/reactivate", '', (err, res)->
      callback err, unless err then subObj res.subscription

  #
  # TRANSACTIONS
  # See https://docs.recurly.com/api/transactions for documentation
  #

  transObj = (t)->
    trans =
      uuid       : t.uuid[0]
      status     : t.status[0]
      amount     : parseInt t.amount_in_cents[0]._, 10
      tax        : parseInt t.tax_in_cents[0]._, 10
      currency   : t.currency[0]
      datetime   : t.created_at[0]._
      refundable : t.refundable[0]._
      source     : t.source[0]

    trans.invoice = t.invoice[0].$.href  if t.invoice

    if trans.status in ['success', 'void']
      billing          = t.details[0].account[0].billing_info[0]
      trans.owner      = "#{billing.first_name[0]} #{billing.last_name[0]}"
      trans.cardType   = billing.card_type[0]
      trans.cardNumber = "#{billing.last_four}"

    return trans

  @getTransactions: (accountCode, callback)->
    get "accounts/#{accountCode}/transactions", (err, res)->
      return callback err  if err

      trans = []
      for page in res
        trans.push transObj t  for t in page.transactions?.transaction

      callback null, trans

  @createTransaction: (accountCode, data, callback)->
    xml =
      """
      <transaction>
        <description>#{data.desc}</description>
        <amount_in_cents>#{data.amount}</amount_in_cents>
        <currency>USD</currency>
        <account>
          <account_code>#{accountCode}</account_code>
        </account>
      </transaction>
      """

    post 'transactions', xml, (err, res)->
      callback err, unless err then transObj res.transaction

  @deleteTransaction: (accountCode, data, callback)->
    del "transactions/#{data.uuid}?amount_in_cents=##{data.amount}", callback

  #
  # INVOICES
  # See https://docs.recurly.com/api/invoices for XML format
  #

  invoiceObj = (i)->
    uuid     : i.uuid[0]
    amount   : i.total_in_cents[0]._
    currency : i.currency[0]
    state    : i.state[0]

  @getInvoices: (accountCode, callback)->
    get "accounts/#{accountCode}/invoices", (err, res)->
      return callback err  if err

      invs = []
      for page in res
        invs.push invoiceObj i  for i in page.invocies?.invoice

      callback null, invs

  # charge amount from pending one-time adjustments (carge/credit) to subscription
  # if not manually charged with this method, those will be automatically charged
  # on subscription's renewal (typically monthly)
  @chargePending: (accountCode, callback)->
    post "accounts/#{accountCode}/invoices", '', (err, res)->
      callback err, unless err then transObj res.transaction

  #
  # ADJUSTMENTS (ONE-TIME CHARGE/CREDIT TO SUBSCRIPTION)
  # See https://docs.recurly.com/api/invoices for XML format
  #

  adjObj = (a)->
    uuid        : a.uuid[0]
    amount      : a.total_in_cents[0]._
    currency    : a.currency[0]
    description : if a.description[0].$ then '' else a.description[0]
    type        : a.$.type
    origin      : a.origin[0]

  @getAdjustments: (accountCode, type, state, callback)->
    [callback, state] = [state, callback]  unless callback
    [callback, type]  = [type, callback]   unless callback
    type  or= 'credits and charges'
    state or= 'active'

    get "accounts/#{accountCode}/adjustments?type=#{type}&state=#{state}", (err, res)->
      return callback err  if err

      adjs = []
      for page in res
        adjs.push adjObj a  for a in page.adjustments?.adjustment

      callback null, adjs

  @getCharged: (accountCode, callback)->
    @getAdjustments accountCode, 'charge', 'invoiced', callback

  @getPendingCharges: (accountCode, callback)->
    @getAdjustments accountCode, 'charge', 'pending', callback

  @getCredited: (accountCode, callback)->
    @getAdjustments accountCode, 'credit', 'invoiced', callback

  @getPendingCredits: (accountCode, callback)->
    @getAdjustments accountCode, 'credit', 'pending', callback

  @createAdjustment: (accountCode, data, callback)->
    xml =
      """
      <adjustment>
        <description>#{data.desc}</description>
        <unit_amount_in_cents>#{data.amount}</unit_amount_in_cents>
        <currency>USD</currency>
        <quantity>1</quantity>
        <accounting_code>#{data.accountingCode}</accounting_code>
      </adjustment>
      """

    post "accounts/#{accountCode}/adjustments", xml, (err, res)->
      callback err, unless err then adjObj res.adjustment

  @createCharge: @createAdjustment

  @createRefund: (accountCode, data, callback)->
    data.unit_amount_in_cents = "-#{data.unit_amount_in_cents}"
    @createAdjustment accountCode, data, callback

  #
  # ACCOUNTS and BILLING INFO
  # See https://docs.recurly.com/api/accounts for XML format
  #

  accObj = (acc, billing)->
    firstName : acc.first_name[0]
    lastName  : acc.last_name[0]
    email     : acc.email[0]
    username  : acc.username[0]
    url       : 'https://koding.recurly.com/account/' + acc.hosted_login_token[0]
    billing   : billing

  @getAccount: (accountCode, callback)->
    get "accounts/#{accountCode}", (err, res)=>
      return callback err  if err
      @getBilling accountCode, (err, billing)->
        return callback err  if err
        callback null, accObj res[0]?.account, billing

  @setAccount: (accountCode, data, callback)->
    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <account>
        <account_code>#{accountCode}</account_code>
        <username>#{data.username}</username>
        <email>#{data.email}</email>
        <first_name>#{data.firstName}</first_name>
        <last_name>#{data.lastName}</last_name>
      </account>
      """

    @getAccount accountCode, (err, account)->
      if err or not account?.username
        post 'accounts', xml, callback
      else
        console.log 'does this ever happen?', xml, callback
        put "accounts/#{accountCode}", xml, callback

  @deleteAccount: (accountCode, callback)->
    del "accounts/#{accountCode}", callback

  createBillingObject = (b)->
    cardFirstName     : b.first_name[0]
    cardLastName      : b.last_name[0]
    cardNumber        : Array(13).join('*') + b.last_four
    cardMonth         : b.month[0]._
    cardYear          : b.year[0]._
    cardCV            : '***'
    cardType          : b.card_type[0]
    address1          : b.address1[0]
    address2          : ifString b.address2[0]
    city              : ifString b.city[0]
    state             : ifString b.state[0]
    zip               : b.zip[0]
    country           : b.country[0]

  @getBilling: (accountCode, callback)->
    get "accounts/#{accountCode}/billing_info", (err, res)->
      return callback err  if err?
      billingInfo = res[0]?.billing_info
      callback err,
        if billingInfo
        then createBillingObject billingInfo
        else {}

  @setBilling: (accountCode, data, callback)->
    # Remove credit card number if it's not updated
    if data.cardNumber?.indexOf('*') > -1 or data.cardCV?.cardCV is '***'
      delete data.cardNumber
      delete data.cardCV

    # See https://docs.recurly.com/api/account for XML format
    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <billing_info>
        <number>#{data.cardNumber}</number>
        <verification_value>#{data.cardCV}</verification_value>
        <month>#{data.cardMonth}</month>
        <year>#{data.cardYear}</year>

        <first_name>#{data.cardFirstName}</first_name>
        <last_name>#{data.cardLastName}</last_name>
        <address1>#{data.address}</address1>
        #{if data.city then #{"<state>#{data.city}</state>"} else ''}
        #{if data.state then #{"<state>#{data.state}</state>"} else ''}
        <zip>#{data.zip}</zip>
        <country>#{data.country}</country>

        <ip_address>#{data.ipAddress}</ip_address>
      </billing_info>
      """

    put "accounts/#{accountCode}/billing_info", xml, callback
