xml2js   = require 'xml2js'
https    = require 'https'
createId = require 'hat'
{argv}   = require 'optimist'
KONFIG   = require('koding-config-manager').load("main.#{argv.c}")

getUniqueId = -> createId 64
API_KEY     = KONFIG.recurly.apiKey

module.exports = class Recurly

  ifString = (str)-> if typeof str is 'string' then str else ''

  # Recurly's error entry structure. I'll use the same structure
  # for socket/http errors.
  createErrorObject = (short='', message='', field='')-> {short, message, field}

  summarizeErrors = (errors)->
    billing = 0
    for e in errors
      if e.field.indexOf('subscription.account.billing_info') > -1 and ++billing > 2
        return createErrorObject 'billing', 'Credit card information required.'

  # If requested list of records are longer than 50 items, recurly
  # paginates them. This method gets the URL path of next page.
  parseNextUrl = (res)->
    links = {}
    for link in res.headers.link.split(', ')
      linkData = link.split('; ')
      rel = linkData[1].substring(5, linkData[1].length - 1)
      url = linkData[0].substring(1, linkData[0].length - 1)
      links[rel] = url.substring(url.indexOf('v2') + 3)
    return links

  # This method makes a request to Recurly. If the page is chunked,
  # it waits for the last chunk and returns output as JS object.
  request = (method, operation, data, callback)->
    options =
      host     : 'api.recurly.com'
      port     : 443
      path     : '/v2/' + operation
      method   : method
      auth     : API_KEY + ':'
      headers  :
        Accept           : 'application/xml'
        'Content-Length' : Buffer.byteLength data, 'utf8'

    if data.length > 0
      options.headers['Content-Type'] = 'application/xml; charset=UTF-8'

    req = https.request options, (res)->
      res.setEncoding 'utf8'
      body = ''

      res.on 'data', (chunk)-> body += chunk
      res.on 'end',  ->
        return callback null, {}  unless body.length > 0

        # Parse XML and build JS object, or list of errors.
        xml2js.parseString body, (err, result)->
          if err
            callback [createErrorObject 'xml', 'Invalid XML']
          else if result.error
            callback [createErrorObject result.error.symbol[0], result.error.description[0]._]
          else if result.errors
            # See https://docs.recurly.com/api/basics/validation-errors for XML format
            errors = []
            for err1 in result.errors.error
              if err1.$
                errors.push createErrorObject err1.$.symbol, err1._, err1.$.field
              else
                errors.push createErrorObject err1, err1
            callback errors
          else
            # Find next page's URL if necessary
            nextUrl = parseNextUrl res  if res.headers.link
            callback null, result, nextUrl

    req.on 'error', (e)->
      callback [createErrorObject 'connection', 'Unable to connect to payment backend.']

    req.end(data, 'utf8')

  # POST request
  post = (operation, data, callback) ->
    request 'POST', operation, data, callback
  # PUT request
  put = (operation, data, callback) ->
    request 'PUT', operation, data, callback
  # DELETE request
  del = (operation, callback) ->
    request 'DELETE', operation, '', callback

  # GET request.
  # If there are multiple pages, this method requests all pages.
  # Returns list of XML/JS objects, not a single XML/JS object!
  # TODO: support buffering, return pages separately
  get = (operation, callback)->
    if operation.indexOf('per_page') == -1
      operation += "#{if operation.indexOf('?') > -1 then '&' else '?'}per_page=50"

    # Collect all GET responses before calling CB
    allData = []
    collect = (err, result, nextUrl)->
      return callback err  if err

      allData.push result

      if nextUrl
        request 'GET', nextUrl, '', collect
      else
        callback null, allData

    request 'GET', operation, '', collect

  #
  # concrete API methods
  #

  #
  # PLANS
  # See https://docs.recurly.com/api/plans for documentation
  #

  createPlanObject = (plan)->
    title       : plan.name[0]
    code        : plan.plan_code[0]
    desc        : ifString plan.description[0]
    feeMonthly  : parseInt plan.unit_amount_in_cents[0]['USD'][0]._, 10
    feeInitial  : parseInt plan.setup_fee_in_cents[0]['USD'][0]._, 10
    feeInterval : parseInt plan.plan_interval_length[0]._, 10

  @fetchPlans: (callback)->
    get 'plans', (err, res)->
      return callback err  if err

      plans = []
      for page in res when page.plans?.plan
        plans.push createPlanObject p  for p in page.plans.plan

      callback null, plans

  @getPlan: (data, callback)->
    get "plans/#{data.code}", (err, res)->
      return callback err  if err

      if res[0]?.plan
        callback null, createPlanObject res[0].plan
      else
        callback createErrorObject 'plan', 'Requested plan not found'

  @createPlan: (data, callback)->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <plan_code>#{data.code}</plan_code>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeMonthly, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    post 'plans', xml, (err, res)->
      callback err, unless err then createPlanObject res.plan

  @updatePlan: (data, callback)->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeMonthly, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    put "plans/#{data.code}", xml, (err, res)->
      callback err, unless err then createPlanObject res.plan

  @deletePlan: (data, callback)->
    del "plans/#{data.code}", callback

  #
  # SUBSCRIPTIONS
  # See https://docs.recurly.com/api/subscriptions for documentation
  #

  createSubscriptionObject = (sub)->
    sub =
      plan        : sub.plan[0].plan_code[0]
      quantity    : sub.quantity[0]._
      uuid        : sub.uuid[0]
      currency    : sub.currency[0]
      status      : sub.state[0]
      datetime    : sub.activated_at[0]._
      expires     : sub.expires_at[0]._
      renew       : sub.current_period_ends_at[0]._
      amount      : sub.unit_amount_in_cents[0]._

    if s.pending_subscription
      sub.pending =
        plan      : sub.pending_subscription[0].plan[0].plan_code[0]
        quantity  : sub.pending_subscription[0].quantity[0]._

    return sub

  @getSubscriptions: (paymentMethodId, callback)->
    get "accounts/#{paymentMethodId}/subscriptions", (err, res)->
      return callback err  if err

      subs = []
      for page in res
        subs.push createSubscriptionObject s  for s in page.subscriptions

      callback null, subs

  @getSubscription: (paymentMethodId, data, callback)->
    get "subscriptions/#{data.uuid}", (err, res)->
      return callback err  if err

      if res[0]?.subscription
        callback null, createSubscriptionObject res[0].subscription
      else
        callback createErrorObject 'subscription', 'Requested subscription not found'

  @createSubscription: (paymentMethodId, data, callback)->
    data.quantity ?= 1

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <plan_code>#{data.plan}</plan_code>
        <currency>USD</currency>
        <quantity>#{data.quantity}</quantity>
        <account>
          <account_code>#{paymentMethodId}</account_code>
        </account>
      </subscription>
      """

    post 'subscriptions', xml, (err, res)->
      callback err, unless err then createSubscriptionObject res.subscription

  @updateSubscription: (paymentMethodId, data, callback)->
    data.quantity ?= 1
    timeframe      = 'now'

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <timeframe>#{timeframe}</timeframe>
        <plan_code>#{data.plan}</plan_code>
        <quantity>#{data.quantity}</quantity>
      </subscription>
      """

    put "subscriptions/#{data.uuid}", xml, (err, res)->
      callback err, unless err then createSubscriptionObject res.subscription

  @terminateSubscription: (paymentMethodId, data, callback)->
    data.refund ?= 'none'

    put "subscriptions/#{data.uuid}/terminate?refund=#{data.refund}", '', (err, res)->
      callback err, unless err then createSubscriptionObject res.subscription

  @cancelSubscription: (paymentMethodId, data, callback)->
    put "subscriptions/#{data.uuid}/cancel", '', (err, res)->
      callback err, unless err then createSubscriptionObject res.subscription

  @reactivateUserSubscription: (paymentMethodId, data, callback)->
    put "subscriptions/#{data.uuid}/reactivate", '', (err, res)->
      callback err, unless err then createSubscriptionObject res.subscription

  #
  # TRANSACTIONS
  # See https://docs.recurly.com/api/transactions for documentation
  #

  createTransactionObject = (t)->
    trans =
      uuid       : t.uuid[0]
      status     : t.status[0]
      amount     : parseInt t.amount_in_cents[0]._, 10
      tax        : parseInt t.tax_in_cents[0]._, 10
      currency   : t.currency[0]
      datetime   : t.created_at[0]._
      refundable : t.refundable[0]._
      source     : t.source[0]

    trans.invoice = t.invoice[0].$.href  if t.invoice

    if trans.status in ['success', 'void']
      billing          = t.details[0].account[0].billing_info[0]
      trans.owner      = "#{billing.first_name[0]} #{billing.last_name[0]}"
      trans.cardType   = billing.card_type[0]
      trans.cardNumber = "#{billing.last_four}"

    return trans

  @getTransactions: (paymentMethodId, callback)->
    get "accounts/#{paymentMethodId}/transactions", (err, res)->
      return callback err  if err

      trans = []
      for page in res
        trans.push createTransactionObject t  for t in page.transactions?.transaction

      callback null, trans

  @createTransaction: (paymentMethodId, data, callback)->
    xml =
      """
      <transaction>
        <description>#{data.desc}</description>
        <amount_in_cents>#{data.amount}</amount_in_cents>
        <currency>USD</currency>
        <account>
          <account_code>#{paymentMethodId}</account_code>
        </account>
      </transaction>
      """

    post 'transactions', xml, (err, res)->
      callback err, unless err then createTransactionObject res.transaction

  @deleteTransaction: (paymentMethodId, data, callback)->
    del "transactions/#{data.uuid}?amount_in_cents=##{data.amount}", callback

  #
  # INVOICES
  # See https://docs.recurly.com/api/invoices for XML format
  #

  createInvoiceObject = (i)->
    uuid     : i.uuid[0]
    amount   : i.total_in_cents[0]._
    currency : i.currency[0]
    state    : i.state[0]

  @getInvoices: (paymentMethodId, callback)->
    get "accounts/#{paymentMethodId}/invoices", (err, res)->
      return callback err  if err

      invs = []
      for page in res
        invs.push createInvoiceObject i  for i in page.invocies?.invoice

      callback null, invs

  # charge amount from pending one-time adjustments (carge/credit) to subscription
  # if not manually charged with this method, those will be automatically charged
  # on subscription's renewal (typically monthly)
  @chargePending: (paymentMethodId, callback)->
    post "accounts/#{paymentMethodId}/invoices", '', (err, res)->
      callback err, unless err then createTransactionObject res.transaction

  #
  # ADJUSTMENTS (ONE-TIME CHARGE/CREDIT TO SUBSCRIPTION)
  # See https://docs.recurly.com/api/invoices for XML format
  #

  createAdjustmentObject = (a)->
    uuid        : a.uuid[0]
    amount      : a.total_in_cents[0]._
    currency    : a.currency[0]
    description : if a.description[0].$ then '' else a.description[0]
    type        : a.$.type
    origin      : a.origin[0]

  @getAdjustments: (paymentMethodId, type, state, callback)->
    [callback, state] = [state, callback]  unless callback
    [callback, type]  = [type, callback]   unless callback
    type  or= 'credits and charges'
    state or= 'active'

    get "accounts/#{paymentMethodId}/adjustments?type=#{type}&state=#{state}", (err, res)->
      return callback err  if err

      adjs = []
      for page in res
        adjs.push createAdjustmentObject a  for a in page.adjustments?.adjustment

      callback null, adjs

  @getCharged: (paymentMethodId, callback)->
    @getAdjustments paymentMethodId, 'charge', 'invoiced', callback

  @getPendingCharges: (paymentMethodId, callback)->
    @getAdjustments paymentMethodId, 'charge', 'pending', callback

  @getCredited: (paymentMethodId, callback)->
    @getAdjustments paymentMethodId, 'credit', 'invoiced', callback

  @getPendingCredits: (paymentMethodId, callback)->
    @getAdjustments paymentMethodId, 'credit', 'pending', callback

  @createAdjustment: (paymentMethodId, data, callback)->
    xml =
      """
      <adjustment>
        <description>#{data.desc}</description>
        <unit_amount_in_cents>#{data.amount}</unit_amount_in_cents>
        <currency>USD</currency>
        <quantity>1</quantity>
        <accounting_code>#{data.accountingCode}</accounting_code>
      </adjustment>
      """

    post "accounts/#{paymentMethodId}/adjustments", xml, (err, res)->
      callback err, unless err then createAdjustmentObject res.adjustment

  @createCharge: @createAdjustment

  @createRefund: (paymentMethodId, data, callback)->
    data.unit_amount_in_cents = "-#{data.unit_amount_in_cents}"
    @createAdjustment paymentMethodId, data, callback

  #
  # ACCOUNTS and BILLING INFO
  # See https://docs.recurly.com/api/accounts for XML format
  #

  createAccountObject = (acc, billing) ->
    firstName : acc.first_name[0]
    lastName  : acc.last_name[0]
    email     : acc.email[0]
    username  : acc.username[0]
    url       : 'https://koding.recurly.com/account/' + acc.hosted_login_token[0]
    billing   : billing

  @fetchAccountDetailsByPaymentMethodId: (paymentMethodId, callback) ->
    get "accounts/#{paymentMethodId}", (err, res) =>
      return callback err  if err
      @fetchBillingByPaymentMethodId paymentMethodId, (err, billing) ->
        return callback err  if err
        callback null, createAccountObject res[0]?.account, billing

  @setAccountDetailsByPaymentMethodId: (paymentMethodId, data, callback) ->

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <account>
        <account_code>#{paymentMethodId}</account_code>
        <username>#{data.username}</username>
        <email>#{data.email}</email>
        <first_name>#{data.firstName}</first_name>
        <last_name>#{data.lastName}</last_name>
      </account>
      """

    @fetchAccountDetailsByPaymentMethodId paymentMethodId, (err, account) ->
      if err or not account?.username
        post 'accounts', xml, callback
      else
        put "accounts/#{paymentMethodId}", xml, callback

  @deleteAccount: (paymentMethodId, callback)->
    del "accounts/#{paymentMethodId}", callback

  filterNils = (ob) ->
    ob[key] = null  for own key, val of ob when val?.$?.nil?
    ob

  createPaymentObject = (b) ->
    filterNils
      cardFirstName     : b.first_name[0]
      cardLastName      : b.last_name[0]
      cardNumber        : Array(13).join('*') + b.last_four
      cardMonth         : b.month[0]._
      cardYear          : b.year[0]._
      cardCV            : '***'
      cardType          : b.card_type[0]
      address1          : b.address1[0]
      address2          : ifString b.address2[0]
      city              : ifString b.city[0]
      state             : ifString b.state[0]
      zip               : b.zip[0]
      country           : b.country[0]
      company           : b.company[0]
      vatNumber         : b.vat_number[0]
      phone             : b.phone[0]

  @fetchBillingByPaymentMethodId: (paymentMethodId, callback)->
    get "accounts/#{paymentMethodId}/billing_info", (err, res)->
      return callback err  if err?
      paymentMethod = res[0]?.billing_info
      callback err,
        if paymentMethod
        then createPaymentObject paymentMethod
        else {}

  makeTag = (data, field, tagName = field) ->
    if data[field] then "<#{tagName}>#{data[field]}</#{tagName}>" else ''

  @setBillingByPaymentMethodId = (paymentMethodId, data, callback)->
    # Remove credit card number if it's not updated
    if (data.cardNumber?.indexOf '*') > -1 or data.cardCV?.cardCV is '***'
      delete data.cardNumber
      delete data.cardCV

    tag = makeTag.bind null, data

    # See https://docs.recurly.com/api/account for XML format
    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <billing_info>
        #{tag 'cardNumber', 'number'}
        #{tag 'cardCV', 'verification_value'}
        #{tag 'cardMonth', 'month'}
        #{tag 'cardYear', 'year'}
        #{tag 'company'}
        #{tag 'cardFirstName', 'first_name'}
        #{tag 'cardLastName', 'last_name'}
        #{tag 'address1'}
        #{tag 'city'}
        #{tag 'state'}
        #{tag 'zip'}
        #{tag 'country'}
        #{tag 'phone'}
        #{tag 'vatNumber', 'vat_number'}
        #{tag 'ipAddress', 'ip_address'}
      </billing_info>
      """

    put "accounts/#{paymentMethodId}/billing_info", xml, callback
