
{argv}   = require 'optimist'
KONFIG   = require('koding-config-manager').load("main.#{argv.c}")


module.exports = class Recurly

  models = require './models'

  { GET, POST, PUT, DEL } = (require './request') KONFIG.recurly.apiKey

  summarizeErrors = (errors)->
    billing = 0
    for e in errors
      if e.field.indexOf('subscription.account.billing_info') > -1 and ++billing > 2
        return new models.Error 'billing', 'Credit card information required.'

  # If requested list of records are longer than 50 items, recurly
  # paginates them. This method gets the URL path of next page.
  parseNextUrl = (res)->
    links = {}
    for link in res.headers.link.split(', ')
      linkData = link.split('; ')
      rel = linkData[1].substring(5, linkData[1].length - 1)
      url = linkData[0].substring(1, linkData[0].length - 1)
      links[rel] = url.substring(url.indexOf('v2') + 3)
    return links


  #
  # concrete API methods
  #

  @fetchPlans: (callback) ->
    GET 'plans', (err, res) ->
      return callback err  if err

      plans = []
      for page in res when page.plans?.plan
        plans.push new models.Plan p  for p in page.plans.plan

      callback null, plans

  @fetchPlan: (data, callback) ->
    GET "plans/#{data.code}", (err, res) ->
      return callback err  if err

      if res[0]?.plan
        callback null, new models.Plan res[0].plan
      else
        callback new models.Error 'plan', 'Requested plan not found'

  @createPlan: (data, callback) ->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <plan_code>#{data.code}</plan_code>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeMonthly, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    POST 'plans', xml, (err, res) ->
      callback err, unless err then new models.Plan res.plan

  @updatePlan: (data, callback)->
    data.feeInitial  ?= 0
    data.feeInterval ?= 1

    xml =
      """
      <plan>
        <name>#{data.title}</name>
        <setup_fee_in_cents>
          <USD>#{parseInt(data.feeInitial, 10)}</USD>
        </setup_fee_in_cents>
        <unit_amount_in_cents>
          <USD>#{parseInt(data.feeMonthly, 10)}</USD>
        </unit_amount_in_cents>
        <plan_interval_length>#{data.feeInterval}</plan_interval_length>
        <plan_interval_unit>months</plan_interval_unit>
      </plan>
      """

    PUT "plans/#{data.code}", xml, (err, res)->
      callback err, unless err then new models.Plan res.plan

  @deletePlan: (data, callback)->
    DEL "plans/#{data.code}", callback


  @fetchSubscriptions: (accountCode, callback) ->
    GET "accounts/#{accountCode}/subscriptions", (err, res) ->
      return callback err  if err

      subs = []
      for page in res
        subs.push new models.Subscription s  for s in page.subscriptions

      callback null, subs

  @fetchSubscription: (accountCode, data, callback) ->
    GET "subscriptions/#{data.uuid}", (err, res) ->
      return callback err  if err

      if res[0]?.subscription
        callback null, new models.Subscription res[0].subscription
      else
        callback new models.Error 'subscription', 'Requested subscription not found'

  @createSubscription: (paymentMethodId, data, callback)->
    data.quantity ?= 1

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <plan_code>#{data.plan}</plan_code>
        <currency>USD</currency>
        <quantity>#{data.quantity}</quantity>
        <account>
          <account_code>#{paymentMethodId}</account_code>
        </account>
      </subscription>
      """

    POST 'subscriptions', xml, (err, res)->
      callback err, unless err then new models.Subscription res.subscription

  @updateSubscription: (paymentMethodId, data, callback)->
    data.quantity ?= 1
    timeframe      = 'now'

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <subscription>
        <timeframe>#{timeframe}</timeframe>
        <plan_code>#{data.plan}</plan_code>
        <quantity>#{data.quantity}</quantity>
      </subscription>
      """

    PUT "subscriptions/#{data.uuid}", xml, (err, res)->
      callback err, unless err then new models.Subscription res.subscription

  @terminateSubscription: (paymentMethodId, data, callback)->
    data.refund ?= 'none'

    PUT "subscriptions/#{data.uuid}/terminate?refund=#{data.refund}", '', (err, res)->
      callback err, unless err then new models.Subscription res.subscription

  @cancelSubscription: (accountCode, data, callback)->
    PUT "subscriptions/#{data.uuid}/cancel", '', (err, res)->
      callback err, unless err then new models.Subscription res.subscription

  @reactivateUserSubscription: (accountCode, data, callback)->
    PUT "subscriptions/#{data.uuid}/reactivate", '', (err, res)->
      callback err, unless err then new models.Subscription res.subscription



  @fetchTransactions: (accountCode, callback) ->
    GET "accounts/#{accountCode}/transactions", (err, res) ->
      return callback err  if err

      trans = []
      for page in res
        trans.push new models.Transaction t  for t in page.transactions?.transaction

      callback null, trans

  @createTransaction: (paymentMethodId, data, callback)->
    xml =
      """
      <transaction>
        <description>#{data.desc}</description>
        <amount_in_cents>#{data.amount}</amount_in_cents>
        <currency>USD</currency>
        <account>
          <account_code>#{paymentMethodId}</account_code>
        </account>
      </transaction>
      """

    POST 'transactions', xml, (err, res)->
      callback err, unless err then new models.Transaction res.transaction

  @deleteTransaction: (accountCode, data, callback)->
    DEL "transactions/#{data.uuid}?amount_in_cents=##{data.amount}", callback



  @fetchInvoices: (accountCode, callback) ->
    GET "accounts/#{accountCode}/invoices", (err, res) ->
      return callback err  if err

      invs = []
      for page in res
        invs.push new models.Invoice i  for i in page.invocies?.invoice

      callback null, invs

  # charge amount from pending one-time adjustments (carge/credit) to subscription
  # if not manually charged with this method, those will be automatically charged
  # on subscription's renewal (typically monthly)
  @chargePending: (accountCode, callback)->
    POST "accounts/#{accountCode}/invoices", '', (err, res)->
      callback err, unless err then new models.Transaction res.transaction


  @fetchAdjustments: (accountCode, type, state, callback) ->
    [callback, state] = [state, callback]  unless callback
    [callback, type]  = [type, callback]   unless callback
    type  or= 'credits and charges'
    state or= 'active'

    url = "accounts/#{accountCode}/adjustments?type=#{type}&state=#{state}"

    GET url, (err, res) ->
      return callback err  if err

      adjs = []
      for page in res
        adjs.push new models.Adjustment a  for a in page.adjustments?.adjustment

      callback null, adjs

  @fetchCharged: (accountCode, callback) ->
    @fetchAdjustments accountCode, 'charge', 'invoiced', callback

  @fetchPendingCharges: (accountCode, callback) ->
    @fetchAdjustments accountCode, 'charge', 'pending', callback

  @fetchCredited: (accountCode, callback) ->
    @fetchAdjustments accountCode, 'credit', 'invoiced', callback

  @fetchPendingCredits: (accountCode, callback) ->
    @fetchAdjustments accountCode, 'credit', 'pending', callback

  @createAdjustment: (accountCode, data, callback) ->
    xml =
      """
      <adjustment>
        <description>#{data.desc}</description>
        <unit_amount_in_cents>#{data.amount}</unit_amount_in_cents>
        <currency>USD</currency>
        <quantity>1</quantity>
        <accounting_code>#{data.accountingCode}</accounting_code>
      </adjustment>
      """

    POST "accounts/#{accountCode}/adjustments", xml, (err, res) ->
      callback err, unless err then new models.Adjustment res.adjustment

  @createCharge: @createAdjustment

  @createRefund: (accountCode, data, callback) ->
    data.unit_amount_in_cents = "-#{data.unit_amount_in_cents}"
    @createAdjustment accountCode, data, callback


  @fetchAccountDetailsByAccountCode: (accountCode, callback) ->
    GET "accounts/#{accountCode}", (err, res) =>
      return callback err  if err
      @fetchBillingByPaymentMethodId paymentMethodId, (err, billing) ->
        return callback err  if err
        callback null, new models.Account res[0]?.account, billing

  @setAccountDetailsByPaymentMethodId: (paymentMethodId, data, callback) ->

    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <account>
        <account_code>#{paymentMethodId}</account_code>
        <username>#{data.username}</username>
        <email>#{data.email}</email>
        <first_name>#{data.firstName}</first_name>
        <last_name>#{data.lastName}</last_name>
      </account>
      """

    @fetchAccountDetailsByPaymentMethodId paymentMethodId, (err, account) ->
      if err or not account?.username
        POST 'accounts', xml, callback
      else
        PUT "accounts/#{accountCode}", xml, callback

  @deleteAccount: (accountCode, callback)->
    DEL "accounts/#{accountCode}", callback



  @fetchBillingByAccountCode: (accountCode, callback)->
    GET "accounts/#{accountCode}/billing_info", (err, res)->
      return callback err  if err?
      paymentMethod = res[0]?.billing_info
      callback err,
        if paymentMethod
        then new models.Billing paymentMethod
        else {}

  makeTag = (data, field, tagName = field) ->
    if data[field] then "<#{tagName}>#{data[field]}</#{tagName}>" else ''

  @setBillingByPaymentMethodId = (paymentMethodId, data, callback)->
    # Remove credit card number if it's not updated
    if (data.cardNumber?.indexOf '*') > -1 or data.cardCV?.cardCV is '***'
      delete data.cardNumber
      delete data.cardCV

    tag = makeTag.bind null, data

    # See https://docs.recurly.com/api/account for XML format
    xml =
      """
      <?xml version="1.0" encoding="UTF-8"?>
      <billing_info>
        #{tag 'cardNumber', 'number'}
        #{tag 'cardCV', 'verification_value'}
        #{tag 'cardMonth', 'month'}
        #{tag 'cardYear', 'year'}
        #{tag 'company'}
        #{tag 'cardFirstName', 'first_name'}
        #{tag 'cardLastName', 'last_name'}
        #{tag 'address1'}
        #{tag 'city'}
        #{tag 'state'}
        #{tag 'zip'}
        #{tag 'country'}
        #{tag 'phone'}
        #{tag 'vatNumber', 'vat_number'}
        #{tag 'ipAddress', 'ip_address'}
      </billing_info>
      """

    PUT "accounts/#{accountCode}/billing_info", xml, callback
