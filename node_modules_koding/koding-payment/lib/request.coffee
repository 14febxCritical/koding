module.exports = class Request

  models = require './models'

  constructor: (apiKey) ->
    return new Request apiKey  unless this instanceof Request

    @apiKey = apiKey

  POST: (operation, data, callback) =>
    @request 'POST', operation, data, callback

  PUT: (operation, data, callback) =>
    @request 'PUT', operation, data, callback

  DEL: (operation, callback) =>
    @request 'DELETE', operation, '', callback

  # GET request.
  # If there are multiple pages, this method requests all pages.
  # Returns list of XML/JS objects, not a single XML/JS object!
  # TODO: support buffering, return pages separately
  GET: (operation, callback) =>
    if operation.indexOf('per_page') is -1
      operation += "#{if operation.indexOf('?') > -1 then '&' else '?'}per_page=50"

    # Collect all GET responses before calling CB
    allData = []
    collect = (err, result, nextUrl) =>
      return callback err  if err

      allData.push result

      if nextUrl
        @request 'GET', nextUrl, '', collect
      else
        callback null, allData

    @request 'GET', operation, '', collect


  # This method makes a request to Recurly. If the page is chunked,
  # it waits for the last chunk and returns output as JS object.
  request: (method, operation, data, callback) ->

    https = require 'https'
    xml2js = require 'xml2js'

    options =
      host     : 'api.recurly.com'
      port     : 443
      path     : "/v2/#{ operation }"
      method   : method
      auth     : "#{ @apiKey }:"
      headers  :
        Accept           : 'application/xml'
        'Content-Length' : Buffer.byteLength data, 'utf8'

    if data.length > 0
      options.headers['Content-Type'] = 'application/xml; charset=UTF-8'

    req = https.request options, (res)->
      res.setEncoding 'utf8'
      body = ''

      res.on 'data', (chunk)-> body += chunk
      res.on 'end',  ->
        return callback null, {}  unless body.length > 0

        # Parse XML and build JS object, or list of errors.
        xml2js.parseString body, (err, result)->
          if err
            callback [new models.Error 'xml', 'Invalid XML']
          else if result.error
            callback [new models.Error result.error.symbol[0], result.error.description[0]._]
          else if result.errors
            # See https://docs.recurly.com/api/basics/validation-errors for XML format
            errors = []
            for err1 in result.errors.error
              if err1.$
                errors.push new models.Error err1.$.symbol, err1._, err1.$.field
              else
                errors.push new models.Error err1, err1
            callback errors
          else
            # Find next page's URL if necessary
            nextUrl = parseNextUrl res  if res.headers.link
            callback null, result, nextUrl

    req.on 'error', (e)->
      callback [new models.Error 'connection', 'Unable to connect to payment backend.']

    req.end(data, 'utf8')