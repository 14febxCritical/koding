fs                = require 'fs'
os                = require 'os'
path              = require 'path'
uuid              = require 'node-uuid'
crypto            = require "crypto"
WebSocket         = require 'ws'
WebSocketServer   = require('ws').Server
{env}             = process
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Environment       = require './environment'
Client            = require './client'
uuid              = require 'node-uuid'
{Request, RequestFilter, RequestFilters, AuthenticateFilter} =require './request'

noop = ()->

runWithTimeout = (scope, timeout, fn)->
  # if fn is not called within spesified time,
  # calls fn with err
  # timeout is in seconds
  isFnCalled = false
  setTimeout ()->
    if not isFnCalled
      fn "Kite worker didnt return in time", null
  , timeout * 1000
  return (args...)->
    isFnCalled = true
    fn.apply scope, args

urlSafeBase64decode = (encoded)->
  encoded = encoded.replace(/\-/g, '+').replace(/_/g, '/')
  new Buffer(encoded, 'base64')

sha256 = (s)->
  shasum = crypto.createHash 'sha256'
  shasum.update(s)
  shasum.digest('binary')

decrypt = (encodedToken, kodingKey)->
  # token = 'u3IsfJXb9gdzfqskbGj_lQK-_Aw1BhX8eWUBZzbqRFAi-Q-TCxmd7KILfL6Pvjrh117ZYHOdB2yy9YcTId9cMV3TN6oKk6zhjr5x8_QViuGqckmNP6OSKMGh5cIFOehi6oxpeHRb2pQEeVtyCHxVHOZE7v2GX6LaQz1IPwbyCDja9Mw='
  # kodingKey = 'NPhFRpZPYuWA4kFA7Y0ewEIQy7qdgj3ij6tegRQ9sd2s-g2-Debdi20fStRiIM5Z'
  # plaintext = decrypt(token, kodingKey)
  decodedToken = urlSafeBase64decode encodedToken
  iv = (new Buffer decodedToken.slice(0, 16))
  kodingKey = sha256(urlSafeBase64decode(kodingKey))
  ciphertext = decodedToken.slice(16, decodedToken.length)
  # Decipher encrypted data
  decipher = crypto.createDecipheriv('aes-256-cfb', kodingKey, iv);
  decrypted = decipher.update(ciphertext, 'binary') + decipher.final('binary');
  new Buffer(decrypted, 'binary').toString('utf8');

class Authenticator
  constructor: ()->
  authenticate: ()->
    return false

class KodingKeyAuthenticator extends Authenticator
  authenticate: (token, kodingKey)->
    token == kodingKey

class TokenAuthenticator extends Authenticator
  authenticate: (token, kodingKey)->
    decryptedToken = decrypt(token, kodingKey)
    if not decryptedToken
      return false
    JSON.parse decryptedToken

class KiteConnectionWrapper extends EventEmitter
  constructor: (@client, @worker)->
  tell: (method, args...)->
    @callRemote method, args[0], null

  callRemote: (method, args, authentication, callback=noop)=>
    scrubber = new Scrubber @worker.localStore
    # adding required stuff
    payload = {}
    payload.kite =
      name: @worker.kitename
      username: @worker.environment.userName()
      id: @worker.uuid
      environment: @worker.environment.environment()
      region: @worker.environment.region()
      version: @worker.environment.version()
      hostname: @worker.environment.hostname()
      publicIP: ""
      port: @worker.port.toString()
    payload.withArgs = args

    if authentication
      payload.authentication = authentication
    else
      payload.authentication =
        type: "kodingKey",
        key: @worker.environment.kodingKey()

    scrubber.scrub [payload, callback], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      message = JSON.stringify scrubbed
      console.log "sending:", message
      @client.send message

class Worker extends EventEmitter
  constructor: (@options={})->
    @kiteName       = @options.name
    @username       = @options.username
    throw "every worker needs a name" if not @kiteName? and not @kiteName
    @localStore     = new Store
    @remoteStore    = new Store
    @environment    = options.environment or new Environment username: @username
    @authenticators =
      'kodingKey': new KodingKeyAuthenticator
      'token'    : new TokenAuthenticator

    @requestFilters = new RequestFilters [new AuthenticateFilter(this)]
    @uuid           = uuid.v4()
    @api            = {}

  callRemote: (client, method, args)=>
    scrubber = new Scrubber @localStore
    # adding required stuff
    payload = args
    scrubber.scrub payload, =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      message = JSON.stringify scrubbed
      client.send message

  handleFunc: (name, func)->
    @api[name] = func

  runServer: (@host="localhost", @port=9999)->
    worker = this
    @wss = new WebSocketServer host:@host, port: @port
    @kontrolClient = new Client name:@kiteName, port: @port, environment: @environment
    @kontrolClient.on 'connected', ()=>
      console.log "connecting to kontrol"
      @kontrolClient.callRemote "register", null, (err, data)->
        console.log "register callback", err, data
        throw "Kite register error #{err}"
    @kontrolClient.connect()

    @wss.on 'connection', (client)->
      client.on 'message', (data)->
        console.log('received: %s', data)
        scrubbed = JSON.parse data
        scrubber = new Scrubber worker.localStore
        unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
          unless worker.remoteStore.has(callbackId)
            worker.remoteStore.add callbackId, (args...)->
              worker.callRemote client, callbackId, args
          worker.remoteStore.get callbackId

        if worker.api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof worker.api[scrubbed.method]
          callback = worker.api[scrubbed.method]
        else
          # this is a client tell callback
          callback = worker.localStore.get(scrubbed.method)
          callback.apply unscrubbed
          # we dont have anything else to do here
          return

        clientCallback = unscrubbed[1]

        options =
          localKite: worker,
          remoteKite: new KiteConnectionWrapper(client, worker),
          method: scrubbed.method,
          args: unscrubbed[0].withArgs,
          username: null, # <-- this will be added by authentication filter
          authentication: unscrubbed[0].authentication
        request = new Request options

        worker.requestFilters.runFilters request, (err, request)->
          return clientCallback err, null if err

          if callback
            callback request, runWithTimeout(worker, 2, clientCallback)

module.exports.RequestFilter  = RequestFilter
module.exports.RequestFilters = RequestFilters
module.exports.Worker         = Worker
