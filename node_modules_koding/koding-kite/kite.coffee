fs                = require 'fs'
os                = require 'os'
path              = require 'path'
uuid              = require 'node-uuid'
WebSocket         = require 'ws'
WebSocketServer   = require('ws').Server
jwt               = require('green-jwt')
{env}             = process
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Settings          = require './settings'
{Kontrol}         = require './remote'
{Request, RequestFilter, RequestFilters, AuthenticateFilter} = require './request'
{KiteError}       = require './errors'
{getArgNames}     = require './utils'
log4js            = require 'log4js'
Sync              = require 'sync'

logger = log4js.getLogger()

noop = ()->

class Authenticator
  constructor: ()->
  authenticate: (key, request, kite)->
    return false

class KodingKeyAuthenticator extends Authenticator
  authenticate: (key, request, kite)->
    if key != kite.settings.kodingKey()
      return false

    request.username = kite.username  # A koding key belongs to only one user.
    return true

class TokenAuthenticator extends Authenticator
  constructor: (@keys)->

  authenticate: (key, request, kite)->
    token = jwt.decode key

    if not token.verify @keys[token.claim.iss]  # Issuer
      console.log 1
      return false

    if token.claim.aud is not kite.uuid  # Audience
      console.log 2
      return false

    now = new Date

    exp = new Date(token.claim.exp * 1000)  # Expiration Time
    console.log exp
    console.log now
    if exp < now
      console.log 3
      return false

    if token.claim.nbf * 1000 > now  # Not before
      console.log 4
      return false

    request.username = token.claim.sub  # Username
    return true

class KiteConnectionWrapper extends EventEmitter
  constructor: (@client, @kite)->
  go: (method, args, callback=noop)=>
    scrubber = new Scrubber @kite.localStore
    # adding required stuff
    payload = {}
    payload.kite = @kite.getProperties()
    if Array.isArray args
      payload.withArgs = args
    else
      payload.withArgs = [args]
    payload.responseCallback = callback
    payload.authentication =
      type: "kodingKey",
      key: @kite.settings.kodingKey()

    scrubber.scrub [payload], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      logger.debug "sending to connected client: #{JSON.stringify scrubbed}"
      @client.send JSON.stringify scrubbed

class Options
  constructor: (options)->
    @username     = options.username
    @kitename     = options.kitename
    @publicIP     = options.publicIP
    @environment  = options.environment
    @region       = options.region
    @port         = options.port
    @version      = options.version
    @kontrolAddr  = options.kontrolAddr
    @dependencies = options.dependencies
    @visibility   = options.visibility or "PRIVATE"

class Kite extends EventEmitter
  # Kite takes kite.Options struct
  constructor: (@options)->
    @kiteName       = @options.kitename
    @username       = @options.username
    @localStore     = new Store
    @remoteStore    = new Store
    @settings       = options.settings or new Settings username: @username
    @trustedKontrolKeys = {}
    @trustKontrolKey "koding.com", kodingKontrolPublicKey
    @authenticators =
      'kodingKey': new KodingKeyAuthenticator
      'token'    : new TokenAuthenticator @trustedKontrolKeys
    @requestFilters = new RequestFilters [new AuthenticateFilter(this)]
    @uuid           = uuid.v4()
    @api            = {}
    @host           = @options.publicIP
    @port           = @options.port

  getProperties: ->
    # Equivalent of go struct: koding/newkite/protocol.Kite
    name:         @options.kitename
    username:     @settings.userName()
    id:           @uuid
    environment:  @settings.environment()
    region:       @settings.region()
    visibility:   @options.visibility
    version:      @settings.version()
    hostname:     @settings.hostname()
    url:          @getURL()

  trustKontrolKey: (issuer, key)->
    @trustedKontrolKeys[issuer] = key

  tell: (client, method, args, callback=noop)=>
    scrubber = new Scrubber @localStore

    # adding required stuff
    options = {}
    options.kite = @getProperties()
    options.withArgs = args
    options.authentication = @authentication
    options.responseCallback = callback

    scrubber.scrub [options], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method

      logger.debug "sending #{JSON.stringify scrubbed}"
      client.send JSON.stringify(scrubbed), (err)->
        if err
          logger.debug "error while sending data", err

  handleFunc: (name, func)->
    argList = getArgNames func
    # depending on the parameter list of the function
    # we decide if its written in sync fashion, or async
    # style, then wrap it in async way
    if argList.length is 1
      @api[name] = func.async()
    else
      @api[name] = func

  # Run is blocking, waits until start takes
  run: ()->
    @start.sync this

  onConnection: (client)=>
    kite = this
    client.remoteStore = new Store
    client.on 'message', (data)=>
      scrubbed = JSON.parse data
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
        unless client.remoteStore.has(callbackId)
          client.remoteStore.add callbackId, (args...)->
            kite.tell client, callbackId, args
        return client.remoteStore.get callbackId

      if kite.api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof kite.api[scrubbed.method]
        callback = kite.api[scrubbed.method]
      else
        # this is a client tell callback
        callback = kite.localStore.get(scrubbed.method)
        callback.apply unscrubbed
        # we dont have anything else to do here
        return

      clientCallback = (err, result)->
        unscrubbed[0].responseCallback({error: err, result: result})

      options =
        localKite: this,
        remoteKite: new KiteConnectionWrapper(client, this),
        method: scrubbed.method,
        args: unscrubbed[0].withArgs,
        username: null, # <-- this will be added by authentication filter
        authentication: unscrubbed[0].authentication
      request = new Request options

      @requestFilters.runFilters request, (err, request)->
        return clientCallback err, null if err

        if callback
          callback request, clientCallback

  # Start is like Run(), but does not wait for it to complete. It's nonblocking.
  start: (callback)->
    # TODO:
    @Kontrol = new Kontrol @, {name: "kontrol", url: @settings.kontrolAddress()}, =>
      @Kontrol.tell "register", [], (request)->
        response = request.args[0]
        if response.error
          logger.error "Cannot register to Kontrol", response.error
        else
          logger.info "Registered to kontrol", response.result
      callback null, this

    @ws = new WebSocketServer {host: @options.publicIP, port: @options.port, path: "/kite"}
    @ws.on 'connection', @onConnection

  getURL: ->
    return "ws://" + @options.publicIP + ":" + @options.port + "/kite"

kodingKontrolPublicKey = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3RXNFJ3WjhchYHu+kUyl
lAW1/Az6EwZXc6Cw4aQpVna+MSUxNfc70SfFGopngcvuS6KuOaqsybcTXNsc+qTH
FzyFuujNv/59cw3Cvh6Rn846LtGhSEWGoYBQOXN2Xn/A8OLvxf9Jfxl0nXvlmg0G
B4afDWLHarDatc/nFXqWhyZhr/LE9wZPIXmkkoX3IrHxKKSHzIpbFF+gioETMKPi
dMno1Y0gvPNYkn7LUKzPFsCKAmLU7M6uHDgET4jnRQqCLOIyxW9YEcHVgMMon6Ql
ArrvdXpUpMAg5ijhF97TJpyn7n5SjLkpSBAj/hYsaATcYbEvIBD9XD8rcPDwyFg7
HQIDAQAB
-----END PUBLIC KEY-----"""

module.exports.RequestFilter  = RequestFilter
module.exports.RequestFilters = RequestFilters
module.exports.Kite           = Kite

kite = {}
kite.utils = sleep: Sync.sleep
kite.Options = Options
kite.Kite    = Kite
kite.New = (options)-> new Kite options
kite.main = (fn)->
  Sync fn
module.exports.kite = kite
