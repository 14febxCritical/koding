fs = require 'fs'
os = require 'os'
path = require 'path'
uuid = require 'node-uuid'
crypto = require "crypto"

WebSocket = require 'ws'
WebSocketServer = require('ws').Server
{env} = process
{EventEmitter} = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'


noop = ->

generateUUID = ()->
  uuid.v4()

runWithTimeout = (scope, timeout, fn)->
  # if fn is not called within spesified time,
  # calls fn with err
  # timeout is in seconds
  isFnCalled = false
  setTimeout ()->
    if not isFnCalled
      fn "Kite worker didnt return in time", null
  , timeout * 1000
  return (args...)->
    isFnCalled = true
    fn.apply scope, args

urlSafeBase64decode = (encoded)->
  encoded = encoded.replace(/\-/g, '+').replace(/_/g, '/')
  new Buffer(encoded, 'base64')

sha256 = (s)->
  shasum = crypto.createHash 'sha256'
  shasum.update(s)
  shasum.digest('binary')

decrypt = (encodedToken, kodingKey)->
# token = 'u3IsfJXb9gdzfqskbGj_lQK-_Aw1BhX8eWUBZzbqRFAi-Q-TCxmd7KILfL6Pvjrh117ZYHOdB2yy9YcTId9cMV3TN6oKk6zhjr5x8_QViuGqckmNP6OSKMGh5cIFOehi6oxpeHRb2pQEeVtyCHxVHOZE7v2GX6LaQz1IPwbyCDja9Mw='
# kodingKey = 'NPhFRpZPYuWA4kFA7Y0ewEIQy7qdgj3ij6tegRQ9sd2s-g2-Debdi20fStRiIM5Z'
# plaintext = decrypt(token, kodingKey)
  decodedToken = urlSafeBase64decode encodedToken
  iv = (new Buffer decodedToken.slice(0, 16))
  kodingKey = sha256(urlSafeBase64decode(kodingKey))
  ciphertext = decodedToken.slice(16, decodedToken.length)
  # Decipher encrypted data
  decipher = crypto.createDecipheriv('aes-256-cfb', kodingKey, iv);
  decrypted = decipher.update(ciphertext, 'binary') + decipher.final('binary');
  new Buffer(decrypted, 'binary').toString('utf8');

class Environment
  constructor: (@options={})->
    @basePath = path.join env.HOME || env.HOMEPATH || env.USERPROFILE, ".kd"
    @options.username     or= env.USER
    @options.version      or= "1"
    @options.environment  or= "development"
    @options.region       or= "localhost"
    @options.kontrolAddress or= 'ws://localhost:4000/dnode'
    #
    @_kodingKey = null

  kodingKey:()->
    if not @_kodingKey
      @_kodingKey = @readKeyFile()
    return @_kodingKey

  readKeyFile: ()->
    kodingKey = fs.readFileSync path.join @basePath, "koding.key"
    kodingKey.toString().replace(/\n$/, '')

  userName: ->@options.username
  hostname: -> os.hostname()
  version: -> @options.versions
  environment: -> @options.environment
  region: -> @options.region
  kontrolAddress: -> @options.kontrolAddress

class Client extends EventEmitter
  constructor: (@options={})->
    @localStore = new Store
    @remoteStore = new Store

    @options.name        or= "application"
    @options.port        or= "1234"
    @options.environment or= new Environment
    @options.api         or= {}

    @environment  = @options.environment
    @kodingKey    = @environment.readKeyFile()
    @uuid         = @options.uuid or generateUUID()

    if @options.host? and @options.port?
      @remoteAddr = "ws://#{@options.host}:#{@options.port}/dnode"
    else
      @remoteAddr = @options.url or @environment.kontrolAddress()

    @api =
      heartbeat: (k)->
        remoteFn = k.withArgs[1]
        setInterval ()->
          remoteFn()
        , 1000

    for k, fn of @options.api
      @api[k] = fn

    for k, fn of @constructor.prototype
      if @constructor.prototype.propertyIsEnumerable(k) and 'function' is typeof this.api[k]
        @api[k] = fn
    delete @api['constructor']

  connect: (callback=noop)->
    @ws = new WebSocket @remoteAddr
    self = this
    @ws.on 'open', ()->
      console.log "connected to ", self.remoteAddr
      self.emit 'connected'
      callback(self)

    @ws.on 'message', (data, flags)->
      # now we descrub message and call our callback function
      scrubbed = JSON.parse data
      scrubber = new Scrubber self.localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
        unless self.remoteStore.has(callbackId)
          self.remoteStore.add callbackId, (args...)->
            self.callRemote callbackId, args

        self.remoteStore.get callbackId

      if self.api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof self.api[scrubbed.method]
        callback = self.api[scrubbed.method]
      else
        callback = self.localStore.get(scrubbed.method)

      if callback
          callback.apply self, unscrubbed

  callRemote: (method, args, authentication, callback=noop)=>
    scrubber = new Scrubber @localStore
    # adding required stuff
    payload = {}
    payload.kite =
      name: @options.name
      username: @environment.userName()
      id: @uuid
      environment: @environment.environment()
      region: @environment.region()
      version: @environment.version() # <--- this should always be a string, dont ask me why, its not an integer
      hostname: @environment.hostname()
      publicIP: "" # <-- we dont have a listening ip/port for a client
      port: @options.port.toString() # <-- port should be string, we dont need a listening ip and port for a client
    payload.withArgs = args
    payload.links = []

    if authentication
      payload.authentication = authentication
    else
      payload.authentication =
        type: "kodingKey",
        key: @kodingKey

    scrubber.scrub [payload, callback], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      message = JSON.stringify scrubbed
      console.log "sending:", message
      @ws.send message

  getKites: (options={}, callback=noop)->
    # these are query options for getKites, not to be confused with
    # environment options
    # we ask, getKites({name: "mathworker", version: "1"}) so it returns all 
    # mathworkers in version 1
    options.environment or= ""
    options.hostname    or= ""
    options.id          or= ""
    options.name        or= ""
    options.region      or= ""
    options.username    or= @environment.userName()
    options.version     or= ""

    @callRemote "getKites",
      options,
      null,
      (err, kites)->
          callback err, kites

class Authenticator
  constructor: ()->
  authenticate: ()->
    return false

class KodingKeyAuthenticator extends Authenticator
  authenticate: (token, kodingKey)->
    token == kodingKey

class TokenAuthenticator extends Authenticator
  authenticate: (token, kodingKey)->
    decryptedToken = decrypt(token, kodingKey)
    if not decryptedToken
      return false
    JSON.parse decryptedToken

authenticators =
  'kodingKey': new KodingKeyAuthenticator
  'token': new TokenAuthenticator

class Request
  constructor: (@options)->
    @method = @options.method
    @args = @options.args
    @localKite = @options.localKite
    @remoteKite = @options.remoteKite
    @username = @options.userName
    @authentication = @options.authentication
    @remoteAddr = @options.remoteAddr

class RequestFilter
  constructor: (@environment)->
  run: (request, next)->
    next null, request

class AuthenticateFilter extends RequestFilter
  run: (request, callback)->
    authenticator = authenticators[request.authentication?.type]
    if not authenticator
      return callback "wrong/unsupported authentication type request", request

    authenticated = authenticator.authenticate(request.authentication.key, @environment.kodingKey())
    if not authenticated
      return callback "couldnt authenticate request", request

    # TODO: check timestamp validuntil
    request.username = authenticated.username

    callback null, request

class RequestFilters
  # this is a simple filter chain,
  # we pass every request to filters,
  # so filters can decide if the request is authenticated,
  # or should be cancelled, and they can modify the request.
  #
  # example:
  #
  # class AuthenticateFilter
  #   run: (request, next)->
  #     request.user = {id:1, name:"foo"}
  #     next(null, request)
  #
  # f = new RequestFilters [new SomeFilter, new AnotherFilter, new AuthenticateFilter]
  # f.runFilters {}, (err, request)->
  #    console.log "#{err} - #{request}"
  #
  constructor: (filters)->
    @filters = []
    if filters
      @addFilters filters

  addFilters: (filters)->
    @filters.push filters...

  addFilter: (filter)->
    @filters.push filter

  runFilters: (request, callback)->
    cnt = 0
    self = this
    next = (err, request)->
      if err
        return callback err, request
      cnt++
      if self.filters[cnt]?
        self.filters[cnt].run request, next
      else
        callback null, request
    @filters[0].run request, next

class Worker extends EventEmitter
  constructor: ()->
    @kiteName = @constructor.kiteName
    @username = @constructor.username
    throw "every worker needs a name" if not @kiteName? and not @kiteName
    @localStore = new Store
    @remoteStore = new Store
    @environment = new Environment username: @username
    @requestFilters = new RequestFilters [new AuthenticateFilter(@environment)]

  callRemote: (client, method, args)=>
    scrubber = new Scrubber @localStore
    # adding required stuff
    payload = args
    scrubber.scrub payload, =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      message = JSON.stringify scrubbed
      client.send message

  runServer: (@host="localhost", @port=9999)->
    worker = this
    @wss = new WebSocketServer host:@host, port: @port
    @kontrolClient = new Client name:@kiteName, port: @port, environment: @environment
    @kontrolClient.on 'connected', ()=>
      console.log "connecting to kontrol"
      @kontrolClient.callRemote "register", null, null, (err, data)->
        console.log "received data", data
    @kontrolClient.connect()

    @wss.on 'connection', (client)->
      client.on 'message', (data)->
        console.log('received: %s', data)
        scrubbed = JSON.parse data
        scrubber = new Scrubber worker.localStore
        unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
          unless worker.remoteStore.has(callbackId)
            worker.remoteStore.add callbackId, (args...)->
              worker.callRemote client, callbackId, args
          worker.remoteStore.get callbackId

        if worker.constructor.prototype.propertyIsEnumerable(scrubbed.method) and 'function' is typeof worker[scrubbed.method]
          callback = worker[scrubbed.method]
        else
          callback = worker.localStore.get(scrubbed.method)

        clientCallback = unscrubbed[1]

        options =
          localKite: worker,
          remoteKite: client, # <-- this is subject to change
          method: scrubbed.method,
          args: unscrubbed[0].withArgs,
          username: null, # <-- this will be added by authentication filter
          authentication: unscrubbed[0].authentication
        request = new Request options

        worker.requestFilters.runFilters request, (err, request)->
          return clientCallback err, null if err

          if callback
            callback request, runWithTimeout(worker, 2, clientCallback)

module.exports.Worker = Worker
module.exports.Client = Client