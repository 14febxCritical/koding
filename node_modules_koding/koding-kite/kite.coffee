fs                = require 'fs'
os                = require 'os'
path              = require 'path'
uuid              = require 'node-uuid'
crypto            = require "crypto"
WebSocket         = require 'ws'
WebSocketServer   = require('ws').Server
{env}             = process
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Environment       = require './environment'
{Kontrol}         = require './remote'
uuid              = require 'node-uuid'
{Request, RequestFilter, RequestFilters, AuthenticateFilter} = require './request'
{KiteError}       = require './errors'
{decrypt, getArgNames} = require './utils'

log4js = require 'log4js'
logger = log4js.getLogger()

noop = ()->

class Authenticator
  constructor: ()->
  authenticate: (token, kodingKey, session)->
    return false

class KodingKeyAuthenticator extends Authenticator
  authenticate: (token, kodingKey, session)->
    return token is kodingKey

class TokenAuthenticator extends Authenticator
  authenticate: (token, kodingKey, session)->
    decryptedToken = decrypt(token, kodingKey)
    if not decryptedToken
      return false
    session.token = JSON.parse decryptedToken
    return true

class KiteConnectionWrapper extends EventEmitter
  constructor: (@client, @worker)->
  Go: (method, args, callback=noop)=>
    scrubber = new Scrubber @worker.localStore
    # adding required stuff
    payload = {}
    payload.kite =
      name: @worker.kitename
      username: @worker.environment.userName()
      id: @worker.uuid
      environment: @worker.environment.environment()
      region: @worker.environment.region()
      version: @worker.environment.version()
      hostname: @worker.environment.hostname()
      publicIP: ""
      port: @worker.port.toString()
    payload.withArgs = args
    payload.authentication =
      type: "kodingKey",
      key: @worker.environment.kodingKey()

    scrubber.scrub [payload, callback], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      logger.debug "sending to connected client: #{JSON.stringify scrubbed}"
      @client.send JSON.stringify scrubbed

class Options
  constructor: (options)->
    @Username     = options.Username
    @Kitename     = options.Kitename
    @LocalIP      = options.LocalIP
    @PublicIP     = options.PublicIP
    @Environment  = options.Environment
    @Region       = options.Region
    @Port         = options.Port
    @Version      = options.Version
    @KontrolAddr  = options.KontrolAddr
    @Dependencies = options.Dependencies

class Kite extends EventEmitter
  # Kite takes kite.Options struct
  constructor: (@options)->
    @kiteName       = @options.Kitename
    @username       = @options.Username
    @localStore     = new Store
    @remoteStore    = new Store
    @environment    = options.environment or new Environment username: @username
    @authenticators =
      'kodingKey': new KodingKeyAuthenticator
      'token'    : new TokenAuthenticator
    @requestFilters = new RequestFilters [new AuthenticateFilter(this)]
    @uuid           = uuid.v4()
    @api            = {}
    @host           = @options.PublicIP
    @port           = @options.Port

  Call: (client, method, args, callback=noop)=>
    scrubber = new Scrubber @localStore
    # adding required stuff
    options = {}
    options.kite =
      id: @uuid
      name: @options.Name
      username: @environment.userName()
      environment: @environment.environment()
      region: @options.Region
      version: @options.Version
      hostname: @environment.hostname()
      publicIP: @options.PublicIP
      port: @port.toString()
    options.withArgs = args
    options.authentication = @authentication
    scrubber.scrub [options, callback], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      logger.debug "sending #{JSON.stringify scrubbed}"
      client.send JSON.stringify(scrubbed), (err)->
        if err
          logger.debug "error while sending data", err

  HandleFunc: (name, func)->
    argList = getArgNames func
    # depending on the parameter list of the function
    # we decide if its written in sync fashion, or async
    # style, then wrap it in async way
    if argList.length is 1
      @api[name] = func.async()
    else
      @api[name] = func

  Run: ()->
    @Start()

  Start: (callback=noop)->
    worker = this

    @Kontrol = new Kontrol name: @kiteName, port: @port, environment: @environment
    @Kontrol.on 'connected', ()=>
      @Kontrol.Call "register", null, (request)->
        [err, data] = request.Args
        logger.error "Cannot register to Kontrol", err
      callback.apply this

    @ws = new WebSocketServer host: @options.LocalIP, port: @options.Port
    @ws.on 'connection', (client)=>
      client.remoteStore = new Store
      client.on 'message', (data)=>
        scrubbed = JSON.parse data
        scrubber = new Scrubber worker.localStore
        unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
          unless client.remoteStore.has(callbackId)
            client.remoteStore.add callbackId, (args...)->
              worker.Call client, callbackId, args
          return client.remoteStore.get callbackId

        if worker.api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof worker.api[scrubbed.method]
          callback = worker.api[scrubbed.method]
        else
          # this is a client tell callback
          callback = worker.localStore.get(scrubbed.method)
          callback.apply unscrubbed
          # we dont have anything else to do here
          return

        clientCallback = unscrubbed[1]

        options =
          LocalKite: worker,
          RemoteKite: new KiteConnectionWrapper(client, worker),
          Method: scrubbed.method,
          Args: unscrubbed[0].withArgs,
          Username: null, # <-- this will be added by authentication filter
          Authentication: unscrubbed[0].authentication
        request = new Request options

        worker.requestFilters.runFilters request, (err, request)->
          return clientCallback err, null if err

          if callback
            callback request, clientCallback

module.exports.RequestFilter  = RequestFilter
module.exports.RequestFilters = RequestFilters
module.exports.Kite           = Kite

kite = {}
kite.Options = Options
kite.Kite    = Kite
module.exports.kite = kite