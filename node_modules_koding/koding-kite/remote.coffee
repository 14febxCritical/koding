{env}             = process
uuid              = require 'node-uuid'
WebSocket         = require 'ws'
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Environment       = require './environment'
{Request, RequestFilter, RequestFilters, AuthenticateFilter} = require './request'
{decrypt} = require './utils'
Sync      = require 'sync'

log4js = require 'log4js'
logger = log4js.getLogger()


noop = ->

sync = (fn)->
  Sync fn


# KontrolQuery is a structure of message sent to Kontrol. It is used for
# querying kites based on the incoming field parameters. Missing fields are
# not counted during the query (for example if the "version" field is empty,
# any kite with different version is going to be matched).
# Order of the fields is from general to specific.
class KontrolQuery
  constructor: (options)->
    @Username    = options.Username    or ""
    @Environment = options.Environment or ""
    @Name        = options.Name        or ""
    @Version     = options.Version     or ""
    @Region      = options.Region      or ""
    @Hostname    = options.Hostname    or ""
    @ID          = options.ID          or ""

  toDict: ()->
    keys = ['Username', 'Environment', 'Name', 'Version', 'Region', 'Hostname', 'ID']
    r = {}
    r[k.toLowerCase()] = this[k] for k in keys
    r


class RemoteKite extends EventEmitter
  constructor: (@options={})->
    @localStore = new Store
    @remoteStore = new Store

    @options.name        or= "application"
    @options.port        or= ""
    @options.environment or= new Environment
    @options.api         or= {}

    @environment    = @options.environment
    @kodingKey      = @environment.readKeyFile()
    @uuid           = @options.uuid or uuid.v4()
    @authentication = @options.authentication or type: "kodingKey", key: @kodingKey

    if @options.publicIP? and @options.port?
      @remoteAddr = "ws://#{@options.publicIP}:#{@options.port}/dnode"
    else
      @remoteAddr = @environment.kontrolAddress()

    if @constructor.name isnt 'Kontrol'
      @kontrol = new Kontrol environment: @environment, ->

    @api = {}

    @handleFunc "heartbeat", (request)->
      [interval, heartbeatCallback] = request.Args
      setInterval ()->
        heartbeatCallback()
      , interval * 1000

    @handleFunc "log", (request)->
      logger.info ">>> ", request.Args

  handleFunc: (name, func)->
    @api[name] = func

  Dial: (callback=null)->
    self = this
    doSync = (scope, fn, args...)->
      args.pop()
      return fn.sync scope, args...

    if callback is null
      return doSync self, @Dial_, arguments
    else
      @Dial_ callback

  onMessage: (data, flags)=>
    # now we descrub message and call our callback function
    logger.debug "received: ", data
    scrubbed = JSON.parse data
    scrubber = new Scrubber this.localStore
    unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
      unless @remoteStore.has(callbackId)
        @remoteStore.add callbackId, (args...)->
          @Call callbackId, args

      @remoteStore.get callbackId

    syncCallback = false

    if @api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof @api[scrubbed.method]
      callback = @api[scrubbed.method]
    else
      callback = @localStore.get(scrubbed.method)
      ourCallback = @localStore.items[scrubbed.method]
      syncCallback = ourCallback.isSync? and ourCallback.isSync

    if callback
        options =
          LocalKite: null,
          RemoteKite: this,
          Method: scrubbed.method,
          Args: unscrubbed[0].withArgs,
          Username: null,
          Authentication: null
        request = new Request options
        if syncCallback
          callback null, [request, request.Args[0]]
        else
          callback.apply this, [request]
    else
      logger.warn "couldnt find callback for message", data

  Dial_: (callback)->
    @ws = new WebSocket @remoteAddr
    @ws.on 'open', ()=>
      callback null
    @ws.on 'message', @onMessage

  Call: (method, args, callback=null)=>
    # this decides if we want sync call or async call style
    if callback is null
      # this is a sync remote call...
      self = this
      fn = (method, args, callback)->
        callback.isSync = true
        self.Call_ method, args, callback
      o = fn.sync self, method, args
      return o
    else
      # we are in async fashion, calling Call as usual
      @Call_ method, args, callback

  Call_: (method, args, callback=noop)=>
    work = ()=>
      scrubber = new Scrubber @localStore
      # adding required stuff
      options = {}
      options.kite =
        Id: @uuid
        Name: @options.name
        Username: @environment.userName()
        Environment: @environment.environment()
        Region: @environment.region()
        Version: @environment.version()
        Hostname: @environment.hostname()
        PublicIP: "" # <-- we dont have a listening ip/port for a client
        Port: @options.port.toString() # <-- port should be string, we dont need a listening ip and port for a client
      options.withArgs = args
      options.authentication = @authentication

      scrubber.scrub [options, callback], =>
        scrubbed = scrubber.toDnodeProtocol()
        scrubbed.method = method
        logger.debug "sending to: ", @remoteAddr
        logger.debug "sending #{JSON.stringify scrubbed}"
        @ws.send JSON.stringify(scrubbed), (err)->
          if err
            logger.error "error while sending data", err

    if @authentication.type is "token"
      # TODO: no need to revalidate in every request
      decryptedToken = JSON.parse decrypt(@authentication.key, @environment.kodingKey())
      validUntil = new Date(decryptedToken.validUntil)
      now = new Date
      tokenTtl = (validUntil - new Date(now)) - 2000
      if tokenTtl < 0
        @kontrol.getToken @options.remoteKiteData, (err, token)=>
            @authentication = type: 'token', key: token
            work()
      else
        work()
    else
      work()

class Kontrol extends RemoteKite
  constructor: (@options, callback)->
    super
    @Dial callback

  getToken: (options, callback)->
    @Call "getToken", options, (request)->
      [err, token] = request.Args
      callback err, token

  # GetKites returns the list of Kites matching the query.
  # The returned list contains ready to connect RemoteKite instances.
  # The caller must connect with RemoteKite.Dial() before using each Kite.
  GetKites: (query, eventListener, callback=null)->
    # is this a sync callback
    if callback is null
      fn = (q, e, kallback)=>
        @GetKites_ query, eventListener, (err, kites)->
          kallback null, [err, kites]
      return fn.sync this, query, eventListener
    else
      @GetKites_ query, eventListener, callback

  GetKites_: (query, eventListener, callback)->
    listener = if eventListener.listener? then eventListener else eventListener
    @Call "getKites",
      [query.toDict(), listener],
      (request)->
        [err, kites] = request.Args
        clients = []
        for kite in kites
          kiteOptions =
            remoteKiteData: kite.kite
            environment: @environment
            publicIP: kite.kite.publicIP
            port: kite.kite.port
            authentication:
              type: 'token'
              key: kite.token
          clients.push new RemoteKite kiteOptions
        callback err, clients

class KiteEventListener extends EventEmitter
  listener: (request)=>
    [event] = request.Args
    @emit event.action, event.kite

module.exports.RemoteKite  = RemoteKite
module.exports.Kontrol     = Kontrol
module.exports.KiteEventListener = KiteEventListener
module.exports.KontrolQuery = KontrolQuery
module.exports.sync = sync