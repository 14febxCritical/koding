{env}             = process
uuid              = require 'node-uuid'
WebSocket         = require 'ws'
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Settings       = require './settings'
{Request, RequestFilter, RequestFilters, AuthenticateFilter} = require './request'
{decrypt} = require './utils'
Sync      = require 'sync'

log4js = require 'log4js'
logger = log4js.getLogger()


noop = ->

sync = (fn)->
  Sync fn

doSync = (scope, fn, args...)->
  if typeof(args) is 'object'
    args = (arg for k, arg of args)
  args.pop()
  return fn.sync scope, args...

# KontrolQuery is a structure of message sent to Kontrol. It is used for
# querying kites based on the incoming field parameters. Missing fields are
# not counted during the query (for example if the "version" field is empty,
# any kite with different version is going to be matched).
# Order of the fields is from general to specific.
class KontrolQuery
  constructor: (options)->
    @username    = options.username    or ""
    @environment = options.environment or ""
    @name        = options.name        or ""
    @version     = options.version     or ""
    @region      = options.region      or ""
    @hostname    = options.hostname    or ""
    @id          = options.id          or ""

  toDict: ()->
    keys = ['username', 'environment', 'name', 'version', 'region', 'hostname', 'id']
    r = {}
    r[k.toLowerCase()] = this[k] for k in keys
    r


class RemoteKite extends EventEmitter
  constructor: (@localKite, @properties, @authentication)->
    @localStore = new Store
    @remoteStore = new Store

    @api = {}

    # TODO do not add handlers here, copy handlers from local Kite.

    @handleFunc "heartbeat", (request, callback)->
      [interval, heartbeatCallback] = request.args
      setInterval ()->
        heartbeatCallback()
      , interval * 1000
      callback({result: null, error: null})

    @handleFunc "log", (request)->
      logger.info ">>> ", request.args

  handleFunc: (name, func)->
    @api[name] = func

  dial: (callback=null)=>
    if callback is null
      return doSync this, @dial_, arguments
    else
      @dial_ callback

  onMessage: (data, flags)=>
    # now we descrub message and call our callback function
    logger.debug "received: ", data
    scrubbed = JSON.parse data
    scrubber = new Scrubber this.localStore
    unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
      unless @remoteStore.has(callbackId)
        @remoteStore.add callbackId, (args...)=>
          @tell callbackId, args, ->

      @remoteStore.get callbackId

    syncCallback = false

    if @api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof @api[scrubbed.method]
      callback = @api[scrubbed.method]
    else
      callback = @localStore.get(scrubbed.method)
      ourCallback = @localStore.items[scrubbed.method]
      syncCallback = ourCallback.isSync? and ourCallback.isSync

    if callback
        options =
          localKite: null,
          remoteKite: this,
          method: scrubbed.method,
          args: unscrubbed[0].withArgs,
          username: null,
          authentication: null
        request = new Request options
        if syncCallback
          callback null, [request, request.args[0]]
        else
          callback.apply this, [request, unscrubbed[0].responseCallback]
    else
      logger.warn "couldnt find callback for message", data

  dial_: (callback)->
    @ws = new WebSocket @properties.url, null, {ca: [kontrolCert]}
    @ws.on 'open', ()=>
      callback null
    @ws.on 'message', @onMessage

  tell: (method, args, callback=null)=>
    # this decides if we want sync call or async tell style
    if callback is null
      # this is a sync remote call...
      fn = (method, args, callback)=>
        callback.isSync = true
        @tell_ method, args, callback
      return fn.sync this, method, args
    else
      # we are in async fashion, calling tell as usual
      @tell_ method, args, callback

  tell_: (method, args, callback=noop)=>
    work = ()=>
      scrubber = new Scrubber @localStore
      # adding required stuff
      options = {}
      options.kite = @localKite.getProperties()
      options.withArgs = args or []
      options.authentication = @authentication
      options.responseCallback = callback

      scrubber.scrub [options], =>
        scrubbed = scrubber.toDnodeProtocol()
        scrubbed.method = method
        logger.debug "sending to: ", @properties.url
        logger.debug "sending #{JSON.stringify scrubbed}"
        @ws.send JSON.stringify(scrubbed), (err)->
          if err
            logger.error "error while sending data", err

    if @authentication.type is "token"
      # TODO: no need to revalidate in every request
      now = new Date
      tokenTtl = (@authentication.validUntil - new Date(now)) - 2000
      if tokenTtl < 0
        @kontrol.getToken @options.remoteKiteData, (err, token)=>
            @authentication = type: 'token', key: token
            work()
      else
        work()
    else
      work()

class Kontrol extends RemoteKite
  constructor: (@localKite, @properties, callback)->
    super
    @authentication = {type: "kodingKey", key: @localKite.settings.kodingKey()}
    @dial callback

  getToken: (options, callback)->
    @tell "getToken", options, (request)->
      [err, token] = request.args
      callback err, token

  watchKites: (query, eventListener)->
    listener = if eventListener.listener? then eventListener else eventListener
    @tell 'watchKites', [query.toDict(), listener], (request)->
      console.error "watchKites", request

  getKites: (query, callback=null)->
    # is this a sync callback
    if callback is null
      fn = (q, kallback)=>
        @getKites_ query, (err, kites)->
          kallback null, [err, kites]
      return fn.sync this, query
    else
      @getKites_ query, callback

  getKites_: (query, callback)->
    console.error query.toDict()
    @tell "getKites",
      [query.toDict()],
      (request)->
        [err, kites] = request.args
        clients = []
        for kite in kites
          kiteOptions =
            remoteKiteData: kite.kite
            settings: @settings
            publicIP: kite.kite.publicIP
            port: kite.kite.port
            authentication:
              type: 'token'
              key: kite.token.Key
              ttl: kite.token.TTL
              validUntil: new Date(new Date().getTime() + (kite.token.TTL * 1000))
          clients.push new RemoteKite kiteOptions
        callback err, clients

class KiteEventListener extends EventEmitter
  listener: (request)=>
    [event] = request.args
    @emit event.action, event.kite

kontrolCert = """-----BEGIN CERTIFICATE-----
MIIC5DCCAc6gAwIBAgIBADALBgkqhkiG9w0BAQUwEjEQMA4GA1UEChMHQWNtZSBD
bzAeFw0xMzEyMTcxODU5MjJaFw0xNDEyMTcxODU5MjJaMBIxEDAOBgNVBAoTB0Fj
bWUgQ28wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCv6x+uIq+gV3Lp
9T9dc+9toplAfbTSo4oo529G5uIwNFwdo83WSq9F2AnBuILaVEhZS4pFGQRmC+vo
z4uDtnOvkIn2BBhb/790nlzqZSmJcAI1Z74REbVGKdhEejNyrRl+Ra3vI4GKhiOQ
l8+Eda8NMADToIUBx5PC0899j5x5NaaC3lecp4hUcyhYWS20BbPwI3JixQaNtrOs
3jUEVi3fndpijpfOjrSENZPeMs9qtg3MLz8NqJmWidh33Z28CLy9qWAsLgzIKONw
FKS8S+IhaYf+EoPcff8QR4U0Yzr7Be4amCzEaYH3z3MytEIvtjxRo/3/3ScY+93g
IR5khDrRAgMBAAGjSTBHMA4GA1UdDwEB/wQEAwIApDATBgNVHSUEDDAKBggrBgEF
BQcDATAPBgNVHRMBAf8EBTADAQH/MA8GA1UdEQQIMAaHBH8AAAEwCwYJKoZIhvcN
AQEFA4IBAQAKNlyqaD5HJc2Z9C1oibJdy8Fic4F+LN91bI5vzS4wAuuT/Ytgnkjc
ugaVYyma3UW9+F7lycFEYW5mBLE4WQHpxgTOV3lUVbmgd62IiqIaya9umCul2w0/
ET24WErJJcnP3Pj3Dr7sx3fNbCJccRM05c1fHs4JwJNbI8TmpvELbx99TeeT/oBd
7AkFuPzPqa22C2AmV826Op9tFYAcXWcYTG9ghMAjLK0U2kN8Fn2PWwrSn1MOkYuK
POOyJIW7jTair0QA1NdmDVTv/fYnfjHwQ120nmBX/D3wkcvNk+bQfPgMe/wIV/hW
9kJJ3SAuqhiFskJ54sHq2LZK38zX4hm2
-----END CERTIFICATE-----"""

module.exports.RemoteKite  = RemoteKite
module.exports.Kontrol     = Kontrol
module.exports.KiteEventListener = KiteEventListener
module.exports.KontrolQuery = KontrolQuery
module.exports.sync = sync
