crypto            = require "crypto"
{KiteError} = require './errors'

urlSafeBase64decode = (encodedData)->
  new Buffer(encodedData.replace(/\-/g, '+').replace(/_/g, '/'), 'base64')

sha256 = (data)->
  shasum = crypto.createHash 'sha256'
  shasum.update(data)
  shasum.digest 'binary'

decrypt = (encodedToken, kodingKey)->
  decodedToken = urlSafeBase64decode encodedToken
  iv = new Buffer decodedToken.slice(0, 16)
  kodingKey = sha256 urlSafeBase64decode kodingKey
  ciphertext = decodedToken.slice(16, decodedToken.length)
  # Decipher encrypted data
  decipher  = crypto.createDecipheriv 'aes-256-cfb', kodingKey, iv
  decrypted = decipher.update(ciphertext, 'binary') + decipher.final('binary')
  new Buffer(decrypted, 'binary').toString('utf8');

runWithTimeout = (scope, timeout, fn)->
  # if fn is not called within spesified time,
  # calls fn with err
  # timeout is in seconds
  isFnCalled = false
  t = setTimeout ()->
    if not isFnCalled
      fn new KiteError("Kite worker didnt return in time"), null
      isFnCalled = true
  , timeout * 1000
  return (args...)->
    clearTimeout t
    isFnCalled = true
    fn.apply scope, args

getArgNames = (fn)->
  # give a function, it will return its argument list as array
  # f = (foo, bar)->
  # getArgNames(f) # returns ["foo", "bar"]
  r = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg
  s = fn.toString().replace(r, '')
  result = s.slice(s.indexOf('(')+1, s.indexOf(')')).match(/([^\s,]+)/g)
  return if not result?
  result

module.exports.getArgNames = getArgNames
module.exports.decrypt = decrypt
module.exports.runWithTimeout = runWithTimeout