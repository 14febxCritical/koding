uuid              = require 'node-uuid'
WebSocket         = require 'ws'
{env}             = process
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Environment       = require './environment'
{Request, RequestFilter, RequestFilters, AuthenticateFilter} = require './request'
{decrypt} = require './utils'

noop = ->

module.exports = class Client extends EventEmitter
  constructor: (@options={})->
    @localStore = new Store
    @remoteStore = new Store

    @options.name        or= "application"
    @options.port        or= ""
    @options.environment or= new Environment
    @options.api         or= {}

    console.log "options", @options

    @environment    = @options.environment
    @kodingKey      = @environment.readKeyFile()
    @uuid           = @options.uuid or uuid.v4()
    @authentication = @options.authentication or type: "kodingKey", key: @kodingKey

    if @options.host? and @options.port?
      @remoteAddr = "ws://#{@options.host}:#{@options.port}/dnode"
    else
      @remoteAddr = @options.url or @environment.kontrolAddress()

    @api = {}

    @handleFunc "heartbeat", (request)->
      [interval, heartbeatCallback] = request.args
      setInterval ()->
        heartbeatCallback()
      , interval * 1000

    @handleFunc "log", (request)->
      console.log ">>> ", request.args

  handleFunc: (name, func)->
    @api[name] = func

  connect: (callback=noop)->
    @ws = new WebSocket @remoteAddr
    client = this
    @ws.on 'open', ()->
      client.emit 'connected'
      callback client

    @ws.on 'message', (data, flags)->
      # now we descrub message and call our callback function
      console.log "received: ", data
      scrubbed = JSON.parse data
      scrubber = new Scrubber client.localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
        unless client.remoteStore.has(callbackId)
          client.remoteStore.add callbackId, (args...)->
            client.callRemote callbackId, args

        client.remoteStore.get callbackId

      if client.api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof client.api[scrubbed.method]
        callback = client.api[scrubbed.method]
      else
        callback = client.localStore.get(scrubbed.method)

      if callback
          args = if Array.isArray(unscrubbed) and unscrubbed[0]?.withArgs? then unscrubbed[0].withArgs else unscrubbed
          options =
            localKite: null,
            remoteKite: client,
            method: scrubbed.method,
            args: args,
            username: null, # <-- this will be added by authentication filter
            authentication: null # <-- this doesnt work right now, waiting for change on go side
          request = new Request options
          callback.apply client, [request]

  callRemote: (method, args, callback=noop)=>
    console.log "authentication ", @authentication
    if @authentication.type is "token"
      # TODO: no need to revalidate in every request
      console.log @authentication.key
      decryptedToken = JSON.parse decrypt(@authentication.key, @environment.kodingKey())
      console.log ">>>>>>>>>>>>> ", decryptedToken.validUntil
      validUntil = new Date(decryptedToken.validUntil)
      now = new Date
      if validUntil < now
        console.log ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> token is not valid...."
        kontrol = new Client environment: @environment
        kontrol.on 'connected', ()=>
          console.log ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> connected to kontrol !!!!"
          console.log @options.remoteKiteData
          kontrol.getToken(@options.remoteKiteData)
        kontrol.connect()

      console.log "-------- // -------------------------"
      console.log decryptedToken
      console.log "// ----"
    scrubber = new Scrubber @localStore
    # adding required stuff
    options = {}
    options.kite =
      id: @uuid
      name: @options.name
      username: @environment.userName()
      environment: @environment.environment()
      region: @environment.region()
      version: @environment.version()
      hostname: @environment.hostname()
      publicIP: "" # <-- we dont have a listening ip/port for a client
      port: @options.port.toString() # <-- port should be string, we dont need a listening ip and port for a client
    options.withArgs = args
    options.authentication = @authentication

    scrubber.scrub [options, callback], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      console.log "sending #{JSON.stringify scrubbed}"
      @ws.send JSON.stringify(scrubbed), (err)->
        if err
          console.log "error while sending data", err

  getToken: (options)->
    console.log ">>>>>>>>>>>>>>>>> get token called ", options
    # options =
    #   # name: "application"
    #   # version: "0.0.1"
    #   # region: "localhost"
    #   id: @uuid
    #   name: "mathworker" # @options.name
    #   username: @environment.userName()
    #   environment: @environment.environment()
    #   region: @environment.region()
    #   version: @environment.version()
    #   hostname: @environment.hostname()
    #   username: @environment.userName()
    #   environment: @environment.environment()
    @callRemote "getToken", options, (request)->
      console.log ".... get token replied ...."
      console.log request.args

  getKites: (query={}, callback=noop)->
    # these are query options for getKites, not to be confused with
    # environment options
    # we ask, getKites({name: "mathworker", version: "1"}) so it returns all
    # mathworkers in version 1
    query.environment or= @environment.environment()
    query.hostname    or= ""
    query.id          or= ""
    query.name        or= ""
    query.region      or= ""
    query.username    or= @environment.userName()
    query.version     or= ""

    @callRemote "getKites",
      [query, ()->],
      (request)->
        [err, kites] = request.args
        clients = []
        for kite in request.args[1]
          console.log "------------- kite ----------"
          console.log kite
          console.log "------------- kite ----------"
          kiteOptions =
            remoteKiteData: kite.kite
            environment: @environment
            host: kite.kite.publicIP
            port: kite.kite.port
            authentication:
              type: 'token'
              key: kite.token
          clients.push new Client kiteOptions
          callback err, clients
