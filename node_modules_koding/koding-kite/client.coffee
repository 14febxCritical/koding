uuid              = require 'node-uuid'
WebSocket         = require 'ws'
{env}             = process
{EventEmitter}    = require 'events'
{Scrubber, Store} = require 'koding-dnode-protocol'
Environment       = require './environment'

noop = ->

module.exports = class Client extends EventEmitter
  constructor: (@options={})->
    @localStore = new Store
    @remoteStore = new Store

    @options.name        or= "application"
    @options.port        or= ""
    @options.environment or= new Environment
    @options.api         or= {}

    @environment    = @options.environment
    @kodingKey      = @environment.readKeyFile()
    @uuid           = @options.uuid or uuid.v4()
    @authentication = @options.authentication or type: "kodingKey", key: @kodingKey

    if @options.host? and @options.port?
      @remoteAddr = "ws://#{@options.host}:#{@options.port}/dnode"
    else
      @remoteAddr = @options.url or @environment.kontrolAddress()

    @api =
      heartbeat: (k)->
        remoteFn = k.withArgs[1]
        setInterval ()->
          remoteFn()
        , 1000

    for k, fn of @options.api
      @api[k] = fn

    for k, fn of @constructor.prototype
      if @constructor.prototype.propertyIsEnumerable(k) and 'function' is typeof this.api[k]
        @api[k] = fn
    delete @api['constructor']

  connect: (callback=noop)->
    @ws = new WebSocket @remoteAddr
    self = this
    @ws.on 'open', ()->
      console.log "connected to ", self.remoteAddr
      self.emit 'connected'
      callback(self)

    @ws.on 'message', (data, flags)->
      # now we descrub message and call our callback function
      scrubbed = JSON.parse data
      scrubber = new Scrubber self.localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)->
        unless self.remoteStore.has(callbackId)
          self.remoteStore.add callbackId, (args...)->
            self.callRemote callbackId, args

        self.remoteStore.get callbackId

      if self.api.propertyIsEnumerable(scrubbed.method) and 'function' is typeof self.api[scrubbed.method]
        callback = self.api[scrubbed.method]
      else
        callback = self.localStore.get(scrubbed.method)

      if callback
          callback.apply self, unscrubbed

  callRemote: (method, args, callback=noop)=>
    scrubber = new Scrubber @localStore
    # adding required stuff
    options = {}
    options.kite =
      name: @options.name
      username: @environment.userName()
      id: @uuid
      environment: @environment.environment()
      region: @environment.region()
      version: @environment.version() # <--- this should always be a string, dont ask me why, its not an integer
      hostname: @environment.hostname()
      publicIP: "" # <-- we dont have a listening ip/port for a client
      port: @options.port.toString() # <-- port should be string, we dont need a listening ip and port for a client
    options.withArgs = args
    options.authentication = @authentication

    scrubber.scrub [options, callback], =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method = method
      message = JSON.stringify scrubbed
      console.log "sending:", message
      @ws.send message

  getKites: (query={}, options={}, callback=noop)->
    # these are query options for getKites, not to be confused with
    # environment options
    # we ask, getKites({name: "mathworker", version: "1"}) so it returns all 
    # mathworkers in version 1
    query.environment or= @environment.environment()
    query.hostname    or= ""
    query.id          or= ""
    query.name        or= ""
    query.region      or= ""
    query.username    or= @environment.userName()
    query.version     or= ""

    kiteClass = options.kiteClass or Client

    @callRemote "getKites",
      [query, ()->],
      (err, kites)->
          throw "getKites error: #{err}" if err
          clients = []
          for kite in kites
            kiteOptions =
              environment: @environment
              host: kite.kite.publicIP
              port: kite.kite.port
              authentication:
                type: 'token'
                key: kite.token
            clients.push new kiteClass kiteOptions
            callback err, clients