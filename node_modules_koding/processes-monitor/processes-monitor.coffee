getRandomInt = (min, max) ->
    return Math.floor(Math.random() * (max - min + 1)) + min

getRandom3DigitPrime = ->
  primes = [127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229]
  return primes[getRandomInt(0,primes.length-1)]

module.exports =
  start : (options) ->
    {interval,name} = options

    unless process.send
      console.log "[#{name.toUpperCase()}][WARN] Process is not forked, parent communication will not be possible."
    else
      process.send?({name :name, alive: yes})

    setInterval ->
      # communicating to parent supervisor
      data =
        "process-monitor" : yes
        name   : name
        mem    :
          rss       : Math.floor((process.memoryUsage().rss)/(1024*1024))
          heapTotal : Math.floor((process.memoryUsage().heapTotal)/(1024*1024))
          heapUsed  : Math.floor((process.memoryUsage().heapUsed)/(1024*1024))
          unit      : 'MB'
        uptime : process.uptime()

      process.send? data

      if options.limit_hard?.memory < data.mem.rss
        options.limit_hard.callback name, "Exceeded hard memory limit", data

      if options.limit_soft?.memory < data.mem.rss
        options.limit_soft.callback name, "Exceeded soft memory limit", data

      # Send memory usage to librato
      if options.librato?.push
        os = require "os"

        # Post to Librato
        librato = require("librato-metrics").createClient(
          email: options.librato.email
          token: options.librato.token
        )
        data = gauges: [
          name: 'memory'
          source: options.stats_id + ':' + os.hostname()
          value: data.mem.rss
        ]
        librato.post '/metrics', data, (err, response) ->
          if err
            console.log "Librato - Can't push stats: " + err

      if options.die?.after
        if "string" is typeof options.die.after
          a = getRandom3DigitPrime()
          options.die.after = (a*1000)*60
          console.log "[PROCESS-MONITOR][#{name}] is assigned a non-overlapping lifetime. (#{a} mins)"
        setTimeout ->
          if "function" is typeof options.die.middleware
            if options.die.middlewareTimeout
              setTimeout ->
                console.log "[PROCESS-MONITOR][#{name}] die.middleware didn't return the callback within #{options.die.middlewareTimeout} it will die now."
                process.exit()
              ,options.die.middlewareTimeout
            options.die.middleware name,(err,res)->

              process.exit()
          else
            process.exit()
        ,options.die.after

      # if options.toobusy
      #   toobusy = require 'toobusy'
      #   setTimeout ->
      #     if toobusy()
      #       options.toobusy.callback name
      #   , options.toobusy.interval ? 10000

    ,interval ? 1000

