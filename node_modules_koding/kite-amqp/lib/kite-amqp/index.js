// Generated by CoffeeScript 1.6.2
var EventEmitter, Kite,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

EventEmitter = require('microemitter').EventEmitter;

module.exports = Kite = (function(_super) {
  var Scrubber, Store, amqp, error, parse, serializableError, stringify, _ref;

  __extends(Kite, _super);

  amqp = require('amqp');

  _ref = require('koding-dnode-protocol'), Scrubber = _ref.Scrubber, Store = _ref.Store;

  parse = JSON.parse, stringify = JSON.stringify;

  Object.defineProperty(Object.prototype, 'throwError', {
    value: function(it) {
      throw it;
    }
  });

  serializableError = function(err) {
    return {
      message: err.message,
      stack: err.stack
    };
  };

  function Kite(kiteName, api, roundRobin) {
    var _ref1;

    this.kiteName = kiteName;
    this.api = api;
    this.roundRobin = roundRobin != null ? roundRobin : false;
    if (!api) {
      _ref1 = [kiteName, api], this.api = _ref1[0], this.kiteName = _ref1[1];
    }
    this.kiteName || (this.kiteName = 'unknown');
    this.localStore = new Store;
    this.remoteStore = new Store;
    this.channels = {};
    this.clients = {};
    this.requesters = {};
  }

  Kite.prototype.handleError = function(routingKey, callbackId, err) {
    if (callbackId == null) {
      callbackId = 'uncaughtException';
    }
    err = serializableError(err);
    return this.fetchBrokerExchange(function(brokerExchange) {
      return brokerExchange.publish(routingKey, stringify({
        "arguments": [err],
        method: callbackId,
        callbacks: {}
      }), {
        contentType: 'application/json'
      });
    });
  };

  Kite.prototype.handleRequest = function(scrubbed, routingKey, _arg) {
    var authenticatedUser, channels, deliveryInfo, headers, requesters,
      _this = this;

    headers = _arg.headers, deliveryInfo = _arg.deliveryInfo;
    channels = this.channels, requesters = this.requesters;
    authenticatedUser = this.clients[routingKey];
    if (scrubbed.method === 'ping') {
      return this.handleResponse(routingKey, 'pong', []);
    }
    return this.unscrubMessage(routingKey, authenticatedUser, scrubbed, function(unscrubbed) {
      var callback, data, method, withArgs, _base, _ref1;

      data = unscrubbed[0], callback = unscrubbed[1];
      if (data != null) {
        if ((_ref1 = data.withArgs) != null) {
          _ref1.username = authenticatedUser;
        }
        method = data.method, withArgs = data.withArgs;
      }
      withArgs || (withArgs = {});
      if (_this.api.propertyIsEnumerable(method) && 'function' === typeof _this.api[method]) {
        withArgs.authenticatedUser = authenticatedUser;
        return typeof (_base = _this.api)[method] === "function" ? _base[method](withArgs, function(err, msg) {
          return _this.handleResponse(routingKey, callback.id, [].slice.call(arguments));
        }) : void 0;
      } else if (callback = _this.localStore.get(scrubbed.method)) {
        return callback.apply(null, unscrubbed);
      } else {
        return _this.handleError(routingKey, callback != null ? callback.id : void 0, {
          message: "No such method! " + method
        });
      }
    });
  };

  Kite.prototype.unscrubMessage = function(routingKey, authenticatedUser, scrubbed, callback) {
    var scrubber, unscrubbed,
      _this = this;

    if (!((scrubbed["arguments"] != null) && (scrubbed.callbacks != null))) {
      return callback([scrubbed, function() {}]);
    } else {
      scrubber = new Scrubber(this.localStore);
      unscrubbed = scrubber.unscrub(scrubbed, function(callbackId) {
        var storeKey;

        storeKey = "" + authenticatedUser + callbackId;
        if (!_this.remoteStore.has(storeKey)) {
          _this.remoteStore.add(storeKey, function() {
            var args;

            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return _this.handleResponse(routingKey, callbackId, args);
          });
        }
        return _this.remoteStore.get(storeKey);
      });
      return callback(unscrubbed);
    }
  };

  Kite.prototype.handleResponse = function(routingKey, callbackId, args) {
    var scrubber,
      _this = this;

    scrubber = new Scrubber(this.localStore);
    return scrubber.scrub(args, function() {
      var out;

      out = scrubber.toDnodeProtocol();
      out.method = callbackId;
      out.pid = process.pid;
      return _this.fetchBrokerExchange(function(brokerExchange) {
        return brokerExchange.publish(routingKey, stringify(out));
      });
    });
  };

  Kite.prototype.handleMessage = function(message, headers, deliveryInfo) {
    var messageData, routingKey;

    routingKey = deliveryInfo.routingKey;
    messageData = ((function() {
      try {
        return parse(message.data);
      } catch (_error) {}
    })()) || message;
    switch (routingKey) {
      case 'auth.join':
        return this.join(messageData);
      case 'auth.leave':
        return this.leave(messageData);
      default:
        if (routingKey in this.clients) {
          return this.handleRequest(messageData, routingKey, {
            headers: headers,
            deliveryInfo: deliveryInfo
          });
        } else {
          return console.log("Unknown routing key: " + routingKey + ".  Dropping message on the floor.");
        }
    }
  };

  Kite.prototype.getKiteId = function() {
    if (this.roundRobin) {
      return "" + (require('os').hostname().replace(/\./g, '_'));
    } else {
      return "" + process.pid + "|" + (require('os').hostname().replace(/\./g, '_'));
    }
  };

  Kite.prototype.getServiceType = function() {
    return "kite-" + this.kiteName;
  };

  Kite.prototype.getRabbitMqResourceName = function() {
    return "" + (this.getServiceType()) + "-" + (this.getKiteId());
  };

  Kite.prototype.getKiteExchangeOptions = function() {
    return {
      type: 'fanout',
      autoDelete: true,
      durable: false
    };
  };

  Kite.prototype.fetchExchange = function(name, options, callback) {
    var exchangeName, readyEvent,
      _this = this;

    exchangeName = "" + name + "Exchange";
    readyEvent = "" + exchangeName + "Ready";
    if (this[exchangeName] === null) {
      return this.once(readyEvent, function() {
        return _this.fetchBrokerExchange(callback);
      });
    } else if (this.brokerExchange == null) {
      this[exchangeName] = null;
      return this.connection.exchange(name, options, function(exchange) {
        _this[exchangeName] = exchange;
        _this.emit(readyEvent);
        return callback(exchange);
      });
    } else {
      return callback(this[exchangeName]);
    }
  };

  Kite.prototype.fetchAuthExchange = function(callback) {
    return this.fetchExchange('auth', {
      noDeclare: true
    }, callback);
  };

  Kite.prototype.fetchBrokerExchange = function(callback) {
    return this.fetchExchange('broker', {
      noDeclare: true
    }, callback);
  };

  Kite.prototype.leave = function(messageData) {
    var routingKey, _base;

    routingKey = messageData.routingKey;
    delete this.clients[routingKey];
    return typeof (_base = this.api)._leave === "function" ? _base._leave(messageJson) : void 0;
  };

  Kite.prototype.join = function(messageData) {
    var routingKey, username, _base;

    console.log('join', {
      messageData: messageData
    });
    username = messageData.username, routingKey = messageData.routingKey;
    this.clients[routingKey] = username;
    if (typeof (_base = this.api)._join === "function") {
      _base._join(messageJson);
    }
    return this.handleResponse(routingKey, 'ready', [this.getRabbitMqResourceName()]);
  };

  error = function() {
    throw arguments[0];
  };

  Kite.prototype.createPresenceMemberKey = function() {
    var serviceGenericName, serviceUniqueName;

    serviceGenericName = this.getServiceType();
    serviceUniqueName = this.getRabbitMqResourceName();
    return "serviceType.kite.serviceGenericName." + serviceGenericName + ".serviceUniqueName." + serviceUniqueName;
  };

  Kite.prototype.establishPresence = function() {
    var Presence;

    Presence = require('koding-rabbit-presence');
    this.presence = new Presence({
      connection: this.connection,
      exchange: 'services-presence',
      member: this.createPresenceMemberKey()
    });
    return this.presence.announce();
  };

  Kite.prototype.registerSelf = function() {
    var config, heartbeat, host, login, options, password, port, protocol, rabbitMqResourceName, vhost, _ref1,
      _this = this;

    config = this.config;
    _ref1 = config.amqp, host = _ref1.host, port = _ref1.port, protocol = _ref1.protocol, login = _ref1.login, password = _ref1.password, vhost = _ref1.vhost, heartbeat = _ref1.heartbeat;
    if (port == null) {
      port = 5672;
    }
    if (protocol == null) {
      protocol = 'amqp:';
    }
    options = {
      host: host,
      port: port,
      protocol: protocol
    };
    if (login != null) {
      options.login = login;
    }
    if (password != null) {
      options.password = password;
    }
    if (vhost != null) {
      options.vhost = vhost;
    }
    if (heartbeat != null) {
      options.heartbeat = heartbeat;
    }
    this.connection = amqp.createConnection(options);
    this.connection.on('error', this.emit.bind(this, 'error'));
    rabbitMqResourceName = this.getRabbitMqResourceName();
    return this.connection.on('ready', function() {
      _this.establishPresence();
      return _this.connection.exchange('accounting', {
        type: 'topic',
        autoDelete: false,
        durable: true,
        exclusive: false
      }, function(accounting) {
        return _this.connection.exchange(rabbitMqResourceName, _this.getKiteExchangeOptions(), function(exchange) {
          return accounting.bind(exchange, '#', function() {
            return _this.connection.queue('', {
              exclusive: true
            }, function(queue) {
              queue.bind(exchange, '');
              return queue.on('queueBindOk', function() {
                return queue.subscribe(function(message, headers, deliveryInfo) {
                  return _this.handleMessage(message, headers, deliveryInfo);
                });
              });
            });
          });
        });
      });
    });
  };

  Kite.prototype.writePid = function(pidPath) {
    if (pidPath) {
      return require("fs").writeFile(pidPath, "" + process.pid, function(err) {
        if (err != null) {
          return console.log("[WARN] Can't write pid to " + pidPath + ":  monit can't watch this process. err:" + err.message);
        }
      });
    }
  };

  Kite.prototype.run = function(config) {
    var host, logPath, password, pidPath, username;

    this.config = config;
    pidPath = config.pidPath, logPath = config.logPath, host = config.host, username = config.username, password = config.password, this.apiUri = config.apiUri;
    this.writePid(pidPath);
    return this.registerSelf();
  };

  return Kite;

})(EventEmitter);
