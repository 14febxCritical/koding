{EventEmitter} = require 'microemitter'
redis = require 'redis'
os = require 'os'

class Kommunicator extends EventEmitter

  constructor:(@publicKey, @serviceGenericName, @serviceUniqueName, @host='localhost', @port=6380)->
    @callbackid = 0
    @waitingReplies = {}
    @kiteList = {}
    @commands = 
      'kite.who': ()->
        [@getChannelNameForKite()]
      'kite.join': (channelName, kiteName)->
        if not @kiteList[channelName]
          @kiteList[channelName] = []
        if kiteName not in @kiteList[channelName] 
          @kiteList[channelName].push kiteName
        console.log "clients", @kiteList
        [true]

  getChannelNameForKite:(genericName, uniqueName)->
    gn = genericName or @serviceGenericName
    "#{@publicKey}-kite-#{gn}-#{uniqueName or @serviceUniqueName}"

  getChannelNameForGenericName:(genericName)->
    "#{@publicKey}-kite-#{genericName or @serviceGenericName}"

  getChannelNameForAll:()->
    "#{@publicKey}-kite-all"

  receivedCommand: (from, cmdid, cmd, args)->
    console.log "received command", from, cmd, args

    if cmd.indexOf('reply-') > -1
      cmdid = cmd.split('reply-')[1]
      console.log "received cmdid", cmdid, @waitingReplies[cmdid]
      @waitingReplies[cmdid]?.apply(@, args)
      return

    console.log "@commands", @commands, cmd
    fn = @commands[cmd]
    ret = fn.apply(@, args)
    @sendCommand(from, "reply-#{cmdid}", ret)

  sendCommand: (channel, cmd, args, cb=false)->
    @callbackid++;
    data = {
      cmd: cmd,
      id: @callbackid,
      args: args,
      from: @getChannelNameForKite()
    }
    console.log ">>>>> publishing to channel", channel, cmd, args 
    if cb
      @waitingReplies[@callbackid] = cb
    console.log "waiting replies list", @waitingReplies
    @mergenData.publish channel, JSON.stringify(data)

  connectToMessageBus: ()=>
    console.log @serviceUniqueName, @serviceGenericName, @publicKey

    @mergen = redis.createClient(@port, @host)
    @mergen.on "error", (err)->
      console.log("Error ",err)

    @mergen.subscribe @getChannelNameForAll()
    @mergen.subscribe @getChannelNameForGenericName()
    @mergen.subscribe @getChannelNameForKite()

    @mergen.on "message", (channel, message)=>
      console.log ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> received channel", channel, "message", message
      message = JSON.parse message
      @receivedCommand message.from, message.id, message.cmd, message.args

    @mergen.on "subscribe", (channel, count)->
      console.log ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> connected to channel", channel

    # we have a second connection because, redis client in node doesnt send any commands
    # when it enters subscribe mode, though redis docs says you can publish if you are in subcribe
    # mode
    @mergenData = redis.createClient(@port, @host)
    @mergenData.on "error", (err)->
      console.log "error", err

    data = {}
    data.pid = process.pid
    data.hostname = os.hostname()
    data.serviceGenericName = @serviceGenericName
    data.serviceUniqueName = @serviceUniqueName
    data.startedAt = Date.now()

    @mergenData.hset "#{@publicKey}-kites", "#{@serviceGenericName}-#{@serviceUniqueName}", data

    @sendCommand @getChannelNameForGenericName(), "kite.who", [], (reply)->
      console.log "!!!!!!!! received reply for me", reply 
      @commands['kite.join'].call(@, @getChannelNameForGenericName(), reply)

    @sendCommand @getChannelNameForGenericName(), "kite.join", [@getChannelNameForGenericName(), @getChannelNameForKite()]

    @connected = true

module.exports = class Kite extends EventEmitter

  amqp = require 'amqp'
  {Scrubber, Store} = require 'koding-dnode-protocol'
  {parse, stringify} = JSON
  Object.defineProperty Object.prototype, 'throwError', value:(it)-> throw it

  @throwIt = (it) ->
    console.error it  if it?
    process.kill process.pid, 'SIGTERM'

  serializableError =(err)->
    message  : err.message
    stack    : err.stack

  constructor:(@kiteName, @api, @publicKey)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @channels = {}
    @clients = {} # a hash of clients by the secret channel ids they are using.
    @requesters = {}

  handleError:(routingKey, callbackId='uncaughtException', err)->
    err = serializableError(err)
    @fetchBrokerExchange (brokerExchange)->
      brokerExchange.publish routingKey, stringify(
        arguments : [err]
        method    : callbackId
        callbacks : {}
      ),{
        contentType: 'application/json'
      }

  handleRequest:(scrubbed, routingKey, {headers, deliveryInfo}, exchangeName = "broker")->
    authenticatedUsername = @clients[routingKey]
    return @handleResponse routingKey, 'pong', []  if scrubbed.method is 'ping'
    authenticatedUsername = if authenticatedUsername? then authenticatedUsername else routingKey

    @unscrubMessage routingKey, authenticatedUsername, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      if data?
        data.withArgs?.username = authenticatedUsername
        {method, withArgs} = data
      withArgs or= {}
      if @api.propertyIsEnumerable(method) and 'function' is typeof @api[method]
        withArgs.authenticatedUser = authenticatedUsername
        @api[method]? withArgs, (err, msg)=>

          @handleResponse routingKey, callback.id, [].slice.call(arguments), exchangeName
      else if callback = @localStore.get(scrubbed.method)
        callback unscrubbed...
      else
        @handleError routingKey, callback?.id, {
          message: "No such method! #{method}"
        }

  unscrubMessage:(routingKey, authenticatedUser, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        storeKey = "#{authenticatedUser}#{callbackId}"
        unless @remoteStore.has(storeKey)
          @remoteStore.add storeKey, (args...)=>
            @handleResponse routingKey, callbackId, args
        @remoteStore.get storeKey
      callback unscrubbed

  handleResponse:(routingKey, callbackId, args, exchangeName = "broker")->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      out.pid = process.pid
      @fetchExchangeByName exchangeName, (exchange)->
        exchange.publish routingKey, stringify(out)

  handleMessage:(message, headers, deliveryInfo)->
    console.log "handle message", message
    {routingKey} = deliveryInfo
    messageData = (try parse message.data) or message
    # catch e then @emit 'error', e
    switch routingKey
      when 'auth.join'  then @join messageData
      when 'auth.leave' then @leave messageData
      when 'auth.who' then @who messageData
      else
        if routingKey of @clients
          @handleRequest messageData, routingKey, {headers, deliveryInfo}
        else
          console.log "Unknown routing key: #{routingKey}.  Dropping message on the floor."

  getKiteId:-> "#{process.pid}|#{require('os').hostname().replace /\./g, '_'}"

  getServiceType:-> "kite-#{@kiteName}"

  getRabbitMqResourceName:-> "#{@getServiceType()}-#{@getKiteId()}"

  getKiteExchangeOptions:->
    type        : 'fanout'
    autoDelete  : yes
    durable     : no

  fetchExchange:(name, options, callback)->
    exchangeName  = "#{name}Exchange"
    readyEvent    = "#{exchangeName}Ready"
    if @[exchangeName] is null
      @once readyEvent, => @fetchBrokerExchange callback
    else unless @brokerExchange?
      @[exchangeName] = null
      @connection.exchange name, options,
        (exchange)=>
          @[exchangeName] = exchange
          @emit readyEvent
          callback exchange
    else callback @[exchangeName]

  fetchAuthExchange:(callback)->
    @fetchExchange 'auth', {noDeclare:yes}, callback

  fetchBrokerExchange:(callback)->
    @fetchExchange 'broker', {noDeclare: yes}, callback

  fetchExchangeByName:(name, callback)->
    switch name
      when 'broker'     then @fetchBrokerExchange callback
      when 'auth'       then @fetchAuthExchange callback
      when 'kite-intra' then @fetchKiteIntraCommExchange callback

  fetchKiteIntraCommExchange:(callback)->
    @kite2kiteExchangeConfig = 
      type : 'direct'
      autoDelete : no
      durable : yes
      exclusive : no    
    @fetchExchange 'kite-intra-comm', @kite2kiteExchangeConfig, callback

  who: (messageData)->
    console.log "who: received messageData", messageData

  leave:(messageData)->
    {routingKey} = messageData
    delete @clients[routingKey]
    @api._leave? messageJson

  join:(messageData)->
    console.log "auth.join", messageData
    {routingKey, username, correlationName, serviceGenericName} = messageData
    console.log "#{username}@#{correlationName} has joined to service #{serviceGenericName}"
    @clients[routingKey] = username
    @api._join? messageJson
    @handleResponse routingKey, 'ready', [@getRabbitMqResourceName()]

  # join:(messageData)->
  #   console.log 'join', {messageData}
  #   {username, routingKey} = messageData
  #   @clients[routingKey] = username
  #   @api._join? messageJson
  #   @handleResponse routingKey, 'ready', [@getRabbitMqResourceName()]

  createPresenceMemberKey:->
    serviceGenericName  = @getServiceType()
    serviceUniqueName   = @getRabbitMqResourceName()
    "serviceType.kite.serviceGenericName.#{serviceGenericName}.serviceUniqueName.#{serviceUniqueName}"

  establishPresence:->
    console.log "establishPresence", @createPresenceMemberKey()
    Presence = require 'koding-rabbit-presence'
    @presence = new Presence {
      @connection
      exchange    : 'services-presence'
      member      : @createPresenceMemberKey()
    }
    @presence.announce()

  registerSelf:=>
    {config} = this
    {host, port, protocol, login, password, vhost, heartbeat} = config.amqp
    port              ?= 5672
    protocol          ?= 'amqp:'
    options           = {host, port, protocol} # but not vhost, because of a bug in node-amqp
    options.login     = login     if login?
    options.password  = password  if password?
    options.vhost     = vhost     if vhost?
    options.heartbeat = heartbeat if heartbeat?
    @connection       = amqp.createConnection options
    @connection.on 'error', @emit.bind this, 'error'
    rabbitMqResourceName = @getRabbitMqResourceName()
    @connection.on 'ready', =>
      @establishPresence()
      @connection.exchange rabbitMqResourceName, @getKiteExchangeOptions(), (exchange)=>
        @connection.queue '', {exclusive: yes}, (queue)=>
          queue.bind exchange, ''
          queue.on 'queueBindOk', =>
            console.log "#{@kiteName}: Kite is connected to system"
            queue.subscribe (message, headers, deliveryInfo)=>
              @handleMessage message, headers, deliveryInfo

      @fetchExchangeByName 'kite-intra', (kite2kite)=>
        @connection.queue '', {exclusive: yes}, (k2kQueue) =>
          
          k2kQueue.bind kite2kite, @kiteRoutingKeyPrefix + @kiteName
          k2kQueue.on 'queueBindOk', =>
            console.log "#{@kiteName}: Intra-Kite communication is ready"
            k2kQueue.subscribe (message, headers, deliveryInfo)=>
              @receiveMessageFromAnotherKite message, headers, deliveryInfo
          k2kQueue.on 'error', =>
            console.log arguments

  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"

  run:(@config, @key)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf()

    @communicator = new Kommunicator(@key, @getServiceType(), @getRabbitMqResourceName())
    @communicator.connectToMessageBus()

#### kite to kite communication hadling #####

  ##todo change routing prefix generation method
  kiteRoutingKeyPrefix = "k2k"

  tellKite:(kite, callback)=>
    args = [kite, callback]
    {method, kiteName} = kite
    if kiteName == @kiteName
      console.log 'Self-calling a kite is not recommended! Now dropping message'  
    else
      @request kiteName, method, args

  request :(kiteName, method, args)->
    @scrubKiteMessage method, args, (scrubbed) =>
      messageString = JSON.stringify scrubbed
      @sendMessageToAnotherKite kiteName, messageString
  
  sendMessageToAnotherKite:(kiteName, messsage)->
    @fetchExchangeByName 'kite-intra', (kite2kite)=>
      kite2kite.publish @kiteRoutingKeyPrefix + kiteName, messsage

  scrubKiteMessage:(method, args, callback) ->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method or= method
      scrubbed.name or= @kiteName
      callback scrubbed

  receiveMessageFromAnotherKite:(message, headers, deliveryInfo)->
    messageData = (try message.data.toString()) or message
    scrubbed = JSON.parse messageData
    routingKey = @kiteRoutingKeyPrefix + scrubbed.name
    @handleRequest scrubbed, routingKey, {headers, deliveryInfo}, 'kite-intra'

  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"
