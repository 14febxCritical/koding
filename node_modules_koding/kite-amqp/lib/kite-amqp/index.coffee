{EventEmitter} = require 'microemitter'

module.exports = class Kite extends EventEmitter

  amqp = require 'amqp'
  {Scrubber, Store} = require 'koding-dnode-protocol'
  {parse, stringify} = JSON
  Object.defineProperty Object.prototype, 'throwError', value:(it)-> throw it

  serializableError =(err)->
    message  : err.message
    stack    : err.stack

  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @channels = {}

    @clients = {} # a hash of clients by the secret channel ids they are using.

    @requesters = {}

  bound: require 'koding-bound'

  handleError:(routingKey, callbackId='uncaughtException', err)->
    err = serializableError(err)
    @fetchBrokerExchange (brokerExchange)->
      brokerExchange.publish routingKey, stringify(
        arguments : [err]
        method    : callbackId
        callbacks : {}
      ),{
        contentType: 'application/json'
      }

  handleRequest:(scrubbed, routingKey, {headers, deliveryInfo})->
    {channels, requesters} = this
    authenticatedUser = @clients[routingKey]
    @unscrubMessage routingKey, authenticatedUser, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      data.withArgs?.username = authenticatedUser
      {method, withArgs} = data
      withArgs or= {}
      switch method
        when '_ping' then @handleResponse routingKey, callback.id, 1
        else
          if @api.propertyIsEnumerable(method) and 'function' is typeof @api[method]
            withArgs.authenticatedUser = authenticatedUser
            @api[method]? withArgs, (err, msg)=>
              @handleResponse routingKey, callback.id, [].slice.call(arguments)
          else if callback = @localStore.get(scrubbed.method)
            callback unscrubbed...
          else
            @handleError routingKey, callback?.id, {
              message: "No such method! #{method}"
            }

  unscrubMessage:(routingKey, authenticatedUser, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        storeKey = "#{authenticatedUser}#{callbackId}"
        unless @remoteStore.has(storeKey)
          @remoteStore.add storeKey, (args...)=>
            @handleResponse routingKey, callbackId, args
        @remoteStore.get storeKey
      callback unscrubbed

  handleResponse:(routingKey, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      out.pid = process.pid
      @fetchBrokerExchange (brokerExchange)->
        brokerExchange.publish routingKey, stringify(out)

  handleMessage:(message, headers, deliveryInfo)->
    {routingKey} = deliveryInfo
    messageData = (try parse message.data) or message
    # catch e then @emit 'error', e
    switch routingKey
      when 'auth.join'  then @join messageData
      when 'auth.leave' then @leave messageData
      else
        if routingKey of @clients
          @handleRequest messageData, routingKey, {headers, deliveryInfo}
        else
          console.log "Unknown routing key: #{routingKey}.  Dropping message on the floor."

  getKiteId:-> "#{process.pid}|#{require('os').hostname().replace /\./g, '_'}"

  getServiceType:-> "kite-#{@kiteName}"

  getRabbitMqResourceName:-> "#{@getServiceType()}-#{@getKiteId()}"

  getKiteExchangeOptions:->
    type        : 'fanout'
    autoDelete  : yes
    durable     : no

  getBrokerExchangeOptions:->
    type        : 'topic'
    autoDelete  : yes
    durable     : no

  fetchExchange:(name, options, callback)->
    exchangeName  = "#{name}Exchange"
    readyEvent    = "#{exchangeName}Ready"
    if @[exchangeName] is null
      @once readyEvent, => @fetchBrokerExchange callback
    else unless @brokerExchange?
      @[exchangeName] = null
      @connection.exchange name, options,
        (exchange)=>
          @[exchangeName] = exchange
          @emit readyEvent
          callback exchange
    else callback @[exchangeName]

  fetchAuthExchange:(callback)->
    @fetchExchange 'auth', @getKiteExchangeOptions(), callback

  fetchBrokerExchange:(callback)->
    @fetchExchange 'broker', @getBrokerExchangeOptions(), callback

  leave:(messageData)->
    {routingKey} = messageData
    delete @clients[routingKey]
    @api._leave? messageJson

  join:(messageData)->
    console.log 'join', {messageData}
    {username, routingKey} = messageData
    @clients[routingKey] = username
    @api._join? messageJson
    @handleResponse routingKey, 'ready', [@getRabbitMqResourceName()]

  error =-> throw arguments[0]

  registerServiceWithAuthWorker:->
    serviceType         = 'kite'
    serviceGenericName  = @getServiceType()
    serviceUniqueName   = @getRabbitMqResourceName()
    @fetchAuthExchange (exchange)->
      exchange.publish 'kite.join', {
        serviceType
        serviceGenericName
        serviceUniqueName
      }

  createPresenceMemberKey:->
    serviceGenericName  = @getServiceType()
    serviceUniqueName   = @getRabbitMqResourceName()
    "serviceType.kite.serviceGenericName.#{serviceGenericName}.serviceUniqueName.#{serviceUniqueName}"

  establishPresence:->
    Presence = require 'koding-rabbit-presence'
    @presence = new Presence {
      @connection
      exchange    : 'services-presence'
      member      : @createPresenceMemberKey()
    }
    @presence.announce()

  registerSelf:->
    {config} = this
    {host, port, protocol, login, password, vhost} = config.amqp
    port              ?= 5672
    protocol          ?= 'amqp:'
    options           = {host, port, protocol} # but not vhost, because of a bug in node-amqp
    options.login     = login     if login?
    options.password  = password  if password?
    options.vhost     = vhost     if vhost?
    @connection       = amqp.createConnection options
    @connection.on 'error', @bound 'emit'
    rabbitMqResourceName = @getRabbitMqResourceName()
    @connection.on 'ready', =>
      @establishPresence()
      # @registerServiceWithAuthWorker()
      @connection.exchange rabbitMqResourceName, @getKiteExchangeOptions(), (exchange)=>
        @connection.queue rabbitMqResourceName, (queue)=>
          queue.bind exchange, ''
          queue.on 'queueBindOk', =>
            queue.subscribe (message, headers, deliveryInfo)=>
              @handleMessage message, headers, deliveryInfo

  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"

  run:(@config)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf()
