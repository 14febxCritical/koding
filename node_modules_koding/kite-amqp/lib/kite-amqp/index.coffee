{EventEmitter} = require 'microemitter'

module.exports = class Kite extends EventEmitter

  amqp = require 'amqp'
  {Scrubber, Store} = require 'koding-dnode-protocol'
  {parse, stringify} = JSON
  Object.defineProperty Object.prototype, 'throwError', value:(it)-> throw it

  @throwIt = (it) ->
    console.error it  if it?
    process.kill process.pid, 'SIGTERM'

  serializableError =(err)->
    message  : err.message
    stack    : err.stack

  constructor:(@kiteName, @api, @roundRobin = false)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @channels = {}

    @clients = {} # a hash of clients by the secret channel ids they are using.

    @requesters = {}

  handleError:(routingKey, callbackId='uncaughtException', err)->
    err = serializableError(err)
    @fetchBrokerExchange (brokerExchange)->
      brokerExchange.publish routingKey, stringify(
        arguments : [err]
        method    : callbackId
        callbacks : {}
      ),{
        contentType: 'application/json'
      }

  handleRequest:(scrubbed, routingKey, {headers, deliveryInfo}, exchangeName = "broker")->
    authenticatedUsername = @clients[routingKey]
    return @handleResponse routingKey, 'pong', []  if scrubbed.method is 'ping'
    authenticatedUsername = if authenticatedUsername? then authenticatedUsername else routingKey

    @unscrubMessage routingKey, authenticatedUsername, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      if data?
        data.withArgs?.username = authenticatedUsername
        {method, withArgs} = data
      withArgs or= {}
      if @api.propertyIsEnumerable(method) and 'function' is typeof @api[method]
        withArgs.authenticatedUser = authenticatedUsername
        @api[method]? withArgs, (err, msg)=>

          @handleResponse routingKey, callback.id, [].slice.call(arguments), exchangeName
      else if callback = @localStore.get(scrubbed.method)
        callback unscrubbed...
      else
        @handleError routingKey, callback?.id, {
          message: "No such method! #{method}"
        }

  unscrubMessage:(routingKey, authenticatedUser, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        storeKey = "#{authenticatedUser}#{callbackId}"
        unless @remoteStore.has(storeKey)
          @remoteStore.add storeKey, (args...)=>
            @handleResponse routingKey, callbackId, args
        @remoteStore.get storeKey
      callback unscrubbed

  handleResponse:(routingKey, callbackId, args, exchangeName = "broker")->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      out.pid = process.pid
      @fetchExchangeByName exchangeName, (exchange)->
        exchange.publish routingKey, stringify(out)

  handleMessage:(message, headers, deliveryInfo)->
    {routingKey} = deliveryInfo
    messageData = (try parse message.data) or message
    # catch e then @emit 'error', e
    switch routingKey
      when 'auth.join'  then @join messageData
      when 'auth.leave' then @leave messageData
      else
        if routingKey of @clients
          @handleRequest messageData, routingKey, {headers, deliveryInfo}
        else
          console.log "Unknown routing key: #{routingKey}.  Dropping message on the floor."

  getKiteId:-> "#{process.pid}|#{require('os').hostname().replace /\./g, '_'}"

  getServiceType:-> "kite-#{@kiteName}"

  getRabbitMqResourceName:-> "#{@getServiceType()}-#{@getKiteId()}"

  getKiteExchangeOptions:->
    type        : 'fanout'
    autoDelete  : yes
    durable     : no

  fetchExchange:(name, options, callback)->
    exchangeName  = "#{name}Exchange"
    readyEvent    = "#{exchangeName}Ready"
    if @[exchangeName] is null
      @once readyEvent, => @fetchBrokerExchange callback
    else unless @brokerExchange?
      @[exchangeName] = null
      @connection.exchange name, options,
        (exchange)=>
          @[exchangeName] = exchange
          @emit readyEvent
          callback exchange
    else callback @[exchangeName]

  fetchAuthExchange:(callback)->
    @fetchExchange 'auth', {noDeclare:yes}, callback

  fetchBrokerExchange:(callback)->
    @fetchExchange 'broker', {noDeclare: yes}, callback

  fetchExchangeByName:(name, callback)->
    switch name
      when 'broker'     then @fetchBrokerExchange callback
      when 'auth'       then @fetchAuthExchange callback
      when 'kite-intra' then @fetchKiteIntraCommExchange callback

  fetchKiteIntraCommExchange:(callback)->
    @kite2kiteExchangeConfig = 
      type : 'direct'
      autoDelete : no
      durable : yes
      exclusive : no    
    @fetchExchange 'kite-intra-comm', @kite2kiteExchangeConfig, callback

  leave:(messageData)->
    {routingKey} = messageData
    delete @clients[routingKey]
    @api._leave? messageJson

  join:(messageData)->
    {routingKey, username, correlationName, serviceGenericName} = messageData
    console.log "#{username}@#{correlationName} has joined to service #{serviceGenericName}"
    @clients[routingKey] = username
    @api._join? messageJson
    @handleResponse routingKey, 'ready', [@getRabbitMqResourceName()]

  # join:(messageData)->
  #   console.log 'join', {messageData}
  #   {username, routingKey} = messageData
  #   @clients[routingKey] = username
  #   @api._join? messageJson
  #   @handleResponse routingKey, 'ready', [@getRabbitMqResourceName()]

  createPresenceMemberKey:->
    serviceGenericName  = @getServiceType()
    serviceUniqueName   = @getRabbitMqResourceName()
    "serviceType.kite.serviceGenericName.#{serviceGenericName}.serviceUniqueName.#{serviceUniqueName}"

  establishPresence:->
    Presence = require 'koding-rabbit-presence'
    @presence = new Presence {
      @connection
      exchange    : 'services-presence'
      member      : @createPresenceMemberKey()
    }
    @presence.announce()

  registerSelf:=>
    {config} = this
    {host, port, protocol, login, password, vhost, heartbeat} = config.amqp
    port              ?= 5672
    protocol          ?= 'amqp:'
    options           = {host, port, protocol} # but not vhost, because of a bug in node-amqp
    options.login     = login     if login?
    options.password  = password  if password?
    options.vhost     = vhost     if vhost?
    options.heartbeat = heartbeat if heartbeat?
    @connection       = amqp.createConnection options
    @connection.on 'error', @emit.bind this, 'error'
    rabbitMqResourceName = @getRabbitMqResourceName()
    @connection.on 'ready', =>
      @establishPresence()
      @connection.exchange 'accounting', { type : 'topic', autoDelete : no, durable : yes, exclusive : no }, (accounting) =>
        @connection.exchange rabbitMqResourceName, @getKiteExchangeOptions(), (exchange)=>
          accounting.bind exchange, '#', =>
            @connection.queue '', {exclusive: yes}, (queue)=>
              queue.bind exchange, ''
              queue.on 'queueBindOk', =>
                console.log "#{@kiteName}: Kite is connected to system"
                queue.subscribe (message, headers, deliveryInfo)=>
                  @handleMessage message, headers, deliveryInfo

      @fetchExchangeByName 'kite-intra', (kite2kite)=>
        @connection.queue '', {exclusive: yes}, (k2kQueue) =>
          
          k2kQueue.bind kite2kite, @kiteRoutingKeyPrefix + @kiteName
          k2kQueue.on 'queueBindOk', =>
            console.log "#{@kiteName}: Intra-Kite communication is ready"
            k2kQueue.subscribe (message, headers, deliveryInfo)=>
              @receiveMessageFromAnotherKite message, headers, deliveryInfo
          k2kQueue.on 'error', =>
            console.log arguments

  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"

  run:(@config)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf()

#### kite to kite communication hadling #####

  ##todo change routing prefix generation method
  kiteRoutingKeyPrefix = "k2k"

  tellKite:(kite, callback)=>
    args = [kite, callback]
    {method, kiteName} = kite
    if kiteName == @kiteName
      console.log 'Self-calling a kite is not recommended! Now dropping message'  
    else
      @request kiteName, method, args

  request :(kiteName, method, args)->
    @scrubKiteMessage method, args, (scrubbed) =>
      messageString = JSON.stringify scrubbed
      @sendMessageToAnotherKite kiteName, messageString
  
  sendMessageToAnotherKite:(kiteName, messsage)->
    @fetchExchangeByName 'kite-intra', (kite2kite)=>
      kite2kite.publish @kiteRoutingKeyPrefix + kiteName, messsage

  scrubKiteMessage:(method, args, callback) ->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      scrubbed = scrubber.toDnodeProtocol()
      scrubbed.method or= method
      scrubbed.name or= @kiteName
      callback scrubbed

  receiveMessageFromAnotherKite:(message, headers, deliveryInfo)->
    messageData = (try message.data.toString()) or message
    scrubbed = JSON.parse messageData
    routingKey = @kiteRoutingKeyPrefix + scrubbed.name
    @handleRequest scrubbed, routingKey, {headers, deliveryInfo}, 'kite-intra'

  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"

  run:(@config)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf()
