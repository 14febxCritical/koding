{EventEmitter} = require 'microemitter'

module.exports = class Kite extends EventEmitter

  amqp = require 'amqp'
  {Scrubber, Store} = require 'koding-dnode-protocol'
  {parse, stringify} = JSON
  Object.defineProperty Object.prototype, 'throwError', value:(it)-> throw it

  serializableError =(err)->
    message  : err.message
    stack    : err.stack

  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @channels = {}

    @clients = {} # a hash of clients by the secret channel ids they are using.

    @requesters = {}

  bound: require 'koding-bound'

  handleError:(routingKey, callbackId='uncaughtException', err)->
    err = serializableError(err)
    @fetchBrokerExchange (brokerExchange)->
      brokerExchange.publish routingKey, stringify(
        arguments : [err]
        method    : callbackId
        callbacks : {}
      ),{
        contentType: 'application/json'
      }

  handleRequest:(scrubbed, routingKey, {headers, deliveryInfo})->
    {channels, requesters} = this
    authenticatedUser = @clients[routingKey]
    @unscrubMessage routingKey, authenticatedUser, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      data.withArgs?.username = authenticatedUser
      {method, withArgs} = data
      withArgs or= {}
      switch method
        when '_ping' then @handleResponse routingKey, callback.id, 1
        else
          if @api.propertyIsEnumerable(method) and 'function' is typeof @api[method]
            withArgs.authenticatedUser = authenticatedUser
            @api[method]? withArgs, (err, msg)=>
              @handleResponse routingKey, callback.id, [].slice.call(arguments)
          else if callback = @localStore.get(scrubbed.method)
            callback unscrubbed...
          else
            @handleError routingKey, callback?.id, {
              message: "No such method! #{method}"
            }

  unscrubMessage:(routingKey, authenticatedUser, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      storeKey = "#{authenticatedUser}#{callbackId}"
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        unless @remoteStore.has(storeKey)
          @remoteStore.add storeKey, (args...)=>
            @handleResponse routingKey, callbackId, args
        @remoteStore.get storeKey
      callback unscrubbed

  handleResponse:(routingKey, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      out.pid = process.pid
      @fetchBrokerExchange (brokerExchange)->
        console.log 'broker exchange', brokerExchange
        brokerExchange.publish routingKey, stringify(out)

  handleMessage:(message, headers, deliveryInfo)->
    {routingKey} = deliveryInfo
    try json = parse message.data
    catch e then @emit 'error', e
    switch routingKey
      when 'auth.join'  then @join json
      when 'auth.leave' then @leave json
      else
        if routingKey of @clients
          @handleRequest json, routingKey, {headers, deliveryInfo}
        else
          console.log "Unknown routing key: #{routingKey}.  Dropping message on the floor."

  getKiteId:-> "|#{process.pid}|#{require('os').hostname()}"

  getRabbitMqResourceName:-> "kite-#{@kiteName}#{@getKiteId()}"

  getKiteExchangeOptions:->
    type        : 'fanout'
    autoDelete  : yes
    durable     : no

  getBrokerExchangeOptions:->
    type        : 'topic'
    autoDelete  : yes
    durable     : no

  fetchExchange:(name, options, callback)->
    readyEvent = "#{name}ExchangeReady"
    if @brokerExchange is null
      @once readyEvent, => @fetchBrokerExchange callback
    else unless @brokerExchange?
      @brokerExchange = null
      @connection.exchange name, options,
        (@brokerExchange)=>
          @emit readyEvent
          callback brokerExchange
    else callback @brokerExchange

  fetchAuthExchange:(callback)->
    @fetchExchange 'auth', @getKiteExchangeOptions(), callback

  fetchBrokerExchange:(callback)->
    @fetchExchange 'broker', @getBrokerExchangeOptions(), callback

  leave:(messageJson)->
    {routingKey} = messageJson
    delete @clients[routingKey]
    @api._leave? messageJson

  join:(messageJson)->
    {username, routingKey} = messageJson
    @clients[routingKey] = username
    @api._join? messageJson
    @handleResponse routingKey, 'ready', [null]

  error =-> throw arguments[0]

  getServiceType:-> "kite-#{@name}"

  getServiceName:-> 

  registerServiceWithAuthWorker:->
    serviceType = @getServiceType()
    serviceName = @getRabbitMqResourceName()
    @fetchAuthExchange (exchange)->
      exchange.publish 'kite.join', {serviceType, serviceName}

  registerSelf:->
    {config} = this
    {host, port, protocol, username, password, vhost} = config.amqp
    port      ?= 5672
    protocol  ?= 'amqp:'
    options   = {host}
    options.login = username  if username?
    options.password = password  if password?
    options.vhost = vhost  if vhost?
    @connection = amqp.createConnection options
    @connection.on 'error', @bound 'emit'
    rabbitMqResourceName = @getRabbitMqResourceName()
    @connection.on 'ready', =>
      @registerServiceWithAuthWorker()
      @connection.exchange rabbitMqResourceName, @getKiteExchangeOptions(), (exchange)=>
        @connection.queue rabbitMqResourceName, (queue)=>
          queue.bind exchange, ''
          queue.on 'queueBindOk', =>
            queue.subscribe (message, headers, deliveryInfo)=>
              @handleMessage message, headers, deliveryInfo

  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"

  run:(@config)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf()
