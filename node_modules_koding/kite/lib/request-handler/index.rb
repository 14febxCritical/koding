require "rubygems"
require "bundler/setup"
require 'pusher-client'
require 'net/http'
require 'fileutils'
require './parse_options'

$log = Logger.new($options[:logfile])

$log.debug "LAUNCHING AN INSTANCE OF THE KITE REQUEST HANDLER"

$log.debug $options.inspect

class KiteRequestHandler
  def initialize(config)
    @config = config
    @socket = PusherClient::Socket.new(config[:key], config)
    krh_channel_name = "private-krh-#{$options[:kite_name]}"
    $log.debug "ADDING join/part HANDLERS: #{krh_channel_name}"
    add_listener(krh_channel_name, 'join')
    add_listener(krh_channel_name, 'part')
    add_listener(krh_channel_name, 'status')
    add_listener(krh_channel_name, 'fail')
    @channels = {}
    join_all()
  end
  
  def join_all()
    $log.debug 'Joining all previously joined channels.'
    begin
      channels = Dir.new(@config[:joined_channels_path])
    rescue Errno::ENOENT
      FileUtils.mkdir_p(@config[:joined_channels_path])
      retry
    end
    channels.each do |channel|
      if channel !~ /^(\.\.?)$/
        $log.debug "Inspecting channel: #{channel}"
        $log.debug "This channel was not previously joined: #{channel}"
        join {'channel' => channel}, true
      end
    end
  end
  
  def add_to_joined_channels_path(channel)
    $log.debug "[JOIN] Remembering that we are joined to a channel: #{channel}"
    FileUtils.touch(@config[:joined_channels_path]+channel)
  end
  
  def remove_from_joined_channels_path(channel)
    unless channel.nil?
      $log.debug "[PART] Forgetting about a channel that we were previously joined to: #{channel}"
      begin
        # Ummm...  do we need some more security on this one???? C.T.
        File.unlink(@config[:joined_channels_path]+channel)
      rescue Errno::ENOENT
        $log.warn "could not remove tmp file for #{channel}"
      end
    end
  end
  
  def status(msg)
    $log.debug 'BEGIN STATUS DUMP'
    $log.debug "REQUEST-HANDLER LEVEL RECORD: \n\t"+@channels.keys.join("\n\t")
    $log.debug "socket-library level record: \n\t"+@socket.channels.channels.keys.join("\n\t")
    $log.debug 'END STATUS DUMP'
  end
  
  def fail(msg)
    $log.warn 'Intentionally failing...'
    $log.debug "Intentionally failing means unsubscribing from the event on the socket without cleaning up the local state."
    @channels.keys.each do |channel|
      @socket.unsubscribe(channel)
    end
  end

  def join(channel, silent=false)
    $log.debug "JOINING TO CHANNEL: #{channel['channel']}"
    $log.debug @channels.inspect
    $log.debug channel['channel']
    unless @channels.has_key? channel['channel']
      $log.debug "joining channel #{channel['channel']}"
      @channels[channel['channel']] = true
      add_listener(channel['channel'], 'client-message')
    end
    add_to_joined_channels_path(channel['channel']) unless silent
  end

  def part(channel, silent=false)
    $log.debug "PARTING FROM CHANNEL: #{channel['channel']}"
    @socket.unsubscribe channel['channel']
    @channels.delete channel['channel']
    remove_from_joined_channels_path(channel['channel']) unless silent
  end
  
  def add_listener(channel, event)
    @socket.subscribe(channel, 'khr')
    @socket[channel].bind(event) do |msg|
      clean_event = event
      clean_event[/^(client-)?/] = ''
      $log.debug "RECEIVED AN EVENT: #{event} => #{clean_event}"
      begin
        msg_data = JSON.parse(msg)
      rescue
        msg_data = msg
      end
      if respond_to? clean_event
        $log.debug "CLASS IMPLEMENTS A HANDLER: #{clean_event}"
        __send__(clean_event, msg_data) 
      else
        $log.debug "CLASS CAN'T HANDLE EVENT; FORWARDING #{channel} #{event} #{msg} TO KITE"
        send_request(channel, event,  msg_data)
      end
    end
  end

  def send_request(channel, event, msg)
    if msg.is_a? String
      $log.warn "Don't know how to handle String"
    else
      msg[:username] = channel.split('-')[2]
      $log.debug "got a message #{msg.inspect}"
      $log.debug "sending message to endpoint: #{@config[:kite_uri]}"
      begin
        res = Net::HTTP.post_form(URI.parse(@config[:kite_uri]), msg)
      rescue => err
        $log.debug "ERROR: "+err.inspect
      end
      $log.debug "response: #{res}"
      puts res.body
    end
  end

  def connect
    @socket.connect
  end
end

begin 
  PusherClient.logger = $log
  handler = KiteRequestHandler.new($options)
  handler.connect
rescue => err
  $log.fatal("Caught exception; exiting")
  $log.fatal(err)
end
