'use strict'

module.exports = class Channel

  {EventEmitter} = require 'microemitter'
  {sendWsMessage, performTask} = require './util'

  constructor:(@ws, @name, options) ->
    @fineGrained = options?.fineGrained ? no
    @emitter = new EventEmitter
    @events = {}
    @wildcards = {}
    onopen = =>
      name = @privateName or @name
      if ws.readyState > 0
        sendWsMessage ws, "client-bind", name  unless @fineGrained
        msgListener = (e) =>
          data = JSON.parse(e.data)
          # console.log data
          return  if not data.event or not data.exchange
          exchange = name
          return  if data.exchange isnt exchange
          evt =
            type  : exchange + "." + data.event
            event : data.event
          if data.paylod? then try
            payload = JSON.parse(data.payload)
          catch ex
            payload = data.payload
          finally
            data.payload = payload
          evt.data = data.payload
          if data.event is "broker:subscription_error"
            @emit 'error', new Error "Subscription error: #{name}"
            process.nextTick ->
              ws.removeEventListener "message", msgListener
          else
            @dispatchEvent data.event, evt

        ws.addEventListener "message", msgListener
      else
        ws.addEventListener "open", onopen

    @emitter.on "authorized", onopen

  once:(eventType, listener, ctx) ->
    wrapper = =>
      listener.apply ctx or @, [].slice.call(arguments)
      @off eventType, wrapper

    @on eventType, wrapper
    return this

  getRE = do ->
    reCache = {}
    (eventType) ->
      return reCache[eventType]  if reCache[eventType]?
      RegExp "^" + eventType.replace(/(#|\*|\.)/g, (match, wildcard) ->
        switch wildcard
          when "#" then "([\\w|\\.]*)"
          when "*" then "(\\w*)"
          when "." then "\\."
      ) + "$"

  dispatchEvent:(event, evt) ->
    @emitter.emit event, evt
    Object.keys(@wildcards).forEach (wildcard) =>
      matchesWildcard = getRE(wildcard).test(event)
      @emitter.emit wildcard, evt  if matchesWildcard

  addWildcardListener:(routingKey, listener) ->
    @wildcards[routingKey] or (@wildcards[routingKey] = [])
    @wildcards[routingKey].push listener

  on:(eventType, listener, ctx) ->
    brokerListener = (eventObj) =>
      listener.call ctx or @, eventObj.data, eventObj.event

    brokerListener.orig = listener
    performTask @, (channelName) =>
      sendWsMessage @ws, "client-bind", channelName, routingKey: eventType  if @fineGrained
      @addWildcardListener eventType  if /#|\*/.test(eventType)
      @emitter.on eventType, brokerListener
      @events[eventType] or (@events[eventType] = [])
      @events[eventType].push brokerListener

    return this

  off:(eventType, listener) ->
    channel = @privateName or @name
    sendWsMessage @ws, "client-unbind", channel, routingKey: eventType  if @fineGrained
    listeners = @events[eventType] or []
    i = 0
    while i < listeners.length
      brokerListener = listeners[i]
      if brokerListener.orig is listener
        process.nextTick =>
          @ws.removeEventListener channel + "." + eventType, brokerListener
          listeners.splice i, 1
        break
      i++

    return this

  emit:(eventType, payload, meta) ->
    
    # Requirement: Client cannot publish to public channel
    return false  unless @isPrivate
    
    # Requirement: Event has to have client- prefix.
    return false  unless eventType.match(/^(client-[\w-@#]*)/)
    performTask @, (channelName) =>
      sendWsMessage @ws, eventType, channelName, {payload, meta}
      true

  # alias these:
  @::bind = @::on
  @::unbind = @::off
  @::trigger = @::emit