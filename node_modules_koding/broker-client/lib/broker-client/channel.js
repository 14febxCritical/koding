'use strict';

var Channel;

module.exports = Channel = (function() {
  var EventEmitter, getRE, performTask, sendWsMessage, _ref;

  EventEmitter = require('microemitter').EventEmitter;

  _ref = require('./util'), sendWsMessage = _ref.sendWsMessage, performTask = _ref.performTask;

  function Channel(ws, name, options) {
    var onopen, _ref1,
      _this = this;
    this.ws = ws;
    this.name = name;
    this.fineGrained = (_ref1 = options != null ? options.fineGrained : void 0) != null ? _ref1 : false;
    this.emitter = new EventEmitter;
    this.events = {};
    this.wildcards = {};
    onopen = function() {
      var msgListener;
      name = _this.privateName || _this.name;
      if (ws.readyState > 0) {
        if (!_this.fineGrained) {
          sendWsMessage(ws, "client-bind", name);
        }
        msgListener = function(e) {
          var data, evt, exchange, payload;
          data = JSON.parse(e.data);
          if (!data.event || !data.exchange) {
            return;
          }
          exchange = name;
          if (data.exchange !== exchange) {
            return;
          }
          evt = {
            type: exchange + "." + data.event,
            event: data.event
          };
          try {
            payload = JSON.parse(data.payload);
          } catch (ex) {
            payload = data.payload;
          } finally {
            data.payload = payload;
          }
          evt.data = data.payload;
          if (data.event === "broker:subscription_error") {
            _this.emit('error', new Error("Subscription error: " + name));
            return process.nextTick(function() {
              return ws.removeEventListener("message", msgListener);
            });
          } else {
            return _this.dispatchEvent(data.event, evt);
          }
        };
        return ws.addEventListener("message", msgListener);
      } else {
        return ws.addEventListener("open", onopen);
      }
    };
    this.emitter.on("authorized", onopen);
  }

  Channel.prototype.once = function(eventType, listener, ctx) {
    var wrapper,
      _this = this;
    wrapper = function() {
      listener.apply(ctx || _this, [].slice.call(arguments));
      return _this.off(eventType, wrapper);
    };
    this.on(eventType, wrapper);
    return this;
  };

  getRE = (function() {
    var reCache;
    reCache = {};
    return function(eventType) {
      if (reCache[eventType] != null) {
        return reCache[eventType];
      }
      return RegExp("^" + eventType.replace(/(#|\*|\.)/g, function(match, wildcard) {
        switch (wildcard) {
          case "#":
            return "([\\w|\\.]*)";
          case "*":
            return "(\\w*)";
          case ".":
            return "\\.";
        }
      }) + "$");
    };
  })();

  Channel.prototype.dispatchEvent = function(event, evt) {
    var _this = this;
    this.emitter.emit(event, evt);
    return Object.keys(this.wildcards).forEach(function(wildcard) {
      var matchesWildcard;
      matchesWildcard = getRE(wildcard).test(event);
      if (matchesWildcard) {
        return _this.emitter.emit(wildcard, evt);
      }
    });
  };

  Channel.prototype.addWildcardListener = function(routingKey, listener) {
    this.wildcards[routingKey] || (this.wildcards[routingKey] = []);
    return this.wildcards[routingKey].push(listener);
  };

  Channel.prototype.on = function(eventType, listener, ctx) {
    var brokerListener,
      _this = this;
    brokerListener = function(eventObj) {
      return listener.call(ctx || _this, eventObj.data, eventObj.event);
    };
    brokerListener.orig = listener;
    performTask(this, function(channelName) {
      if (_this.fineGrained) {
        sendWsMessage(_this.ws, "client-bind", channelName, {
          routingKey: eventType
        });
      }
      if (/#|\*/.test(eventType)) {
        _this.addWildcardListener(eventType);
      }
      _this.emitter.on(eventType, brokerListener);
      _this.events[eventType] || (_this.events[eventType] = []);
      return _this.events[eventType].push(brokerListener);
    });
    return this;
  };

  Channel.prototype.off = function(eventType, listener) {
    var brokerListener, channel, i, listeners,
      _this = this;
    channel = this.privateName || this.name;
    if (this.fineGrained) {
      sendWsMessage(this.ws, "client-unbind", channel, {
        routingKey: eventType
      });
    }
    listeners = this.events[eventType] || [];
    i = 0;
    while (i < listeners.length) {
      brokerListener = listeners[i];
      if (brokerListener.orig === listener) {
        process.nextTick(function() {
          _this.ws.removeEventListener(channel + "." + eventType, brokerListener);
          return listeners.splice(i, 1);
        });
        break;
      }
      i++;
    }
    return this;
  };

  Channel.prototype.emit = function(eventType, payload, meta) {
    var _this = this;
    if (!this.isPrivate) {
      return false;
    }
    if (!eventType.match(/^(client-[\w-@#]*)/)) {
      return false;
    }
    return performTask(this, function(channelName) {
      sendWsMessage(_this.ws, eventType, channelName, {
        payload: payload,
        meta: meta
      });
      return true;
    });
  };

  Channel.prototype.bind = Channel.prototype.on;

  Channel.prototype.unbind = Channel.prototype.off;

  Channel.prototype.trigger = Channel.prototype.emit;

  return Channel;

})();
