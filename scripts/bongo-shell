#!/usr/bin/env coffee
nesh = require('nesh')
argv = require('optimist').argv
# -c config file
# -f eval coffeescript file
# -C run -f file when a bongo model is reloaded
fs = require 'fs'

Bongo    = require 'bongo'
Broker   = require 'broker'
{argv}   = require 'optimist'
{extend} = require 'underscore'
vm = require 'vm'


process.on 'uncaughtException', (err)->
  console.log "!!!!!!!!!!!!!!!!!!!!!!!! uncaughtException !!!!!!!!!!!!!!!!!!"
  console.error err


if argv.c
  KONFIG = require('koding-config-manager').load("main.#{argv.c}")  
else
  KONFIG = require('koding-config-manager').load("main.vagrant")

{mongo, mq, projectRoot, webserver} = KONFIG

mqOptions = extend {}, mq
mqOptions.login = webserver.login  if webserver?.login?
mqOptions.productName = 'koding-webserver'


opts =
  welcome: 'Welcome to koding...'
  prompt: 'bongo> '

nesh.config.load()
nesh.loadLanguage('coffee')

lastHash = ""
repl_ = null

hashFile = (f)->
  crypto = require('crypto')
  shasum = crypto.createHash('sha1')
  shasum.update(fs.readFileSync f)
  return shasum.digest('hex')


codeReload = (f)->
  # dead simple code reloading function
  # we load the bongo model in a new context
  # then get its instance methods, class methods
  # and redefine it on our model instance
  # thank god for dynamic languages
  try
    code = nesh.compile fs.readFileSync f, 'utf-8'
  catch E
    console.log "error while loading code... #{f}"
    console.error E
    return 

  code = """
  mdl = require '#{f}'
  """
  code = nesh.compile code
  sandbox = 
    require: require
    console: console

  delete require.cache[f]
  vm.runInNewContext code, sandbox
  ourModel = bongo.models[sandbox.mdl.name]
  if ourModel?
    # we first update instance methods
    for own key, value of sandbox.mdl.prototype
      if typeof(value) is "function"
        ourModel.prototype[key] = value
    # then update classmethods
    for own key, value of sandbox.mdl
      if typeof(value) is "function"
        ourModel[key] = value
  if argv.C
    loadAndRunFile(argv.f, )


loadAndRunFile = (f)->
  hash = hashFile(argv.f)
  if hash isnt lastHash
    console.log ">>>> fileChanged executing..."
    execFile(argv.f, repl_)
    lastHash = hash


Watcher = require 'koding-watcher'
bongoPlugin =
    name: "bongoplugin"
    description: "Some description here"
    setup: (context, next) ->
      {defaults} = context
      next()

    preStart: (context, next) ->
      {options} = context
      next()

    postStart: (context, next)->
      {repl} = context
      repl_ = repl
      if argv.f
        fs.watch argv.f, (event)->
          loadAndRunFile argv.f

      repl.context.md5 = (value) ->
        crypto.createHash('md5').update(value).digest 'hex'

      repl.context.bongo = bongo
      for i of bongo.models
        repl.context[i] = bongo.models[i]
      console.log "Press enter to start"

      _ = require 'underscore'
      watcher = new Watcher
        groups        :
          bongo      :
            folders   : [projectRoot + '/workers/social/lib/social/models']
            onChange  : (path)->
              console.log "#{path} changed"
              codeReload(path)
      next()

execFile = (f, repl)->
  try
    data = nesh.compile fs.readFileSync f, 'utf-8'
    vm.runInContext data, repl.context
  catch E
    console.error E

startShell = ()->
  nesh.loadPlugin bongoPlugin, (err) ->
    nesh.log.error err if err
    if argv.f
      opts.evalData = nesh.compile fs.readFileSync argv.f, 'utf-8'
    nesh.start opts, (err)->
      if (err)
        nesh.log.error(err)

class BongoWithOnReady extends Bongo

  constructor: (options)->
    @on 'newModel', (m)->
      console.log "loaded model", m

    @on 'ready', ()->
      console.log "Bongo is ready"

    @on 'newInstance', ()->
      # TODO: couldnt find a better solution then 
      # adding timeout. Checked events but this is
      # the only solution to make it work in node v.0.8
      setTimeout ()->
        startShell()
      , 1000
    super(options)

bongo = new BongoWithOnReady {
  mongo
  root: projectRoot
  models: 'workers/social/lib/social/models'
  mq: new Broker mqOptions
  resourceName: webserver.queueName
}


