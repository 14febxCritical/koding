Index: lxc-0.8.0~rc1/src/lxc/attach.c
===================================================================
--- lxc-0.8.0~rc1.orig/src/lxc/attach.c	2013-02-07 14:15:49.000000000 +0000
+++ lxc-0.8.0~rc1/src/lxc/attach.c	2013-02-07 14:16:34.000000000 +0000
@@ -159,7 +159,7 @@
 			ptr2[l] = '\0';
 
 		info->cgroups[i].subsystems = strndup(ptr + 1, ptr2 - (ptr + 1));
-		info->cgroups[i].cgroup = strdup(ptr2 + 1);
+		info->cgroups[i].cgroup = strdup(ptr2 + 1 + 4);
 
 		i++;
 	}
@@ -230,13 +230,7 @@
 int lxc_attach_to_ns(pid_t pid, int which)
 {
 	char path[MAXPATHLEN];
-	/* TODO: we assume that the file in /proc for attaching to user
-	 * namespaces will be called /proc/$pid/ns/usr, in accordance
-	 * with the naming convention of previous namespaces. Once the
-	 * kernel really supports setns() on a user namespace, make sure
-	 * the array here matches the array in the kernel
-	 */
-	static char *ns[] = { "mnt", "pid", "uts", "ipc", "usr", "net" };
+	static char *ns[] = { "mnt", "pid", "uts", "ipc", "user", "net" };
 	static int flags[] = {
 		CLONE_NEWNS, CLONE_NEWPID, CLONE_NEWUTS, CLONE_NEWIPC,
 		CLONE_NEWUSER, CLONE_NEWNET
@@ -262,35 +256,6 @@
 		snprintf(path, MAXPATHLEN, "/proc/%d/ns/%s", pid, ns[i]);
 		fd[i] = open(path, O_RDONLY);
 		if (fd[i] < 0) {
-			/* there is currently no support in the kernel for
-			 * attaching to user namespaces - therefore, we
-			 * ignore the error, if the file does not exist
-			 */
-			if (flags[i] == CLONE_NEWUSER && errno == ENOENT) {
-				if (which != -1) {
-					/* we don't want the error
-					 * message on every full attach,
-					 * so we only show it if the
-					 * user really requested it
-					 * explicitly
-					 */
-					ERROR("Kernel does not support "
-					      "attaching to user "
-					      "namespaces, skipping.");
-				} else {
-					/* but do show it as a debug
-					 * message otherwise, so users
-					 * aren't completely left in the
-					 * dark
-					 */
-					DEBUG("Kernel does not support "
-					      "attaching to user "
-					      "namespaces, skipping.");
-				}
-				fd[i] = -1;
-				continue;
-			}
-
 			saved_errno = errno;
 
 			/* close all already opened files before we return
Index: lxc-0.8.0~rc1/src/lxc/lxc_attach.c
===================================================================
--- lxc-0.8.0~rc1.orig/src/lxc/lxc_attach.c	2013-02-07 14:15:49.000000000 +0000
+++ lxc-0.8.0~rc1/src/lxc/lxc_attach.c	2013-02-07 14:17:22.000000000 +0000
@@ -30,6 +30,9 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/personality.h>
+#include <utmp.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 
 #include "attach.h"
 #include "commands.h"
@@ -49,6 +52,7 @@
 	{"arch", required_argument, 0, 'a'},
 	{"namespaces", required_argument, 0, 's'},
 	{"remount-sys-proc", no_argument, 0, 'R'},
+	{"tty", required_argument, 0, 't'},
 	LXC_COMMON_OPTIONS
 };
 
@@ -56,6 +60,7 @@
 static signed long new_personality = -1;
 static int namespace_flags = -1;
 static int remount_sys_proc = 0;
+static char* tty = 0;
 
 static int my_parser(struct lxc_arguments* args, int c, char* arg)
 {
@@ -76,6 +81,7 @@
 		if (ret)
 			return -1;
 		break;
+	case 't': tty = arg; break;
 	}
 
 	return 0;
@@ -122,6 +128,8 @@
 	struct lxc_handler *handler;
 	uid_t uid;
 	char *curdir;
+	gid_t groups[1] = { 0 };
+	int tty_fd;
 
 	ret = lxc_caps_init();
 	if (ret)
@@ -231,6 +239,33 @@
 			}
 		}
 
+		if (tty != 0) {
+			if((tty_fd = open(tty, O_RDWR)) == 0) {
+				ERROR("opening tty failed: %s", strerror(errno));
+				return -1;
+			}
+
+			if(login_tty(tty_fd) == -1) {
+				ERROR("login_tty failed: %s", strerror(errno));
+				return -1;
+			}
+		}
+
+		if (setuid(0) != 0) {
+			ERROR("could not set user id: ", strerror(errno));
+			return -1;
+		}
+
+		if (setgid(0) != 0) {
+			ERROR("could not set group id: ", strerror(errno));
+			return -1;
+		}
+
+		if (setgroups(1, groups) != 0) {
+			ERROR("could not set groups: ", strerror(errno));
+			return -1;
+		}
+
 		if (curdir && chdir(curdir))
 			WARN("could not change directory to '%s'", curdir);
 
