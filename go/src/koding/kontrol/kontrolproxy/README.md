# Compile & Run

Compile the binary

```
cd kontrolproxy/
go build
```

Start kontrol proxy 

```
./kontrolproxy -c "prod"
```

By default proxy starts with ports http (80) and https (443). You can change
them easily in the main.{config}.coffee files under the section kontrold/proxy


# Usage of Kontrol Proxy

KontrolProxy first tries himself to register to kontrol. After an "updateProxy"
message it fetches all necessary routing configurations from the mongodb and
stores them in the memory. Kontroldaemon and mongodb are necessaries to run
kontrol proxy.

Every single lookup is made on these values. Each request just creates a single
struct and every single function uses pointers to these struct, which basically
makes the proxy very fast. 

* Dynamic configuration

Every worker which has a port can be registered automatically to kontrol proxy
via the kontrol processes wrapper. For example we use webserver and gobroker
for that case. Kontrol adds them to proxy automatically everytime they start.

* RESTful API for configurations

Kontrolproxy has a powerful restful api that lets you directly remove, change,
update or add any resource it uses. For more info look at the kontrolapi readme
please. Below is a simple list of current API calls you can use:

	GET     /proxies"
	POST    /proxies/{proxyname}"
	DELETE  /proxies/{proxyname}"

	GET     /services"
	GET     /services/{username}"
	POST    /services/{username}"
	POST    /services/{username}/{servicename}"
	GET     /services/{username}/{servicename}"
	DELETE  /services/{username}/{servicename}"
	DELETE  /services/{username}/{servicename}/{key}"

	GET     /domains"
	GET     /domains/{domain}"
	POST    /domains/{domain}"
	DELETE  /domains/{domain}"

	GET     /rules"
	GET     /rules/{username}"
	GET     /rules/{username}/{servicename}"
	POST    /rules/{username}/{servicename}"

* Load balancing via round-robin

Each host is defined by their `servicename` and `key`. You can add several
hosts to a single `key`. If kontrolproxy detects that it has more than one host
it will use round-robin balancing between your servers. The only exception for this is the 'broker' process. Round-robin for broker is disabled.

* SSL support

Kontrolproxy has support for SSL. It looks for the files `cert.pem` and
`key.pem` in the same directory it was executed. If it finds both files and the
files are correct it starts a seperate server which listens to https requests.

* Websocket support

Kontrolproxy has support for websocket. It automatically detects it and uses
hijacking for to reach the underlying tcp connection.

* Stored configuration on MongoDB instance

All the configuration is stored in a mongodb instance. However lookups are made
on a loaded variable in the memory. Kontrolproxy loads the configuration only
everytime if a configurations has been changed. This is made whenever it
receives a 'updateProxy' message from kontrol. Therefore it is quite fast
because it is not doing any db lookup. It only make db lookup for VM IP's (to
map foo.kd.io -> VM IP)

* Builtin firewall

Kontrolproxy has `rules` to support basic firewalling for certain rules.
Currently you can filter visits by IP regex and Countries. Each rule can be
either a whitelist or a blacklist. 

It is based on waterfall criterias. It first looks for the IP rule and then to
the Country rule. That means if the IP rule doesn't satisfy the incoming
request, than the validator tries to match it with the Country rule. If the
request country matches with the country validator than the user/client is
either blocked (if blacklist mode is used) or is allowd (if whitelist mode is
used)

* HTTP proxy over RabbitMq (experimental)

This is an experimental feature that proxy the incomnig HTTP request trough
RabbitMq to a RabbitMq client that sits on a remote host. They communicate
trough a qunique id which is generated by the koding.com website. There is
still work here to be done.



# Improvements

* Fallback mechanism for death servers (not supported yet)
* custom HTML error pages (i.e. for death backends)
* wildcard support for fronted domains
* improve routing table for paths (example.com/)
* add random balancing and weighted round-robin


