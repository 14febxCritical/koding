// package kodingkey provides functions for generating koding.key
// and heplers for conversions.
package kodingkey

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"io"
	"io/ioutil"
	"strings"
)

// Length of the koding key bytes.
// Must be multiple of 6 to not create padding in string representation.
const BytesLength = 48

// Number of characters in a koding key when converted to string.
// We are using base64 conversion and it uses 6/8 of the ASCII table,
// that's the reason of this calculation.
const StringLength = BytesLength * 8 / 6

var Encoding *base64.Encoding

func init() {
	Encoding = base64.URLEncoding
}

// KodingKey is a byte representation of a koding.key file
// generated by "kd register" command.
type KodingKey []byte

// NewKodingKey returns a new random generated KodingKey of length "BytesLength".
func NewKodingKey() (KodingKey, error) {
	key := make(KodingKey, BytesLength)

	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		return nil, err
	}

	return key, nil
}

func FromString(s string) (KodingKey, error) {
	s = strings.TrimSpace(s)

	if len(s) == 0 {
		return nil, errors.New("Zero length Koding Key")
	}

	return Encoding.DecodeString(s)
}

func FromFile(path string) (KodingKey, error) {
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	return FromString(string(data))
}

func (k KodingKey) String() string {
	return Encoding.EncodeToString(k)
}

func (k KodingKey) Bytes32() []byte {
	h := sha256.New()
	h.Write(k)
	return h.Sum(nil)
}
