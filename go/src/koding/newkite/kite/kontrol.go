package kite

import (
	"errors"
	"fmt"
	"koding/newkite/protocol"
	"net"
	"net/url"
	"sync"
	"time"

	"github.com/dgrijalva/jwt-go"
)

var ErrNoKitesAvailable = errors.New("no kites availabile")

const registerKontrolRetryDuration = time.Minute

func (k *Kite) keepRegisteredToKontrol(urls chan *url.URL) {
	for k.URL.URL = range urls {
		for {
			err := k.Kontrol.Register()
			if err != nil {
				k.Log.Fatalf("Cannot register to Kontrol: %s", err)
				time.Sleep(registerKontrolRetryDuration)
			}

			// Registered to Kontrol.
			break
		}
	}
}

// Kontrol embeds RemoteKite which has additional special helper methods.
type Kontrol struct {
	*RemoteKite

	// used for synchronizing methods that needs to be called after
	// successful connection.
	readyConnected chan bool

	// used for synchronizing other methods.
	// if kite.RegisterToKontrol is true,
	// then we are ready after register,
	// else we are ready after connect.
	ready     chan bool
	onceReady sync.Once
}

// NewKontrol returns a pointer to new Kontrol instance.
func (k *Kite) NewKontrol(kontrolURL *url.URL) *Kontrol {
	// Only the address is required to connect Kontrol
	kite := protocol.Kite{
		Name: "kontrol", // for logging purposes
		URL:  protocol.KiteURL{kontrolURL},
	}

	auth := Authentication{
		Type: "kodingKey",
		Key:  k.KodingKey,
	}

	remoteKite := k.NewRemoteKite(kite, auth)
	remoteKite.client.Reconnect = true

	kontrol := &Kontrol{
		RemoteKite:     remoteKite,
		readyConnected: make(chan bool),
		ready:          make(chan bool),
	}

	var once sync.Once

	remoteKite.OnConnect(func() {
		k.Log.Info("Connected to Kontrol ")

		// signal all other methods that are listening on this channel, that we
		// are ready.
		once.Do(func() {
			close(kontrol.readyConnected)
			if !k.RegisterToKontrol {
				close(kontrol.ready)
			}
		})
	})

	remoteKite.OnDisconnect(func() {
		k.Log.Warning("Disconnected from Kontrol. I will retry in background...")
	})

	return kontrol
}

// Register registers current Kite to Kontrol. After registration other Kites
// can find it via GetKites() method.
func (k *Kontrol) Register() error {
	<-k.readyConnected

	response, err := k.RemoteKite.Tell("register")
	if err != nil {
		return err
	}

	var rr protocol.RegisterResult
	err = response.Unmarshal(&rr)
	if err != nil {
		return err
	}

	switch rr.Result {
	case protocol.AllowKite:
		kite := &k.localKite.Kite

		// we know now which user that is after authentication
		kite.Username = rr.Username

		// Set the correct PublicIP if left empty in options.
		ip, port, _ := net.SplitHostPort(kite.URL.Host)
		if ip == "" {
			kite.URL.Host = net.JoinHostPort(rr.PublicIP, port)
		}

		k.Log.Info("Registered to Kontrol with URL: %s ID: %s", kite.URL.String(), kite.ID)
		k.onceReady.Do(func() { close(k.ready) })
	case protocol.RejectKite:
		return errors.New("Kite rejected")
	default:
		return fmt.Errorf("Invalid result: %s", rr.Result)
	}

	return nil
}

// WatchKites watches for Kites that matches the query. The onEvent functions
// is called for current kites and every new kite event.
func (k *Kontrol) WatchKites(query protocol.KontrolQuery, onEvent func(*protocol.KiteEvent)) error {
	<-k.ready

	queueEvents := func(r *Request) {
		var event protocol.KiteEvent
		err := r.Args.MustSliceOfLength(1)[0].Unmarshal(&event)
		if err != nil {
			k.Log.Error(err.Error())
			return
		}

		onEvent(&event)
	}

	args := []interface{}{query, Callback(queueEvents)}
	remoteKites, err := k.getKites(args...)
	if err != nil && err != ErrNoKitesAvailable {
		return err // return only when something really happened
	}

	// also put the current kites to the eventChan.
	for _, remoteKite := range remoteKites {
		event := protocol.KiteEvent{
			Action: protocol.Register,
			Kite:   remoteKite.Kite,
			Token:  remoteKite.Authentication.Key,
		}

		onEvent(&event)
	}

	return nil
}

// GetKites returns the list of Kites matching the query. The returned list
// contains ready to connect RemoteKite instances. The caller must connect
// with RemoteKite.Dial() before using each Kite. An error is returned when no
// kites are available.
func (k *Kontrol) GetKites(query protocol.KontrolQuery) ([]*RemoteKite, error) {
	return k.getKites(query)
}

// used internally for GetKites() and WatchKites()
func (k *Kontrol) getKites(args ...interface{}) ([]*RemoteKite, error) {
	<-k.ready

	response, err := k.RemoteKite.Tell("getKites", args...)
	if err != nil {
		return nil, err
	}

	var kites []protocol.KiteWithToken
	err = response.Unmarshal(&kites)
	if err != nil {
		return nil, err
	}

	if len(kites) == 0 {
		return nil, ErrNoKitesAvailable
	}

	remoteKites := make([]*RemoteKite, len(kites))
	for i, kite := range kites {
		token, err := jwt.Parse(kite.Token, k.localKite.getRSAKey)
		if err != nil {
			return nil, err
		}

		exp := time.Unix(int64(token.Claims["exp"].(float64)), 0).UTC()
		auth := Authentication{
			Type:       "token",
			Key:        kite.Token,
			validUntil: &exp,
		}

		remoteKites[i] = k.localKite.NewRemoteKite(kite.Kite, auth)
	}

	return remoteKites, nil
}

// GetToken is used to get a new token for a single Kite.
func (k *Kontrol) GetToken(kite *protocol.Kite) (string, error) {
	<-k.ready

	result, err := k.RemoteKite.Tell("getToken", kite)
	if err != nil {
		return "", err
	}

	var tkn string
	err = result.Unmarshal(&tkn)
	if err != nil {
		return "", err
	}

	return tkn, nil
}

// Public key of Koding.com's Kontrol Kite.
var kodingKontrolPub = []byte{
	0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
	0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d,
	0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x49, 0x6a, 0x41, 0x4e, 0x42,
	0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
	0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4d,
	0x49, 0x49, 0x42, 0x43, 0x67, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41, 0x33,
	0x52, 0x58, 0x4e, 0x46, 0x4a, 0x33, 0x57, 0x6a, 0x68, 0x63, 0x68, 0x59,
	0x48, 0x75, 0x2b, 0x6b, 0x55, 0x79, 0x6c, 0x0a, 0x6c, 0x41, 0x57, 0x31,
	0x2f, 0x41, 0x7a, 0x36, 0x45, 0x77, 0x5a, 0x58, 0x63, 0x36, 0x43, 0x77,
	0x34, 0x61, 0x51, 0x70, 0x56, 0x6e, 0x61, 0x2b, 0x4d, 0x53, 0x55, 0x78,
	0x4e, 0x66, 0x63, 0x37, 0x30, 0x53, 0x66, 0x46, 0x47, 0x6f, 0x70, 0x6e,
	0x67, 0x63, 0x76, 0x75, 0x53, 0x36, 0x4b, 0x75, 0x4f, 0x61, 0x71, 0x73,
	0x79, 0x62, 0x63, 0x54, 0x58, 0x4e, 0x73, 0x63, 0x2b, 0x71, 0x54, 0x48,
	0x0a, 0x46, 0x7a, 0x79, 0x46, 0x75, 0x75, 0x6a, 0x4e, 0x76, 0x2f, 0x35,
	0x39, 0x63, 0x77, 0x33, 0x43, 0x76, 0x68, 0x36, 0x52, 0x6e, 0x38, 0x34,
	0x36, 0x4c, 0x74, 0x47, 0x68, 0x53, 0x45, 0x57, 0x47, 0x6f, 0x59, 0x42,
	0x51, 0x4f, 0x58, 0x4e, 0x32, 0x58, 0x6e, 0x2f, 0x41, 0x38, 0x4f, 0x4c,
	0x76, 0x78, 0x66, 0x39, 0x4a, 0x66, 0x78, 0x6c, 0x30, 0x6e, 0x58, 0x76,
	0x6c, 0x6d, 0x67, 0x30, 0x47, 0x0a, 0x42, 0x34, 0x61, 0x66, 0x44, 0x57,
	0x4c, 0x48, 0x61, 0x72, 0x44, 0x61, 0x74, 0x63, 0x2f, 0x6e, 0x46, 0x58,
	0x71, 0x57, 0x68, 0x79, 0x5a, 0x68, 0x72, 0x2f, 0x4c, 0x45, 0x39, 0x77,
	0x5a, 0x50, 0x49, 0x58, 0x6d, 0x6b, 0x6b, 0x6f, 0x58, 0x33, 0x49, 0x72,
	0x48, 0x78, 0x4b, 0x4b, 0x53, 0x48, 0x7a, 0x49, 0x70, 0x62, 0x46, 0x46,
	0x2b, 0x67, 0x69, 0x6f, 0x45, 0x54, 0x4d, 0x4b, 0x50, 0x69, 0x0a, 0x64,
	0x4d, 0x6e, 0x6f, 0x31, 0x59, 0x30, 0x67, 0x76, 0x50, 0x4e, 0x59, 0x6b,
	0x6e, 0x37, 0x4c, 0x55, 0x4b, 0x7a, 0x50, 0x46, 0x73, 0x43, 0x4b, 0x41,
	0x6d, 0x4c, 0x55, 0x37, 0x4d, 0x36, 0x75, 0x48, 0x44, 0x67, 0x45, 0x54,
	0x34, 0x6a, 0x6e, 0x52, 0x51, 0x71, 0x43, 0x4c, 0x4f, 0x49, 0x79, 0x78,
	0x57, 0x39, 0x59, 0x45, 0x63, 0x48, 0x56, 0x67, 0x4d, 0x4d, 0x6f, 0x6e,
	0x36, 0x51, 0x6c, 0x0a, 0x41, 0x72, 0x72, 0x76, 0x64, 0x58, 0x70, 0x55,
	0x70, 0x4d, 0x41, 0x67, 0x35, 0x69, 0x6a, 0x68, 0x46, 0x39, 0x37, 0x54,
	0x4a, 0x70, 0x79, 0x6e, 0x37, 0x6e, 0x35, 0x53, 0x6a, 0x4c, 0x6b, 0x70,
	0x53, 0x42, 0x41, 0x6a, 0x2f, 0x68, 0x59, 0x73, 0x61, 0x41, 0x54, 0x63,
	0x59, 0x62, 0x45, 0x76, 0x49, 0x42, 0x44, 0x39, 0x58, 0x44, 0x38, 0x72,
	0x63, 0x50, 0x44, 0x77, 0x79, 0x46, 0x67, 0x37, 0x0a, 0x48, 0x51, 0x49,
	0x44, 0x41, 0x51, 0x41, 0x42, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45,
	0x4e, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45,
	0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a,
}
