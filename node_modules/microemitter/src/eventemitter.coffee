class EventEmitter
  idKey = 'ಠ_ಠ'
  
  @listeners = {}
  @targets = {}
  
  @off =(listenerId)->
    ###
    Note: @off, but no symmetrical "@on".  This is by design.
      One shouldn't add event listeners directly.  These static
      collections are maintained so that the listeners may be
      garbage collected and removed from the emitter's record.
      To that end, @off provides a handy interface.
    ###
    delete @listeners[listenerId]
    delete @targets[listenerId]
    return @
  
  defineProperty = Object.defineProperty ||
    (obj, prop, {value})-> obj[prop] = value

  createId = do -> counter = 0; -> counter++

  constructor:(options={})->
    defineProperty( @, idKey,
      value: "#{Math.round Math.random() * 1e9}"
    )
    defineProperty( @, '_events'
      value         : {}
      writable      : yes
    )

  on:(evt, listener)->
    listeners = @_events[evt] or= {}
    if @[idKey] of listener
      lid = listener[@[idKey]]
    else
      lid = do createId
      defineProperty( listener, @[idKey],
        value: lid
      )
    
    EventEmitter.listeners[lid] = \
    listeners[lid] = listener
    
    EventEmitter.targets[lid] = @
    
    return lid

  when:-> # TODO: implement

  off:(evt, listener)->
    switch arguments.length
      when 0 then @_events = {}
      when 1 then @_events[evt] = {}
      else
        listeners = @_events[evt]
        listenerId = listener[@[idKey]]
        delete listeners[listenerId]
        EventEmitter.off listenerId
    return @

  emit:(evt, rest...)->
    listeners = @_events[evt]
    listener.call @, rest... for own id, listener of listeners
    return @

if define?.amd?
  define -> EventEmitter
else
  @['EventEmitter'] = EventEmitter   # export as a string to play nice with Google Closure Compiler
