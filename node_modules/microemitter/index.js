(function() {
  var EventEmitter,
    __slice = Array.prototype.slice,
    __hasProp = Object.prototype.hasOwnProperty;

  EventEmitter = (function() {
    var createId, defineProperty, idKey, mixin;

    idKey = 'ಠ_ಠ';

    EventEmitter.listeners = {};

    EventEmitter.targets = {};

    EventEmitter.off = function(listenerId) {
      /*
          Note: @off, but no symmetrical "@on".  This is by design.
            One shouldn't add event listeners directly.  These static
            collections are maintained so that the listeners may be
            garbage collected and removed from the emitter's record.
            To that end, @off provides a handy interface.
      */      delete this.listeners[listenerId];
      delete this.targets[listenerId];
      return this;
    };

    defineProperty = Object.defineProperty || function(obj, prop, _arg) {
      var value;
      value = _arg.value;
      return obj[prop] = value;
    };

    createId = (function() {
      var counter;
      counter = 0;
      return function() {
        return counter++;
      };
    })();

    mixin = function(obj) {
      var prop, prot, _results;
      prot = EventEmitter.prototype;
      _results = [];
      for (prop in prot) {
        _results.push(obj[prop] = prot[prop]);
      }
      return _results;
    };

    function EventEmitter(obj) {
      if (obj != null) {
        mixin(obj);
      } else {
        obj = this;
      }
      defineProperty(obj, idKey, {
        value: "" + (Math.round(Math.random() * 1e9))
      });
      defineProperty(obj, '_events', {
        value: {},
        writable: true
      });
    }

    EventEmitter.prototype.on = function(evt, listener) {
      var lid, listeners, _base;
      listeners = (_base = this._events)[evt] || (_base[evt] = {});
      if (this[idKey] in listener) {
        lid = listener[this[idKey]];
      } else {
        lid = createId();
        defineProperty(listener, this[idKey], {
          value: lid
        });
      }
      EventEmitter.listeners[lid] = listeners[lid] = listener;
      EventEmitter.targets[lid] = this;
      return lid;
    };

    EventEmitter.prototype.once = function(evt, listener) {
      var wrappedListener,
        _this = this;
      wrappedListener = function() {
        var rest;
        rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.off(evt, wrappedListener);
        return listener.apply(_this, rest);
      };
      return this.on(evt, wrappedListener);
    };

    EventEmitter.prototype.when = function() {};

    EventEmitter.prototype.off = function(evt, listener) {
      var listenerId, listeners;
      switch (arguments.length) {
        case 0:
          this._events = {};
          break;
        case 1:
          this._events[evt] = {};
          break;
        default:
          listeners = this._events[evt];
          listenerId = listener[this[idKey]];
          delete listeners[listenerId];
          EventEmitter.off(listenerId);
      }
      return this;
    };

    EventEmitter.prototype.emit = function() {
      var evt, id, listener, listeners, rest;
      evt = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      listeners = this._events[evt];
      for (id in listeners) {
        if (!__hasProp.call(listeners, id)) continue;
        listener = listeners[id];
        listener.call.apply(listener, [this].concat(__slice.call(rest)));
      }
      return this;
    };

    return EventEmitter;

  })();

  if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
    define(function() {
      return EventEmitter;
    });
  } else {
    this['EventEmitter'] = EventEmitter;
  }

}).call(this);
