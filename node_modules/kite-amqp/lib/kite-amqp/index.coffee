amqp = require 'amqp'
{Scrubber, Store} = require 'koding-dnode-protocol'
{parse, stringify} = JSON
Object.defineProperty Object::, 'throwError', value:(it)-> throw it

module.exports = class Kite
  
  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @channels = {}
    @requesters = {}
  
  handleError:(replyTo, err)->
    @connection.publish replyTo, stringify(error: err.message),
      contentType: 'application/json'
  
  handleRequest:(message, kiteConfig, {headers, deliveryInfo})->
    exchangeName = @getExchangeName()
    {channels, requesters} = @
    try
      scrubbed = parse message.data
      requesterId = scrubbed.username
    catch err then @handleError deliveryInfo.replyTo, err
    @unscrubMessage requesterId, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      {toDo, withArgs, callbackId} = data
      if toDo isnt '_disconnect' and not requesters[requesterId]?
        @api._connect? {requesterId}
        requesters[requesterId] = {}
      switch toDo
        when '_disconnect'
          if requesters[requesterId]?
            Object.keys(requesters[requesterId]).forEach (channelId)->
              delete channels[channelId] if --channels[channelId] is 0
            @api._disconnect? {
              requesterId
              channels: requesters[requesterId]
            }
            delete requesters[requesterId]
            @handleResponse deliveryInfo.replyTo, callbackId, {
              connectionCount: channels[channelId]
            }
          else
            @handleError deliveryInfo.replyTo, {
              message: "Disconnect error: #{requesterId}"
            }
        when '_ping' then @handleResponse deliveryInfo.replyTo, callbackId, 1
        else
          if @api.propertyIsEnumerable(toDo) and 'function' is typeof @api[toDo]
            channels[exchangeName] ?= 0
            channels[exchangeName] += 1
            requesters[requesterId][exchangeName] = yes
            withArgs.requesterId = requesterId
            @api[toDo]? withArgs, (err, msg)=>
              if channels[exchangeName]?
                @handleResponse deliveryInfo.replyTo, callbackId, arguments
          else @handleError deliveryInfo.replyTo, {
            message: "No such method! #{toDo}"
          }
  
  unscrubMessage:(requesterId, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        unless @remoteStore.has(requesterId+callbackId)
          @remoteStore.add requesterId+callbackId, (args...)=>
            @handleResponse @getExchangeName(), callbackId, args
        @remoteStore.get requesterId+callbackId
      callback unscrubbed
  
  handleResponse:(exchangeName, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      @connection.publish exchangeName, stringify(out)
  
  getQueueName:-> "kite-#{@kiteName}"
  
  getExchangeName:-> "#{@getQueueName()}-exchange"
  
  getExchangeOptions:->
    type        : 'topic'
    autoDelete  : yes
    durable     : yes
  
  registerSelf:(config)->
    {host, port, protocol, username, password} = config.amqp
    port      ?= 5672
    protocol  ?= 'amqp:'
    options   = {host, port, protocol}
    # SASL authentication credentials for connecting to RabbitMQ backend:
    options.username = username if username?
    options.password = password if password?
    @connection = amqp.createConnection options
    @connection.on 'ready', =>
      @connection.exchange @getExchangeName(), @getExchangeOptions(), (exchange)=>
        @connection.queue @getQueueName(), (queue)=>
          queue.bind exchange, '#'
          queue.on 'queueBindOk', =>
            queue.subscribe (message, headers, deliveryInfo)=>
              @handleRequest message, config, {headers, deliveryInfo}
  
  writePid:(pidPath)->
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"
  
  run:(config)->
    {pidPath, logPath, host, username, password, @apiUri} = config
    @writePid pidPath
    @registerSelf config
