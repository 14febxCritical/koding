var Kite, Scrubber, Store, amqp, parse, stringify, _ref,
  __slice = [].slice;

amqp = require('amqp');

_ref = require('koding-dnode-protocol'), Scrubber = _ref.Scrubber, Store = _ref.Store;

parse = JSON.parse, stringify = JSON.stringify;

Object.defineProperty(Object.prototype, 'throwError', {
  value: function(it) {
    throw it;
  }
});

module.exports = Kite = (function() {

  function Kite(kiteName, api) {
    var _ref1;
    this.kiteName = kiteName;
    this.api = api;
    if (!api) {
      _ref1 = [kiteName, api], this.api = _ref1[0], this.kiteName = _ref1[1];
    }
    this.kiteName || (this.kiteName = 'unknown');
    this.localStore = new Store;
    this.remoteStore = new Store;
    this.channels = {};
    this.requesters = {};
  }

  Kite.prototype.handleError = function(replyTo, err) {
    return this.connection.publish(replyTo, stringify({
      error: err.message
    }), {
      contentType: 'application/json'
    });
  };

  Kite.prototype.handleRequest = function(message, kiteConfig, _arg) {
    var channels, deliveryInfo, exchangeName, headers, requesterId, requesters, scrubbed,
      _this = this;
    headers = _arg.headers, deliveryInfo = _arg.deliveryInfo;
    exchangeName = this.getExchangeName();
    channels = this.channels, requesters = this.requesters;
    try {
      scrubbed = parse(message.data);
      requesterId = scrubbed.username;
    } catch (err) {
      this.handleError(deliveryInfo.replyTo, err);
    }
    return this.unscrubMessage(requesterId, scrubbed, function(unscrubbed) {
      var callback, callbackId, data, toDo, withArgs, _base, _base1, _base2, _ref1;
      data = unscrubbed[0], callback = unscrubbed[1];
      toDo = data.toDo, withArgs = data.withArgs, callbackId = data.callbackId;
      if (toDo !== '_disconnect' && !(requesters[requesterId] != null)) {
        if (typeof (_base = _this.api)._connect === "function") {
          _base._connect({
            requesterId: requesterId
          });
        }
        requesters[requesterId] = {};
      }
      switch (toDo) {
        case '_disconnect':
          if (requesters[requesterId] != null) {
            Object.keys(requesters[requesterId]).forEach(function(channelId) {
              if (--channels[channelId] === 0) {
                return delete channels[channelId];
              }
            });
            if (typeof (_base1 = _this.api)._disconnect === "function") {
              _base1._disconnect({
                requesterId: requesterId,
                channels: requesters[requesterId]
              });
            }
            delete requesters[requesterId];
            return _this.handleResponse(deliveryInfo.replyTo, callbackId, {
              connectionCount: channels[channelId]
            });
          } else {
            return _this.handleError(deliveryInfo.replyTo, {
              message: "Disconnect error: " + requesterId
            });
          }
          break;
        case '_ping':
          return _this.handleResponse(deliveryInfo.replyTo, callbackId, 1);
        default:
          if (_this.api.propertyIsEnumerable(toDo) && 'function' === typeof _this.api[toDo]) {
            if ((_ref1 = channels[exchangeName]) == null) {
              channels[exchangeName] = 0;
            }
            channels[exchangeName] += 1;
            requesters[requesterId][exchangeName] = true;
            withArgs.requesterId = requesterId;
            return typeof (_base2 = _this.api)[toDo] === "function" ? _base2[toDo](withArgs, function(err, msg) {
              if (channels[exchangeName] != null) {
                return _this.handleResponse(deliveryInfo.replyTo, callbackId, arguments);
              }
            }) : void 0;
          } else {
            return _this.handleError(deliveryInfo.replyTo, {
              message: "No such method! " + toDo
            });
          }
      }
    });
  };

  Kite.prototype.unscrubMessage = function(requesterId, scrubbed, callback) {
    var scrubber, unscrubbed,
      _this = this;
    if (!((scrubbed["arguments"] != null) && (scrubbed.callbacks != null))) {
      return callback([scrubbed, function() {}]);
    } else {
      scrubber = new Scrubber(this.localStore);
      unscrubbed = scrubber.unscrub(scrubbed, function(callbackId) {
        if (!_this.remoteStore.has(requesterId + callbackId)) {
          _this.remoteStore.add(requesterId + callbackId, function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return _this.handleResponse(_this.getExchangeName(), callbackId, args);
          });
        }
        return _this.remoteStore.get(requesterId + callbackId);
      });
      return callback(unscrubbed);
    }
  };

  Kite.prototype.handleResponse = function(exchangeName, callbackId, args) {
    var scrubber,
      _this = this;
    scrubber = new Scrubber(this.localStore);
    return scrubber.scrub(args, function() {
      var out;
      out = scrubber.toDnodeProtocol();
      out.method = callbackId;
      return _this.connection.publish(exchangeName, stringify(out));
    });
  };

  Kite.prototype.getQueueName = function() {
    return "kite-" + this.kiteName;
  };

  Kite.prototype.getExchangeName = function() {
    return "" + (this.getQueueName()) + "-exchange";
  };

  Kite.prototype.getExchangeOptions = function() {
    return {
      type: 'topic',
      autoDelete: true,
      durable: true
    };
  };

  Kite.prototype.registerSelf = function(config) {
    var host, options, password, port, protocol, username, _ref1,
      _this = this;
    _ref1 = config.amqp, host = _ref1.host, port = _ref1.port, protocol = _ref1.protocol, username = _ref1.username, password = _ref1.password;
    if (port == null) {
      port = 5672;
    }
    if (protocol == null) {
      protocol = 'amqp:';
    }
    options = {
      host: host,
      port: port,
      protocol: protocol
    };
    if (username != null) {
      options.username = username;
    }
    if (password != null) {
      options.password = password;
    }
    this.connection = amqp.createConnection(options);
    return this.connection.on('ready', function() {
      return _this.connection.exchange(_this.getExchangeName(), _this.getExchangeOptions(), function(exchange) {
        return _this.connection.queue(_this.getQueueName(), function(queue) {
          queue.bind(exchange, '#');
          return queue.on('queueBindOk', function() {
            return queue.subscribe(function(message, headers, deliveryInfo) {
              return _this.handleRequest(message, config, {
                headers: headers,
                deliveryInfo: deliveryInfo
              });
            });
          });
        });
      });
    });
  };

  Kite.prototype.writePid = function(pidPath) {
    if (pidPath) {
      return require("fs").writeFile(pidPath, "" + process.pid, function(err) {
        if (err != null) {
          return console.log("[WARN] Can't write pid to " + pidPath + ":  monit can't watch this process. err:" + err.message);
        }
      });
    }
  };

  Kite.prototype.run = function(config) {
    var host, logPath, password, pidPath, username;
    pidPath = config.pidPath, logPath = config.logPath, host = config.host, username = config.username, password = config.password, this.apiUri = config.apiUri;
    this.writePid(pidPath);
    return this.registerSelf(config);
  };

  return Kite;

})();
