/*
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
*/
/*
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
@foo
*/
var bongo, isBrowser;
var __slice = Array.prototype.slice, __hasProp = Object.prototype.hasOwnProperty, __indexOf = Array.prototype.indexOf || function(item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (this[i] === item) return i;
  }
  return -1;
};
isBrowser = 'undefined' != typeof window;
/*
@class: bongo (client)
@description: client-side bongo.
*/
bongo = (function() {
  var EventEmitter, JsPath, Model, ModelLoader, Traverse, api, clientId_, createConstructor, createId, dash, dnode, extend, fetchChannel_, findMyInstance, getCancellableCallback_, getModelLoader, instances_, loading_, race, sequence, slice, stack, updateInstances, wrapAll, wrapArgs, wrapFn, wrapInstanceMethods, wrapStaticMethods, _ref, _ref2, _ref3;
  function bongo() {}
  EventEmitter = require('events').EventEmitter;
  bongo = new EventEmitter;
  Traverse = require('traverse');
  createId = bongo.createId = require('hat');
  dnode = require('koding-dnode');
  bongo.dnodeProtocol = require('koding-dnode-protocol');
  bongo.EventEmitter = EventEmitter;
  Model = bongo.Model = require('./src/model');
  ModelLoader = require('./src/modelloader');
  JsPath = bongo.JsPath = require('./src/jspath');
  slice = [].slice;
  _ref = require('./src/util'), extend = _ref.extend, bongo.asynchronizeOwnMethods = _ref.asynchronizeOwnMethods;
  _ref2 = require('sinkrow'), race = _ref2.race, sequence = _ref2.sequence, dash = _ref2.dash;
  _ref3 = require('sinkrow'), bongo.daisy = _ref3.daisy, bongo.dash = _ref3.dash, bongo.sequence = _ref3.sequence, bongo.race = _ref3.race, bongo.future = _ref3.future;
  bongo.api = {};
  instances_ = {};
  loading_ = {};
  getCancellableCallback_ = function(callback) {
    var cancelled, kallback;
    cancelled = false;
    kallback = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!cancelled) {
        return callback.apply(null, rest);
      }
    };
    kallback.cancel = function() {
      return cancelled = true;
    };
    return kallback;
  };
  fetchChannel_ = function(channelName, callback) {
    var channel;
    callback = getCancellableCallback_(callback);
    channel = this.channel(channelName);
    if (channel) {
      callback(channel, false);
    } else {
      channel = this.subscribe(channelName);
      channel.on('broker:subscription_succeeded', function() {
        console.log('subscription succeeded');
        return callback(channel, true);
      });
    }
    return setTimeout((function() {
      return callback.cancel();
    }), 1000);
  };
  getModelLoader = function(constructor, id) {
    var loader, _base, _name;
    loading_[_name = constructor.name] || (loading_[_name] = {});
    return loader = (_base = loading_[constructor.name])[id] || (_base[id] = new ModelLoader(constructor, id));
  };
  bongo.cacheable = (function() {
    var handleBatch, handleSingle;
    handleSingle = function(constructorName, _id, callback) {
      var constructor, model;
      if ('string' == typeof constructorName) {
        constructor = bongo.api[constructorName];
      } else if ('function' === typeof constructorName) {
        constructor = constructorName;
      }
      if (!constructor) {
        callback(new Error("Unknown type " + constructorName));
      } else {
        constructor.cache || (constructor.cache = {});
        if (model = constructor.cache[_id]) {
          callback(null, model);
        } else {
          getModelLoader(constructor, _id).load(function(err, model) {
            constructor.cache[_id] = model;
            return callback(err, model);
          });
        }
      }
    };
    handleBatch = function(batch, callback) {
      var models, queue;
      models = [];
      queue = batch.map(function(single, i) {
        return function() {
          var constructorName, id, name, type;
          name = single.name, type = single.type, constructorName = single.constructorName, id = single.id;
          return handleSingle(type || name || constructorName, id, function(err, model) {
            if (err) {
              return callback(err);
            } else {
              models[i] = model;
              return queue.fin();
            }
          });
        };
      });
      return dash(queue, function() {
        return callback(null, models);
      });
    };
    return function() {
      switch (arguments.length) {
        case 2:
          return handleBatch.apply(this, arguments);
        case 3:
          return handleSingle.apply(this, arguments);
        default:
          throw new Error('bongo.cacheable expects either 2 or 3 arguments.');
      }
    };
  })();
  bongo.getInstances = function() {
    return instances_;
  };
  bongo.getInstancesById = function(id) {
    return instances_[id];
  };
  bongo.addReferences = function() {
    var instance, instances, _i, _len, _name, _results;
    instances = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _results = [];
    for (_i = 0, _len = instances.length; _i < _len; _i++) {
      instance = instances[_i];
      if (!('_id' in instance)) {
        throw new Error("Can't add a reference to an instance that has no id!");
      }
      instances_[_name = instance._id] || (instances_[_name] = {});
      _results.push(instances_[instance._id][instance.bongo_.instanceId] = instance);
    }
    return _results;
  };
  if (!isBrowser) {
    bongo.browserPath = "" + __dirname + "/browser";
  }
  updateInstances = function(data) {
    var constructor, instance, instanceId, instances, prop, val, _results;
    constructor = this;
    instances = bongo.getInstancesById(data._id);
    _results = [];
    for (instanceId in instances) {
      if (!__hasProp.call(instances, instanceId)) continue;
      instance = instances[instanceId];
      for (prop in data) {
        if (!__hasProp.call(data, prop)) continue;
        val = data[prop];
        instance[prop] = val;
      }
      _results.push(instance.emit('update'));
    }
    return _results;
  };
  findMyInstance = (function() {
    var hasEncoder;
    hasEncoder = 'function' === typeof (typeof Encoder !== "undefined" && Encoder !== null ? Encoder.htmlEncode : void 0);
    return function(data, extend) {
      var instance, instanceId, instances, model;
      instances = bongo.getInstancesById(data._id);
      for (instanceId in instances) {
        if (!__hasProp.call(instances, instanceId)) continue;
        instance = instances[instanceId];
        if (instanceId === data.bongo_.instanceId) {
          new Traverse(data).forEach(function(node) {
            if (!this.isLeaf && this.path.length) {
              if (node.bongo_ != null) {
                JsPath.setAt(instance, this.path, findMyInstance(node));
              } else {
                JsPath.setAt(instance, this.path, node);
              }
            }
          });
          return instance;
        }
      }
      data = !hasEncoder ? data : new Traverse(data).forEach(function(node) {
        var _ref4;
        if ('string' === typeof node) {
          return this.update(Encoder.htmlEncode(node));
        } else if (this.path.length && !this.isLeaf && ((_ref4 = node.bongo_) != null ? _ref4.constructorName : void 0)) {
          return this.update(findMyInstance(node), true);
        }
      });
      return model = new bongo.api[data.bongo_.constructorName](data);
    };
  })();
  createConstructor = function(name, staticMethods, instanceMethods, options) {
    var constructor, ctor, option, prop;
    constructor = Function("return function " + name + " () {\n  this.init.apply(this, [].slice.call(arguments));\n  this.bongo_.constructorName = '" + name + "';\n}")();
    wrapStaticMethods(constructor, staticMethods);
    ctor = function() {
      this.constructor = constructor;
    };
    ctor.prototype = Model.prototype;
    for (prop in Model) {
      if (!__hasProp.call(Model, prop)) continue;
      constructor[prop] = Model[prop];
    }
    constructor.prototype = new ctor;
    constructor.__super__ = Model.prototype;
    for (option in options) {
      constructor[option] = options[option];
    }
    wrapInstanceMethods(constructor, instanceMethods);
    return constructor;
  };
  wrapStaticMethods = (function() {
    var optimizeThese;
    optimizeThese = ['on', 'off'];
    return function(constructor, staticMethods) {
      var method, methodName, _fn;
      _fn = function(methodName, method) {
        if (__indexOf.call(optimizeThese, methodName) >= 0) {
          methodName += '_';
        }
        constructor[methodName] = function(err, res) {
          var args, channel, channelId;
          args = slice.call(arguments);
          wrapAll(args);
          if (method.useMQ) {
            channelId = createId();
            channel = bongo.mq.subscribe(channelId);
            return channel.on('broker:subscription_succeeded', function() {
              return method.apply(constructor, [channelId].concat(args));
            });
          } else {
            return method.apply(constructor, [null].concat(args));
          }
        };
        return constructor[methodName].useMQ = method.useMQ;
      };
      for (methodName in staticMethods) {
        if (!__hasProp.call(staticMethods, methodName)) continue;
        method = staticMethods[methodName];
        _fn(methodName, method);
      }
    };
  })();
  wrapInstanceMethods = (function() {
    var optimizeThese;
    optimizeThese = ['on', 'addListener', 'off', 'removeListener', 'save'];
    return function(constructor, instanceMethods) {
      var method, methodName, _fn;
      _fn = function(methodName, method) {
        if (__indexOf.call(optimizeThese, methodName) >= 0) {
          methodName += '_';
        }
        constructor.prototype[methodName] = function() {
          var args, channel, channelId, id;
          args = slice.call(arguments);
          wrapAll(args);
          id = this.getId();
          if (method.useMQ) {
            channelId = 'private-' + createId();
            channel = bongo.mq.subscribe(channelId);
            channel.on('broker:subscription_succeeded', function() {
              return method.apply(null, [channelId, id, (!id ? this : void 0)].concat(__slice.call(args)));
            });
          } else {
            method.apply(null, [null, id, (!id ? this : void 0)].concat(__slice.call(args)));
          }
          return this;
        };
        return constructor.prototype[methodName].useMQ = method.useMQ;
      };
      for (methodName in instanceMethods) {
        if (!__hasProp.call(instanceMethods, methodName)) continue;
        method = instanceMethods[methodName];
        _fn(methodName, method);
      }
    };
  })();
  wrapAll = function(obj) {
    new Traverse(obj).forEach(function(node) {
      if ('function' === typeof node) {
        return this.update(wrapFn(node));
      }
    });
  };
  bongo.reviveFromString = function(str, callback) {
    var instances, separator, strPaylod, strProtocol;
    separator = str.indexOf(':');
    strProtocol = str.substr(0, separator);
    strPaylod = str.substr(separator + 1);
    try {
      switch (strProtocol) {
        case 'json':
          return callback(null, findMyInstance(JSON.parse(strPaylod)));
        case 'feed':
          instances = strPaylod.split('\n').map(function(json) {
            return findMyInstance(JSON.parse(json));
          });
          return callback(null, instances);
      }
    } catch (e) {
      return callback(e);
    }
  };
  bongo.reviveFromJSONP = function(instances, callback) {
    return callback(null, instances.map(function(instance) {
      if (instance.snapshot) {
        return findMyInstance(JSON.parse(instance.snapshot));
      } else {
        return console.log(instance);
      }
    }));
  };
  wrapFn = function(fn) {
    return function(err, res) {
      var args, channel;
      if (res != null ? res.__channelId : void 0) {
        channel = bongo.mq.channel(res.__channelId);
        if (channel != null) {
          channel.on('message', fn.bind(null, null));
          channel.on('error', fn.bind(null));
        }
      } else {
        args = slice.call(arguments);
        wrapArgs(args, function(wrappedArgs) {
          return fn.apply(this, wrappedArgs);
        });
      }
      return this;
    };
  };
  wrapArgs = (function() {
    var feedPrefix, jsonPrefix, revive, setAt;
    jsonPrefix = /^json:/;
    feedPrefix = /^feed:/;
    setAt = JsPath.setAt;
    revive = function(node) {
      return findMyInstance(JSON.parse(node.replace(jsonPrefix, '')));
    };
    return function(args, callback) {
      var objectRefs, objects, parseThese, replaceThese;
      parseThese = [];
      replaceThese = [];
      objectRefs = [];
      args = new Traverse(args).map(function(node) {
        var child, i, nodes, _len;
        if ('string' === typeof node) {
          if (jsonPrefix.test(node)) {
            parseThese.push({
              path: this.path,
              node: node
            });
            return this.update(node);
          } else if (feedPrefix.test(node)) {
            nodes = node.replace(feedPrefix, '').split('\n');
            replaceThese.push({
              path: this.path,
              nodes: nodes
            });
            for (i = 0, _len = nodes.length; i < _len; i++) {
              child = nodes[i];
              parseThese.push({
                path: this.path.concat(i),
                node: 'json:' + child
              });
            }
            return this.update(node);
          } else {
            return this.update(node);
          }
        } else {
          if (!this.isLeaf && 'bongo_' in node && 'constructorName' in node.bongo_) {
            if ('ObjectRef' === node.bongo_.constructorName) {
              return objectRefs.push({
                path: this.path,
                node: node
              });
            } else {
              return this.update(findMyInstance(node));
            }
          } else {
            return this.update(node);
          }
        }
      });
      replaceThese.forEach(function(_arg) {
        var node, nodes, path;
        path = _arg.path, nodes = _arg.nodes;
        nodes = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = nodes.length; _i < _len; _i++) {
            node = nodes[_i];
            _results.push(revive(node));
          }
          return _results;
        })();
        return setAt(args, path, nodes);
      });
      parseThese.forEach(function(_arg) {
        var node, path;
        path = _arg.path, node = _arg.node;
        return setAt(args, path, revive(node));
      });
      if (!objectRefs.length) {
        return callback(args);
      }
      objects = [];
      objectRefs.forEach(function(objectRef) {
        return objects.push(function() {
          var constructorName, id, _ref4;
          _ref4 = objectRef.node, constructorName = _ref4.constructorName, id = _ref4.id;
          return bongo.fetchInstance(constructorName, id, function(err, instance) {
            if (err) {
              throw err;
            }
            setAt(args, objectRef.path, instance);
            return objects.fin();
          });
        });
      });
      return dash(objects, function() {
        return wrapArgs(args, function(args) {
          return callback(args);
        });
      });
    };
  })();
  clientId_ = (typeof localStorage !== "undefined" && localStorage !== null ? localStorage.clientId : void 0) ? localStorage.clientId : (clientId_ = createId(), typeof localStorage !== "undefined" && localStorage !== null ? localStorage.clientId = clientId_ : void 0, clientId_);
  api = function(remote, conn) {
    return {
      receiveServerError: function(errMsg) {
        throw new Error("An error was reported by the server: " + errMsg);
      },
      receiveAccessError: function(errMsg) {
        return KD.requireLogin(errMsg);
      },
      fetchClientId: function(callback) {
        return callback(clientId_);
      },
      receiveBroadcast: function(broadcast) {
        return bongo.emit('broadcast', broadcast);
      }
    };
  };
  bongo.connectKite = function(options, callback) {
    var kiteApi, name;
    if (callback == null) {
      callback = function(kite) {
        return kite.emit('ready');
      };
    }
    name = options.name, kiteApi = options.kiteApi;
    kiteApi.bongo_ = {
      name: name
    };
    kiteApi.bongo_.id = clientId_;
    return bongo.connect(options, function(api, conn) {
      var kite;
      kite = new api.Kite(kiteApi);
      return callback(kite, conn, api);
    });
  };
  stack = [];
  bongo.use = function(middleware) {
    stack.push(middleware);
    return this;
  };
  bongo.connect = function(port, callback) {
    var client, _ref4;
    if (!callback) {
      _ref4 = [port, callback], callback = _ref4[0], port = _ref4[1];
    }
    client = dnode(api);
    client.stack = stack;
    client.connect(port, function(remote, conn) {
      bongo.fetchInstance = remote.fetchInstance;
      return remote.fetchApi(function(constructors, globals) {
        var def, instanceMethods, methodName, name, options, rawInstanceMethods, rawStaticMethods, staticMethods, _i, _j, _k, _len, _len2, _len3;
        for (_i = 0, _len = constructors.length; _i < _len; _i++) {
          def = constructors[_i];
          name = def.name, staticMethods = def.staticMethods, instanceMethods = def.instanceMethods, rawStaticMethods = def.rawStaticMethods, rawInstanceMethods = def.rawInstanceMethods, options = def.options;
          for (_j = 0, _len2 = rawStaticMethods.length; _j < _len2; _j++) {
            methodName = rawStaticMethods[_j];
            staticMethods[methodName].useMQ = true;
          }
          for (_k = 0, _len3 = rawInstanceMethods.length; _k < _len3; _k++) {
            methodName = rawInstanceMethods[_k];
            instanceMethods[methodName].useMQ = true;
          }
          bongo.api[name] = createConstructor(name, staticMethods, instanceMethods, options);
        }
        return callback(bongo.api, conn);
      });
    });
    return this;
  };
  if ((typeof window !== "undefined" && window !== null) && (typeof BONGO_MQ !== "undefined" && BONGO_MQ !== null)) {
    bongo.mq = Model.prototype.mq = BONGO_MQ;
    bongo.mq.fetchChannel = fetchChannel_.bind(bongo.mq);
    bongo.mq.updateInstanceChannel = bongo.mq.subscribe('updateInstance');
    Model.wrapArgs = wrapArgs;
    Model.prototype.mixin(require('./src/eventemitter/broker'));
  } else {
    Model.prototype.mixin(require('./src/eventemitter/dnode'));
  }
  return bongo;
})();
/*
@snippet.
@description: export for node, or the browser, depending.
*/
if (!isBrowser && module) {
  module.exports = bongo;
} else {
  if (typeof window !== "undefined" && window !== null) {
    window.bongo = bongo;
  }
}