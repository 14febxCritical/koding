/*
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
*/
/*
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
@foo
*/
var Bongo, EventEmitter, isBrowser;
var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __slice = Array.prototype.slice, __indexOf = Array.prototype.indexOf || function(item) {
  for (var i = 0, l = this.length; i < l; i++) {
    if (this[i] === item) return i;
  }
  return -1;
};
isBrowser = 'undefined' != typeof window;
/*
@class: bongo (client)
@description: client-side bongo.
*/
EventEmitter = require('events').EventEmitter;
Bongo = (function() {
  var JsPath, Model, ModelLoader, Scrubber, Store, Traverse, createBongoName, createId, dash, extend, race, sequence, slice, _ref, _ref2, _ref3;
  __extends(Bongo, EventEmitter);
  Traverse = require('traverse');
  createId = Bongo.createId = require('hat');
  Bongo.dnodeProtocol = require('koding-dnode-protocol');
  _ref = Bongo.dnodeProtocol, Store = _ref.Store, Scrubber = _ref.Scrubber;
  Bongo.EventEmitter = EventEmitter;
  Model = Bongo.Model = require('./src/model');
  ModelLoader = require('./src/modelloader');
  JsPath = Bongo.JsPath = require('./src/jspath');
  slice = [].slice;
  extend = require('./src/util').extend;
  _ref2 = require('sinkrow'), race = _ref2.race, sequence = _ref2.sequence, dash = _ref2.dash;
  _ref3 = require('sinkrow'), Bongo.daisy = _ref3.daisy, Bongo.dash = _ref3.dash, Bongo.sequence = _ref3.sequence, Bongo.race = _ref3.race, Bongo.future = _ref3.future;
  createBongoName = function() {
    return 'bongo.' + createId();
  };
  function Bongo(options) {
    this.mq = options.mq, this.getSessionToken = options.getSessionToken;
    this.bongoName = createBongoName();
    this.channelName = 'private-' + this.bongoName;
    this.localStore = new Store;
    this.remoteStore = new Store;
    this.readyState = 0;
    this.stack = [];
    this.on('newListener', __bind(function(event, listener) {
      if (event === 'ready' && this.readyState === 1) {
        return process.nextTick(__bind(function() {
          this.emit('ready');
          return this.removeAllListeners('ready');
        }, this));
      }
    }, this));
  }
  Bongo.prototype.createRemoteApiShims = function(api) {
    var instance, name, shimmedApi, statik, _ref4;
    shimmedApi = {};
    for (name in api) {
      _ref4 = api[name], statik = _ref4.statik, instance = _ref4.instance;
      shimmedApi[name] = this.createConstructor(name, statik, instance);
    }
    return shimmedApi;
  };
  Bongo.prototype.wrapStaticMethods = (function() {
    var optimizeThese;
    optimizeThese = ['on', 'off'];
    return function(constructor, constructorName, statik) {
      var bongo;
      bongo = this;
      return statik.forEach(function(method) {
        return constructor[method] = function() {
          var rpc;
          rpc = {
            type: 'static',
            constructorName: constructorName,
            method: method
          };
          return bongo.send(rpc, [].slice.call(arguments));
        };
      });
    };
  })();
  Bongo.prototype.wrapInstanceMethods = (function() {
    var optimizeThese;
    optimizeThese = ['on', 'addListener', 'off', 'removeListener', 'save'];
    return function(constructor, constructorName, instance) {
      var bongo;
      bongo = this;
      return instance.forEach(function(method) {
        return constructor.prototype[method] = function() {
          var data, id, rpc;
          id = this.getId();
          if (id == null) {
            data = this.data;
          }
          rpc = {
            type: 'instance',
            constructorName: constructorName,
            method: method,
            id: id,
            data: data
          };
          return bongo.send(rpc, [].slice.call(arguments));
        };
      });
    };
  })();
  Bongo.prototype.createConstructor = function(name, staticMethods, instanceMethods, options) {
    var ctor, konstructor, option, prop;
    konstructor = Function("return function " + name + " () {\n  this.init.apply(this, [].slice.call(arguments));\n  this.bongo_.constructorName = '" + name + "';\n}")();
    this.wrapStaticMethods(konstructor, name, staticMethods);
    ctor = function() {
      this.constructor = konstructor;
    };
    ctor.prototype = Model.prototype;
    for (prop in Model) {
      if (!__hasProp.call(Model, prop)) continue;
      konstructor[prop] = Model[prop];
    }
    konstructor.prototype = new ctor;
    konstructor.__super__ = Model.prototype;
    for (option in options) {
      if (!__hasProp.call(options, option)) continue;
      konstructor[option] = options[option];
    }
    this.wrapInstanceMethods(konstructor, name, instanceMethods);
    return konstructor;
  };
  Bongo.prototype.getInstancesById = function() {};
  Bongo.prototype.getInstanceMethods = function() {
    return ['fetchApi', 'changeLoggedInState'];
  };
  Bongo.prototype.revive = function(obj) {
    var bongo;
    bongo = this;
    return new Traverse(obj).map(function(node) {
      var constructorName, instance, instanceId, konstructor, _ref4;
      if ((node != null ? node.bongo_ : void 0) != null) {
        _ref4 = node.bongo_, constructorName = _ref4.constructorName, instanceId = _ref4.instanceId;
        instance = bongo.getInstancesById(instanceId);
        if (instance != null) {
          return this.update(instance, true);
        }
        konstructor = bongo.api[node.bongo_.constructorName];
        if (konstructor == null) {
          console.warn('unknown type', constructorName, 'vanilla object will be used...');
          return this.update(node);
        } else {
          return this.update(new konstructor(node), true);
        }
      } else {
        return this.update(node);
      }
    });
  };
  Bongo.prototype.handleRequest = function(message) {
    var callback, method, revived, scrubber, unscrubbed;
    if ((message != null ? message.method : void 0) === 'defineApi') {
      return this.defineApi(message.arguments[0]);
    } else {
      method = message.method;
      scrubber = new Scrubber(this.localStore);
      unscrubbed = scrubber.unscrub(message, __bind(function(callbackId) {
        if (!this.remoteStore.has(secretName + callbackId)) {
          this.remoteStore.add(secretName + callbackId, __bind(function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return this.handleResponse(secretName, callbackId, args);
          }, this));
        }
        return this.remoteStore.get(secretName + callbackId);
      }, this));
      revived = this.revive(unscrubbed);
      if (__indexOf.call(this.getInstanceMethods(), method) >= 0) {
        return this[method].apply(this, revived);
      } else if (!isNaN(+method)) {
        callback = this.localStore.get(method);
        return callback != null ? callback.apply(null, revived) : void 0;
      } else {
        return console.log(method);
      }
    }
  };
  Bongo.prototype.handleResponse = function() {
    console.log.apply(console, arguments);
    return console.log('like a boss');
  };
  Bongo.prototype.connect = function(callback) {
    this.channel = this.mq.subscribe(this.channelName);
    return this.channel.once('broker:subscription_succeeded', __bind(function() {
      this.channel.on('server-message', this.handleRequest.bind(this));
      this.stack.forEach(__bind(function(fn) {
        return fn.call(this);
      }, this));
      return callback(null);
    }, this));
  };
  Bongo.prototype.send = function(method, args) {
    var scrubber;
    if (!Array.isArray(args)) {
      args = [args];
    }
    if (!this.channel) {
      throw new Error('No channel!');
    } else {
      scrubber = new Scrubber(this.localStore);
      return scrubber.scrub(args, __bind(function() {
        var message, messageString;
        message = scrubber.toDnodeProtocol();
        message.method = method;
        messageString = JSON.stringify(message);
        return this.channel.emit('client-message', messageString);
      }, this));
    }
  };
  Bongo.prototype.disconnect = function(callback) {};
  Bongo.prototype.defineApi = function(api) {
    this.api = this.createRemoteApiShims(api);
    this.readyState = 1;
    this.emit('ready');
    return this.channel.emit('client-auth', this.getSessionToken());
  };
  Bongo.prototype.changeLoggedInState = function(state) {
    return this.emit('loggedInStateChanged', state);
  };
  Bongo.prototype.fetchChannel = function(channelName, callback) {
    var channel;
    channel = this.mq.subscribe(channelName);
    return channel.on('broker:subscription_succeeded', function() {
      return callback(channel);
    });
  };
  Bongo.prototype.use = function(fn) {
    return this.stack.push(fn);
  };
  return Bongo;
})();
if (!isBrowser && module) {
  module.exports = Bongo;
} else {
  if (typeof window !== "undefined" && window !== null) {
    window['Bongo'] = Bongo;
  }
}