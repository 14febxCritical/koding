###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
###
# stripTags = (input, allowed='') ->
#   # make sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
#   allowed = (allowed.toLowerCase().match(/<[a-z][a-z0-9]*>/g) or []).join ''
#   tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi
#   # we aren't going to filter out PHP tags, because we're not worried about compatibility with php:
#   comments = /<!--[\s\S]*?-->/gi
#   input.replace(comments, '')
#        .replace tags, ($0, $1) -> if allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 then $0 else ''

###
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
###
isBrowser = 'undefined' isnt typeof window
###
@class: bongo (client)
@description: client-side bongo.
###
class bongo
  # core
  {EventEmitter} = require 'events'
  bongo     = new EventEmitter
  # lib
  #{EventMultiplexer} = require './eventmultiplexer'
  # contrib
  Traverse  = require 'traverse'
  createId  = @createId = require 'hat'
  dnode     = require 'koding-dnode'
  
  @dnodeProtocol = require 'koding-dnode-protocol'
  
  @EventEmitter = EventEmitter
  Model     = @Model = require './src/model'
  ModelLoader = require './src/modelloader'
  JsPath    = @JsPath = require './src/jspath'
  # race      = @race = require './src/race'
  # sequence  = @sequence = require './src/sequence'

  {slice} = []

  {extend, @asynchronizeOwnMethods} = require './src/util'
  
  {race, sequence, dash} = require 'sinkrow'
  {@daisy, @dash, @sequence, @race, @future} = require 'sinkrow'
  
  # @daisy =(args, fn)->
  #   setTimeout args.next = ->
  #     if fn = args.shift() then !!fn(args) or yes else no
  #   , 0

  @api = {}

  instances_ = {}
  
  loading_ = {}
  
  getModelLoader =(constructor, id)->
    loading_[constructor.name] or= {}
    loader = loading_[constructor.name][id] or= new ModelLoader(constructor, id)
  
  @cacheable =do ->
    handleSingle =(constructorName, _id, callback)->
      # TODO: this implementation sucks; reimplement.
      if 'string' is typeof constructorName
        constructor = bongo.api[constructorName]
      else if 'function' is typeof constructorName
        constructor = constructorName
      unless constructor
        callback new Error "Unknown type #{constructorName}"
      else
        constructor.cache or= {}
        if model = constructor.cache[_id]
          callback null, model
        else getModelLoader(constructor, _id).load (err, model)->
          constructor.cache[_id] = model
          callback err, model
      return

    handleBatch =(batch, callback)->
      models = []
      # collectItems = race (i, single, fin)->
      #   {name, type, constructorName, id} = single
      #   handleSingle type or name or constructorName, id, (err, model)->
      #     if err
      #       callback err
      #     else
      #       models[i] = model
      #       fin()
      # , -> callback null, models
      # 
      # collectItems(item) for item in batch
      queue = batch.map (single, i)->->
        {name, type, constructorName, id} = single
        handleSingle type or name or constructorName, id, (err, model)->
          if err
            callback err
          else
            models[i] = model
            queue.fin()
      dash queue, -> callback null, models
      # return
    ->
      switch arguments.length
        when 2
          handleBatch.apply @, arguments
        when 3
          handleSingle.apply @, arguments
        else
          throw new Error 'bongo.cacheable expects either 2 or 3 arguments.'

  @getInstances =-> instances_
  
  @getInstancesById =(id)-> instances_[id]

  @addReferences =(instances...)->
    for instance in instances
      unless '_id' of instance
        throw new Error "Can't add a reference to an instance that has no id!"
      instances_[instance._id] or= {}
      instances_[instance._id][instance.bongo_.instanceId] = instance

  unless isBrowser
    @browserPath = "#{__dirname}/browser"

  updateInstances =(data)->
    constructor = @
    instances = bongo.getInstancesById data._id
    for own instanceId, instance of instances
      instance[prop] = val for own prop, val of data
      instance.emit 'update'

  findMyInstance =do ->
    hasEncoder = 'function' is typeof Encoder?.htmlEncode
    (data, extend)->
      instances = bongo.getInstancesById data._id
      for own instanceId, instance of instances
        if instanceId is data.bongo_.instanceId
          new Traverse(data).forEach (node)->
            if not @isLeaf and @path.length
              if node.bongo_?
                JsPath.setAt instance, @path, findMyInstance(node)
              else
                JsPath.setAt instance, @path, node
            return
          return instance
      data = unless hasEncoder then data else new Traverse(data).forEach (node)->
        if 'string' is typeof node
          @update Encoder.htmlEncode node
        else if @path.length and not @isLeaf and node.bongo_?.constructorName
          @update findMyInstance(node), yes
      model = new bongo.api[data.bongo_.constructorName] data

  createConstructor =(name, staticMethods, instanceMethods, options)->
    constructor = do Function """
      return function #{name} () {
        this.init.apply(this, [].slice.call(arguments));
        this.bongo_.constructorName = '#{name}';
      }
      """
    wrapStaticMethods constructor, staticMethods
    ctor = ->
      @constructor = constructor
      return
    ctor:: = Model::
    constructor[prop] = Model[prop] for own prop of Model
    constructor:: = new ctor
    constructor.__super__ = Model::
    constructor[option] = options[option] for option of options
    wrapInstanceMethods constructor, instanceMethods
    constructor

  wrapStaticMethods = do ->
    optimizeThese = ['on','off']
    (constructor, staticMethods)->
      for own methodName, method of staticMethods
        do (methodName, method)->
          methodName += '_' if methodName in optimizeThese
          constructor[methodName] =(err, res)->
            args = slice.call arguments
            wrapAll args
            if method.useMQ
              channelId = createId()
              channel = bongo.mq.subscribe channelId
              channel.bind 'pusher:subscription_succeeded', ->
                method.apply constructor, [channelId].concat args
            else
              method.apply constructor, [null].concat args
          constructor[methodName].useMQ = method.useMQ
      return

  wrapInstanceMethods = do ->
    optimizeThese = ['on','addListener','off','removeListener','save']
    (constructor, instanceMethods)->
      for own methodName, method of instanceMethods
        do (methodName, method)->
          methodName += '_' if methodName in optimizeThese
          constructor::[methodName] =->
            args = slice.call arguments
            wrapAll args
            id = @getId()
            if method.useMQ
              channelId = 'private-'+createId()
              channel = bongo.mq.subscribe channelId
              channel.bind 'pusher:subscription_succeeded', ->
                method channelId, id, (@ unless id), args...
            else
              method null, id, (@ unless id), args... 
            @
          constructor::[methodName].useMQ = method.useMQ
      return

  wrapAll =(obj)->
    new Traverse(obj).forEach (node)->
      if 'function' is typeof node
        @update wrapFn node
    return

  @reviveFromString =(str, callback)->
    separator = str.indexOf ':'
    strProtocol = str.substr 0, separator
    strPaylod = str.substr separator + 1
    try switch strProtocol
      when 'json'
        callback null, findMyInstance JSON.parse strPaylod
      when 'feed'
        instances = strPaylod.split('\n').map (json)->
          findMyInstance JSON.parse json
        callback null, instances
    catch e then callback e
  
  @reviveFromJSONP =(instances, callback)->
    callback null, instances.map (instance)->
      if instance.snapshot
        findMyInstance JSON.parse instance.snapshot
      else
        console.log instance

  wrapFn =(fn)->
    (err, res)->
      if res?.__channelId
        channel = bongo.mq.channel res.__channelId
        if channel?
          channel.bind 'message', fn.bind null, null
          channel.bind 'error', fn.bind null
      else
        args = slice.call(arguments)
        wrapArgs args, (wrappedArgs)-> fn.apply @, wrappedArgs
      @

  wrapArgs =do->
    jsonPrefix = /^json:/
    feedPrefix = /^feed:/
    {setAt} = JsPath
    revive =(node)-> findMyInstance JSON.parse node.replace jsonPrefix, ''
    (args, callback)->
      parseThese = []
      replaceThese = []
      objectRefs = []
      args = new Traverse(args).map (node)->
        if 'string' is typeof node
          if jsonPrefix.test node
            parseThese.push {@path, node}
            @update node
          else if feedPrefix.test node
            nodes = node.replace(feedPrefix, '').split '\n'
            replaceThese.push {
              @path
              nodes
            }
            for child, i in nodes
              parseThese.push {
                path: @path.concat i
                node: 'json:'+child
              }
            @update node
          else @update node
        else
          if not @isLeaf and 'bongo_' of node and 'constructorName' of node.bongo_
            if 'ObjectRef' is node.bongo_.constructorName
              objectRefs.push {
                @path
                node
              }
            else
              @update findMyInstance node
          else
            @update node

      replaceThese.forEach ({path, nodes})->
        nodes = (revive node for node in nodes)
        setAt args, path, nodes

      parseThese.forEach ({path, node})->
        setAt args, path, revive node

      return callback args unless objectRefs.length

      objects = []
      objectRefs.forEach (objectRef)->
        objects.push ->
          {constructorName, id} = objectRef.node
          bongo.fetchInstance constructorName, id, (err, instance)->
            throw err if err
            setAt args, objectRef.path, instance
            objects.fin()
      dash objects, -> wrapArgs args, (args)-> callback args


  clientId_ =
    if localStorage?.clientId
      localStorage.clientId
    else
      clientId_ = createId()
      localStorage?.clientId = clientId_
      clientId_

  api = (remote, conn)->
    
    receiveServerError:(errMsg)->
      throw new Error "An error was reported by the server: "+errMsg
    
    receiveAccessError:(errMsg)->
      KD.requireLogin errMsg
    
    fetchClientId:(callback)-> 
      callback clientId_
    
    receiveBroadcast:(broadcast)->
      bongo.emit 'broadcast', broadcast

  @connectKite =(options, callback =(kite)-> kite.emit 'ready')->
    {name, kiteApi} = options
    kiteApi.bongo_ = {name}
    #kiteApi.bongo_.os = bongo.asynchronizeOwnMethods require 'os'
    kiteApi.bongo_.id = clientId_
    bongo.connect options, (api, conn)->
      kite = new api.Kite kiteApi
      callback kite, conn, api

  stack = []
  @use =(middleware)->
    stack.push middleware
    @
  
  @connect =(port, callback)->
    [callback, port] = [port, callback] unless callback
    client = dnode api
    client.stack = stack
    client.connect port, (remote, conn)->
      bongo.fetchInstance = remote.fetchInstance
      remote.fetchApi (constructors, globals)->
        for def in constructors
          {
            name
            staticMethods
            instanceMethods
            rawStaticMethods
            rawInstanceMethods
            options
          } = def
          for methodName in rawStaticMethods
            staticMethods[methodName].useMQ = yes
          for methodName in rawInstanceMethods
            instanceMethods[methodName].useMQ = yes
          bongo.api[name] = createConstructor name, staticMethods, instanceMethods, options
        callback bongo.api, conn
    @
  
  if window? and BONGO_MQ?
    @mq = Model::mq = BONGO_MQ
    Model.wrapArgs = wrapArgs
    Model::mixin require './src/eventemitter/pusher'
  else
    Model::mixin require './src/eventemitter/dnode'
###
@snippet.
@description: export for node, or the browser, depending.
###
if not isBrowser and module
  module.exports = bongo
else
  window?.bongo = bongo