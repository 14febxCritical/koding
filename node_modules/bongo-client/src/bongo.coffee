###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@module: bongo-client
@author: Christopher Thorn <chris@koding.com>
###
# stripTags = (input, allowed='') ->
#   # make sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
#   allowed = (allowed.toLowerCase().match(/<[a-z][a-z0-9]*>/g) or []).join ''
#   tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi
#   # we aren't going to filter out PHP tags, because we're not worried about compatibility with php:
#   comments = /<!--[\s\S]*?-->/gi
#   input.replace(comments, '')
#        .replace tags, ($0, $1) -> if allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 then $0 else ''

###
@snippet.
@description: feature-detect the browser.
@todo: is there an improvement?
@foo
###
isBrowser = 'undefined' isnt typeof window
console.log isBrowser
###
@class: bongo (client)
@description: client-side bongo.
###
class Bongo
  # core
  {EventEmitter} = require 'events'
  # bongo     = new EventEmitter
  # lib
  #{EventMultiplexer} = require './eventmultiplexer'
  # contrib
  Traverse  = require 'traverse'
  createId  = @createId = require 'hat'
  dnode     = require 'koding-dnode'
  
  @dnodeProtocol = require 'koding-dnode-protocol'
  {Store, Scrubber} = @dnodeProtocol

  @EventEmitter = EventEmitter
  Model     = @Model = require './src/model'
  ModelLoader = require './src/modelloader'
  JsPath    = @JsPath = require './src/jspath'
  # race      = @race = require './src/race'
  # sequence  = @sequence = require './src/sequence'

  {slice} = []

  {extend} = require './src/util'
  
  {race, sequence, dash} = require 'sinkrow'
  {@daisy, @dash, @sequence, @race, @future} = require 'sinkrow'
  
  # @daisy =(args, fn)->
  #   setTimeout args.next = ->
  #     if fn = args.shift() then !!fn(args) or yes else no
  #   , 0
  createBongoName =-> 'bongo.'+createId()

  createRemoteApiShims =(api)->
    return api

  constructor:(options)->
    {@mq} = options
    @bongoName = createBongoName()
    @channelName = 'private-'+@bongoName
    @localStore = new Store
    @remoteStore = new Store

  handleServerMessage:(message)->
    console.log message
    unless isNaN +message.method
      callback = @localStore.get(message.method)
      if callback?
        callback? message
      else
        throw new Error "Couldn't find the callback: #{message}"

  connect:(callback)->
    @channel = @mq.subscribe @channelName
    @channel.on 'broker:subscription_succeeded', =>
      @channel.on 'server-message', @handleServerMessage.bind(@)
      callback null

  send:(method, args)->
    args = [args] unless Array.isArray(args)
    unless @channel
      throw new Error 'No channel!'
    else
      scrubber = new Scrubber @localStore
      scrubber.scrub args, =>
        @channel.emit 'client-message', scrubber.toDnodeProtocol()

  disconnect:(callback)->

  fetchApi:(callback)->
    @send 'fetchApi', (api)=> @api = createRemoteApiShims(api)

  dispatchMethod:(constructorName, method, context, args)->

  use:->
    
if not isBrowser and module
  module.exports = Bongo
else
  window?['Bongo'] = Bongo

#   @api = {}

#   instances_ = {}
  
#   loading_ = {}
  
#   getCancellableCallback_ = (callback)->
#     cancelled = no
#     kallback = (rest...)->
#       callback rest... unless cancelled
#     kallback.cancel = -> cancelled = yes
#     kallback
  
#   fetchChannel_ = (channelName, callback)->
#     callback = getCancellableCallback_ callback
#     channel = @channel channelName
#     if channel
#       callback channel, no
#     else
#       channel = @subscribe channelName
#       channel.on 'broker:subscription_succeeded', ->
#         console.log 'subscription succeeded'
#         callback channel, yes
#     setTimeout (->callback.cancel()), 1000
  
#   getModelLoader =(constructor, id)->
#     loading_[constructor.name] or= {}
#     loader = loading_[constructor.name][id] or= new ModelLoader(constructor, id)
  
#   @cacheable =do ->
#     handleSingle =(constructorName, _id, callback)->
#       # TODO: this implementation sucks; reimplement.
#       if 'string' is typeof constructorName
#         constructor = bongo.api[constructorName]
#       else if 'function' is typeof constructorName
#         constructor = constructorName
#       unless constructor
#         callback new Error "Unknown type #{constructorName}"
#       else
#         constructor.cache or= {}
#         if model = constructor.cache[_id]
#           callback null, model
#         else getModelLoader(constructor, _id).load (err, model)->
#           constructor.cache[_id] = model
#           callback err, model
#       return

#     handleBatch =(batch, callback)->
#       models = []
#       # collectItems = race (i, single, fin)->
#       #   {name, type, constructorName, id} = single
#       #   handleSingle type or name or constructorName, id, (err, model)->
#       #     if err
#       #       callback err
#       #     else
#       #       models[i] = model
#       #       fin()
#       # , -> callback null, models
#       # 
#       # collectItems(item) for item in batch
#       queue = batch.map (single, i)->->
#         {name, type, constructorName, id} = single
#         handleSingle type or name or constructorName, id, (err, model)->
#           if err
#             callback err
#           else
#             models[i] = model
#             queue.fin()
#       dash queue, -> callback null, models
#       # return
#     ->
#       switch arguments.length
#         when 2
#           handleBatch.apply @, arguments
#         when 3
#           handleSingle.apply @, arguments
#         else
#           throw new Error 'bongo.cacheable expects either 2 or 3 arguments.'

#   @getInstances =-> instances_
  
#   @getInstancesById =(id)-> instances_[id]

#   @addReferences =(instances...)->
#     for instance in instances
#       unless '_id' of instance
#         throw new Error "Can't add a reference to an instance that has no id!"
#       instances_[instance._id] or= {}
#       instances_[instance._id][instance.bongo_.instanceId] = instance

#   unless isBrowser
#     @browserPath = "#{__dirname}/browser"

#   updateInstances =(data)->
#     constructor = @
#     instances = bongo.getInstancesById data._id
#     for own instanceId, instance of instances
#       instance[prop] = val for own prop, val of data
#       instance.emit 'update'

#   findMyInstance =do ->
#     hasEncoder = 'function' is typeof Encoder?.htmlEncode
#     (data, extend)->
#       instances = bongo.getInstancesById data._id
#       for own instanceId, instance of instances
#         if instanceId is data.bongo_.instanceId
#           new Traverse(data).forEach (node)->
#             if not @isLeaf and @path.length
#               if node.bongo_?
#                 JsPath.setAt instance, @path, findMyInstance(node)
#               else
#                 JsPath.setAt instance, @path, node
#             return
#           return instance
#       data = unless hasEncoder then data else new Traverse(data).forEach (node)->
#         if 'string' is typeof node
#           @update Encoder.htmlEncode node
#         else if @path.length and not @isLeaf and node.bongo_?.constructorName
#           @update findMyInstance(node), yes
#       model = new bongo.api[data.bongo_.constructorName] data

#   createConstructor =(name, staticMethods, instanceMethods, options)->
#     constructor = do Function """
#       return function #{name} () {
#         this.init.apply(this, [].slice.call(arguments));
#         this.bongo_.constructorName = '#{name}';
#       }
#       """
#     wrapStaticMethods constructor, staticMethods
#     ctor = ->
#       @constructor = constructor
#       return
#     ctor:: = Model::
#     constructor[prop] = Model[prop] for own prop of Model
#     constructor:: = new ctor
#     constructor.__super__ = Model::
#     constructor[option] = options[option] for option of options
#     wrapInstanceMethods constructor, instanceMethods
#     constructor

#   wrapStaticMethods = do ->
#     optimizeThese = ['on','off']
#     (constructor, staticMethods)->
#       for own methodName, method of staticMethods
#         do (methodName, method)->
#           methodName += '_' if methodName in optimizeThese
#           constructor[methodName] =(err, res)->
#             args = slice.call arguments
#             wrapAll args
#             if method.useMQ
#               channelId = createId()
#               channel = bongo.mq.subscribe channelId
#               channel.on 'broker:subscription_succeeded', ->
#                 method.apply constructor, [channelId].concat args
#             else
#               method.apply constructor, [null].concat args
#           constructor[methodName].useMQ = method.useMQ
#       return

#   wrapInstanceMethods = do ->
#     optimizeThese = ['on','addListener','off','removeListener','save']
#     (constructor, instanceMethods)->
#       for own methodName, method of instanceMethods
#         do (methodName, method)->
#           methodName += '_' if methodName in optimizeThese
#           constructor::[methodName] =->
#             args = slice.call arguments
#             wrapAll args
#             id = @getId()
#             if method.useMQ
#               channelId = 'private-'+createId()
#               channel = bongo.mq.subscribe channelId
#               channel.on 'broker:subscription_succeeded', ->
#                 method channelId, id, (@ unless id), args...
#             else
#               method null, id, (@ unless id), args... 
#             @
#           constructor::[methodName].useMQ = method.useMQ
#       return

#   wrapAll =(obj)->
#     new Traverse(obj).forEach (node)->
#       if 'function' is typeof node
#         @update wrapFn node
#     return

#   @reviveFromString =(str, callback)->
#     separator = str.indexOf ':'
#     strProtocol = str.substr 0, separator
#     strPaylod = str.substr separator + 1
#     try switch strProtocol
#       when 'json'
#         callback null, findMyInstance JSON.parse strPaylod
#       when 'feed'
#         instances = strPaylod.split('\n').map (json)->
#           findMyInstance JSON.parse json
#         callback null, instances
#     catch e then callback e
  
#   @reviveFromJSONP =(instances, callback)->
#     callback null, instances.map (instance)->
#       if instance.snapshot
#         findMyInstance JSON.parse instance.snapshot
#       else
#         console.log instance

#   wrapFn =(fn)->
#     (err, res)->
#       if res?.__channelId
#         channel = bongo.mq.channel res.__channelId
#         if channel?
#           channel.on 'message', fn.bind null, null
#           channel.on 'error', fn.bind null
#       else
#         args = slice.call(arguments)
#         wrapArgs args, (wrappedArgs)-> fn.apply @, wrappedArgs
#       @

#   wrapArgs =do->
#     jsonPrefix = /^json:/
#     feedPrefix = /^feed:/
#     {setAt} = JsPath
#     revive =(node)-> findMyInstance JSON.parse node.replace jsonPrefix, ''
#     (args, callback)->
#       parseThese = []
#       replaceThese = []
#       objectRefs = []
#       args = new Traverse(args).map (node)->
#         if 'string' is typeof node
#           if jsonPrefix.test node
#             parseThese.push {@path, node}
#             @update node
#           else if feedPrefix.test node
#             nodes = node.replace(feedPrefix, '').split '\n'
#             replaceThese.push {
#               @path
#               nodes
#             }
#             for child, i in nodes
#               parseThese.push {
#                 path: @path.concat i
#                 node: 'json:'+child
#               }
#             @update node
#           else @update node
#         else
#           if not @isLeaf and 'bongo_' of node and 'constructorName' of node.bongo_
#             if 'ObjectRef' is node.bongo_.constructorName
#               objectRefs.push {
#                 @path
#                 node
#               }
#             else
#               @update findMyInstance node
#           else
#             @update node

#       replaceThese.forEach ({path, nodes})->
#         nodes = (revive node for node in nodes)
#         setAt args, path, nodes

#       parseThese.forEach ({path, node})->
#         setAt args, path, revive node

#       return callback args unless objectRefs.length

#       objects = []
#       objectRefs.forEach (objectRef)->
#         objects.push ->
#           {constructorName, id} = objectRef.node
#           bongo.fetchInstance constructorName, id, (err, instance)->
#             throw err if err
#             setAt args, objectRef.path, instance
#             objects.fin()
#       dash objects, -> wrapArgs args, (args)-> callback args


#   clientId_ =
#     if localStorage?.clientId
#       localStorage.clientId
#     else
#       clientId_ = createId()
#       localStorage?.clientId = clientId_
#       clientId_

#   api = (remote, conn)->
    
#     receiveServerError:(errMsg)->
#       throw new Error "An error was reported by the server: "+errMsg
    
#     receiveAccessError:(errMsg)->
#       KD.requireLogin errMsg
    
#     fetchClientId:(callback)-> 
#       callback clientId_
    
#     receiveBroadcast:(broadcast)->
#       bongo.emit 'broadcast', broadcast

#   @connectKite =(options, callback =(kite)-> kite.emit 'ready')->
#     {name, kiteApi} = options
#     kiteApi.bongo_ = {name}
#     #kiteApi.bongo_.os = bongo.asynchronizeOwnMethods require 'os'
#     kiteApi.bongo_.id = clientId_
#     bongo.connect options, (api, conn)->
#       kite = new api.Kite kiteApi
#       callback kite, conn, api

#   stack = []
#   @use =(middleware)->
#     stack.push middleware
#     @
  
#   @connect =(port, callback)->
#     [callback, port] = [port, callback] unless callback
#     client = dnode api
#     client.stack = stack
#     client.connect port, (remote, conn)->
#       bongo.fetchInstance = remote.fetchInstance
#       remote.fetchApi (constructors, globals)->
#         for def in constructors
#           {
#             name
#             staticMethods
#             instanceMethods
#             rawStaticMethods
#             rawInstanceMethods
#             options
#           } = def
#           for methodName in rawStaticMethods
#             staticMethods[methodName].useMQ = yes
#           for methodName in rawInstanceMethods
#             instanceMethods[methodName].useMQ = yes
#           bongo.api[name] = createConstructor name, staticMethods, instanceMethods, options
#         callback bongo.api, conn
#     @
  
#   if window? and BONGO_MQ?
#     @mq = Model::mq = BONGO_MQ
#     @mq.fetchChannel = fetchChannel_.bind(@mq)
#     @mq.updateInstanceChannel = @mq.subscribe('updateInstance')
#     Model.wrapArgs = wrapArgs
#     Model::mixin require './src/eventemitter/broker'
#   else
#     Model::mixin require './src/eventemitter/dnode'
# ###
# @snippet.
# @description: export for node, or the browser, depending.
# ###