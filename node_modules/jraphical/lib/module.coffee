{Base, Model, ObjectId, Inflector, Register, race, daisy} = require 'bongo'
{extend, groupBy} = require 'underscore'

Relationship = require './relationship' 
Graphlet = require './graphlet'
Snapshot = require './snapshot'

module.exports = class Module extends Model

  @attachInterface =(verb, noun, isPlural, fn)->
    [fn, lowFirstLetter] = [lowFirstLetter, fn] unless fn
    name = @getInterfaceName verb, noun, isPlural, yes
    @::[name] = fn
    @
  
  @getDefaultRole =-> 'related'
  
  @setRelationships = do ->
    setRelationships = (constructor, relationships)->
      if 'function' is typeof relationships
        relationships = relationships.call constructor
      constructor.relationships = relationships
      for own name, def of relationships
        chain = def.inheritanceChain?()
        if chain and Module in chain
          def = targetType: def
        def.as or= def.targetType.getDefaultRole()
        constructor
        .attachInterface('add', name, no, getAdder_ constructor, name, def)
        .attachInterface('assure', name, no, getAssurer_ constructor, name, def)
        .attachInterface('remove', name, no, getRemover_ constructor, name, def)
        .attachInterface('fetch', name, yes, getFetcher_ constructor, name, def)
        .attachInterface('fetch', name, no, getFetcher_ constructor, name, def, yes)
    (relationships)->
      constructor = @
      if 'function' is typeof relationships
        # when you pass "relationships" as a function, it will be defered until the next tick.
        # this can be useful for resolving circular dependencies (a requirement for graphs).
        process.nextTick setRelationships.bind null, constructor, relationships
      else
        setRelationships constructor, relationships
      constructor
  
  # fetchSubject:(callback)-> callback null, @ # this is the stub version.
  
  @collectTeasersCallback = (callback, skip=0)->
    (err, nodes)->
      teasers = []
      collectTeasers = race (i, node, fin)->
        if node.snapshot?
          process.nextTick ->
            teasers[i] = node.snapshot.replace(/^json:/, '')
            fin()
        else
          unless node.fetchSubject?
            # process.nextTick ->
            #Snapshot.capture node, null, i, (err, snapshot)->
            process.nextTick ->
              teasers[i] = JSON.stringify(node)
              fin()
          else
            node.fetchSubject (err, subject)->
              if err
                callback err
              else
                subject.fetchTeaser (err, teaser)->
                  if err
                    callback err
                  else
                    Snapshot.capture node, teaser, i, (err, snapshot)->
                      teasers[i] = snapshot
                      fin()
      , ->
        out = 'feed:'+teasers.join '|||'
        callback null, out
      if nodes.length
        collectTeasers node for node in nodes
      else
        callback null
      return
  
  @collectTeasersAllCallback = (callback)->
    (err, nodes)->
      teasers = []
      collectTeasersAll = race (i, node, fin)->
        teasers[i] = []
        node.fetchSubjects (err, subjects)->
          if err
            callback err
          else
            collectTeasers = race (j, subject, fin)->
              subject.fetchTeaser (err, teaser)->
                if err
                  callback err
                else
                  teasers[i][j] = teaser
                  fin()
            , -> fin()
            collectTeasers subject for subject in subjects
      , -> callback null, teasers
      collectTeasersAll node for node in nodes when node.fetchSubject?
      return
  
  getOrientation =(def)->
    orientation =
      if def.sourceType? then ['source', 'target']
      else if def.targetType? then ['target','source']
      else throw new Error 'Invalid relationship!'
  
  getFetcher_ =(constructor, name, def, onlyOne=no)->
    if onlyOne
      limit = 1
    ->
      model = @
      args = arguments
      switch args.length
        when 1
          [callback] = args
        when 2
          [selector, callback] = args
        when 3
          [selector, options, callback] = args
          if options.targetOptions
            {options, targetOptions} = options
            options or= {}
      if 'string' is typeof selector
        selector = as: selector
      selector or= {}
      selector.as or=
        if 'string' is typeof def.as
          def.as
        else
          $in: def.as
      orientation   = getOrientation(def)
      outgoingName  = "#{orientation[0]}Name"
      outgoingType  = "#{orientation[0]}Type"
      incomingName  = "#{orientation[1]}Name"
      incomingId    = "#{orientation[1]}Id"
      
      [orientation] = orientation
      
      selector[outgoingName] or= \
        if Array.isArray(def[outgoingType])
          $in: def[outgoingType].map (type)-> type.name
        else if def[outgoingType].encapsulatedSubclasses?
          $in: def[outgoingType].encapsulatedSubclasses.map (type)-> type.name
        else
          def[outgoingType].name
      selector[incomingName] = constructor.name
      selector[incomingId]   = model.getId()
      idField = "#{orientation}Id"
      fields = {}
      fields[idField] = 1
      fields['data.flags'] = 1
      fields["#{orientation}Name"] = 1
      Relationship.someData selector, fields, options, (err, cursor)->
        if err
          callback err
        else
          cursor.toArray (err, docs)->
            if err
              callback err
            else unless docs?.length
              callback null, unless limit then []
            else
              ordered = {}
              (doc[idField] for doc in docs).forEach (id, index)->
                ordered[id] = index unless ordered[id]?
              
              groups = groupBy(docs, outgoingName)
              
              results = []
              collectOthers = race (i, type, group, next)->
                ids = (rel[idField] for rel in group)
                flags = {}
                ids.forEach (id, index)->
                  flag = group[index].data?.flags
                  flags[id] = flag if flag
                targetOptions or= {}
                if targetSelector = targetOptions.selector or targetOptions.query
                  delete targetOptions.selector
                  delete targetOptions.query
                else
                  targetSelector = {}

                Base.constructors[type].some extend(targetSelector,
                  _id: $in: ids
                ), targetOptions, (err, others)->
                  if others? 
                    others = for other in others
                      other.flags_ = flags[other.getId()]
                      other
                    results = results.concat others
                  next()
              , ->
                if limit
                  [results] = results
                else
                  sortedResults = []
                  results.forEach (result)->
                    sortedResults[ordered[result.getId()]] = result
                  results = sortedResults.filter (value)-> value?
                callback null, results
              
              for own type, group of groups
                collectOthers type, group

  getAdder_ =(constructor, name, def)->
    (target, options, callback)->
      if 'function' is typeof options
        callback = options
        options = {}
      else unless callback
        callback = ->
      {targetType, as} = def
      [as] = as if Array.isArray as
      if options
        if 'string' is typeof options
          as = options
        else if options.as
          {as} = options
      targetType = [targetType] unless Array.isArray(targetType)
      for targetChildType in targetType
        if target.constructor is targetChildType
          foundTargetType = target.constructor
          break
        else if target.constructor.encapsulatedBy is targetChildType
          foundTargetType = target.constructor.encapsulatedBy
          break
      if foundTargetType
        targetType = foundTargetType
      else
        return callback new TypeError 'Type mismatch'
      rdef = {
        targetId    : target.getId()
        targetName  : targetType.name
        sourceId    : @getId()
        sourceName  : constructor.name
        as
      }
      if options.flags
        rdef.data = flags: options.flags
      # TODO: if this doesn't break shit, I'd like to remove it...  it may break shit tho. CT
      # if target.constructor isnt targetType
      #   rdef.abstractTargetName = targetType.name
      #   rdef.targetName = target.constructor.name
      unless target.getId()
        callback new Error 'No target id!'
      else
        console.log rdef
        new Relationship(rdef).save (err, docs)->
          if err
            callback err
          else if options?.respondWithCount
            delete rdef.targetId
            Relationship.count rdef, (err, count)->
              if err
                callback err
              else
                callback null, docs, count
          else
            callback err, docs
  
  getRemover_ =(constructor, name, def)->
    (target, options, callback)->
      [callback, options] = [options, callback] unless callback
      {targetType, as} = def
      as = as[0] if Array.isArray as
      if options
        if 'string' is typeof options
          as = options
        else if options.as
          {as} = options
      rdef =
        targetId    : target.getId()
        targetName  : targetType.name 
        sourceId    : @getId()
        sourceName  : constructor.name
      unless as is '*'
        rdef.as = as
      Relationship.remove rdef,
        unless options?.respondWithCount
          callback
        else ->
          delete rdef.targetId
          Relationship.count rdef, callback
  
  getAssurer_ = do ->
    addIt =(context, adder, target, callback)->
      context[adder] target, (err)->
        if err
          callback err
        else
          callback null, target
    (constructor, name, def)->
      (target, callback)->
        [callback, target] = [target, callback] unless callback
        fetcher = @getInterfaceName 'fetch', name
        adder = @getInterfaceName 'add', name
        selector = 
          if target?
            targetId    : target.getId()
          else {}
        @[fetcher] selector, (err, module)=>
          if err
            callback err
          else unless def.targetType
            callback new Error 'No target type!'
          else if module
            # update the timestamp on this relationship to reflect the
            # fact that it is being assured again, so the timestamp always
            # shows the most recent
            Relationship.update {
              targetId  : target.getId()
              sourceId  : @getId()
              as        : def.as
            },{
              $set: timestamp: new Date
            }, (err)->
              callback null, module
          else
            if target
              addIt @, adder, target, callback
            else
              target = new def.targetType
              target.save (err)=>
                if err
                  callback err
                else
                  addIt @, adder, target, callback
  
  remove:(callback=->)->
    {constructor} = @
    Relationship.all $or: [{sourceId: @getId()}, {targetId: @getId()}], (err, rels)=>
      if err
        callback err
      else
        relIds = rel.id for rel in rels
        Relationship.remove (_id: $in: relIds), =>
          constructor.remove _id: @getId(), callback
  
  beginGraphlet:-> new Graphlet nodes: [@]
  
  getFlag = (key, val)->
    flag = {}
    flag["data.flags.#{key}"] = val
    flag
  
  getAs =(as)->
    if Array.isArray as then $in: as else as
  
  updateFlag = (sourceId, targetId, as, flag, callback)->
    Relationship.update {targetId, sourceId, as}, flag, callback
  
  unflag:(key, sourceId, as, callback)->
    flag = $unset: getFlag key, 1
    updateFlag sourceId, @getId(), getAs(as), flag, callback
  
  flag:(key, val, sourceId, as, callback)->
    flag = $set: getFlag key, val
    updateFlag sourceId, @getId(), getAs(as), flag, callback
  
  save:(callback)->
    Model::save.call @, callback

  update:(rest..., callback)->
    kallback =(rest...)=> 
      Snapshot.clearById @getId(), -> callback? rest...
    Model::update.apply @, rest.concat kallback
  #
  #fetchSources:(selector, options, callback)->
  #  selector.targetName = @constructor.name
  #  selector.sourceName = options.type.name
  #  fetchOthers_ selector, options, callback
  #  
  #fetchTargets:(selector, options, callback)->
  #  selector.sourceName = @constructor.name
  #  selector.targetName = options.type.name
  #  fetchOthers_ selector, options, callback
  #  
  #fetchOthers_ =->
  #