os = require 'os'
nodePath = require 'path'
{spawn, exec} = require 'child_process'
{Scrubber, Store} = require 'koding-dnode-protocol'
Pusher = require 'node-pusher'
request = require 'request'
express = require 'express'

log = console.log

module.exports = class Kite
  
  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @app = express.createServer()
    @app.use express.bodyParser()
    @channels = {}
    @requesters = {}
  
  unscrubMessage:(requesterId, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        unless @remoteStore.has(requesterId+callbackId)
          @remoteStore.add requesterId+callbackId, (args...)=>
            @request unscrubbed[0].secretChannelId, callbackId, args
        @remoteStore.get requesterId+callbackId
      callback unscrubbed

  startRequestHandler:(config)->
    hostname = os.hostname()
    protocol = config.protocol or 'http://'
    port = config.port
    hostname = os.hostname()
    kiteUri = "#{protocol}#{hostname}:#{port}/"
    logfile = config.requestHandler.logfile or '/tmp/kite-request-handler.log'
    requestHandlerPath = config.requestHandler.path or nodePath.join(
      nodePath.dirname(module.filename)
      'lib/request-handler'
    )
    cmd = [
      "cd #{requestHandlerPath} &&"
      'ruby index.rb'
      '-k', config.pusher.key
      '-s', config.pusher.secret
      '-l', logfile
      '-u', kiteUri
      '-n', @kiteName
    ].join ' '
    requestHandler = exec cmd
    requestHandler.stdout.on 'data', (data)-> log ''+data
    requestHandler.stderr.on 'data', (data)-> log ''+data
    requestHandler.on 'exit', (code)=>
      setTimeout (=> @startRequestHandler), 1000

  handleRequest:(data, res)->
    log @kiteName, 'HANDLING REQUEST on behalf of', data.username, data
    {channels, requesters} = @
    try
      scrubbed = JSON.parse data.data
      requesterId = data.username
    catch e then return res.send error: 400
    @unscrubMessage requesterId, scrubbed, (unscrubbed)=>
      [data, callback] = unscrubbed
      {toDo, withArgs, secretChannelId, subscriberCount, callbackId} = data
      withArgs or= {}
      withArgs.username = requesterId
      unless requesters[requesterId]?
        # send the _connect message to this kite's user-defined API.
        @api._connect? {requesterId}
        # make sure the request handler daemon is listening to client events.
        @pusher.trigger(
          "private-krh-#{@kiteName}", 'join', {
            channel: "private-#{@kiteName}-#{requesterId}"
          }
        )
        requesters[requesterId] = {}
      switch toDo
        when '_handleCallback'
          kallback = @localStore.get scrubbed.method
          kallback? withArgs...
          return res.send result: 200
        when '_disconnect'
          if requesters[requesterId]?
            Object.keys(requesters[requesterId]).forEach (channelId)->
              delete channels[channelId] if --channels[channelId] is 0
            @api._disconnect? {
              requesterId
              channels: requesters[requesterId]
            }
            delete requesters[requesterId]
            return res.send result: 200
          else return res.send error: 400
        when '_ping' then return res.send result: 200
        else
          if @api.propertyIsEnumerable(toDo) and 'function' is typeof @api[toDo]
            channels[secretChannelId] ?= 0
            channels[secretChannelId] += 1
            requesters[requesterId][secretChannelId] = yes
            withArgs.requesterId = requesterId
            @api[toDo]? withArgs, (err, msg)=>
              if channels[secretChannelId]?
                scrubber = new Scrubber @localStore
                scrubber.scrub [].slice.call(arguments), =>
                  out = scrubber.toDnodeProtocol()
                  out.method = callback.id
                  @pusher.trigger secretChannelId, 'message', out
            return res.send result: 200
          else
            return res.send error: 400
  
  handleRequests:->
    @app.post '/', (req, res)=>
      @handleRequest req.body, res
    @app.get '/', (req, res)=>
      @handleRequest req.query, res
  
  registerSelf:->
    uri = @apiUri+'/kite/connect'
    console.log 'Connecting to the API server:', uri
    request.get {
      uri     : uri
      qs      : 
        data  : JSON.stringify {
          @kiteName
          uri : @protocol+os.hostname()+':'+@port
        }
    }, (err, response, body)->
      console.log 'Received a response from the API server:', body
  
  request:(secretChannelId, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, =>
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      @pusher.trigger secretChannelId, 'message', out
  
  run:(config)->
    {port,pidPath,logPath,protocol,@apiUri} = config
    @pusher = new Pusher config.pusher
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"
    @protocol = protocol or 'http://'
    @port = port
    @app.listen port
    @startRequestHandler(config) if config.requestHandler?.isEnabled
    @handleRequests()
    @registerSelf()
