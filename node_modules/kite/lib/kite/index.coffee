{Scrubber, Store} = require 'koding-dnode-protocol'
Pusher = require 'node-pusher'
request = require 'request'

pusher = new Pusher
  appId   : 18240
  key     : 'a19c8bf6d2cad6c7a006'
  secret  : '51f7913fbb446767a9fb'

express = require 'express'


module.exports = class Kite

  constructor:(@kiteName, @api)->
    [@api, @kiteName] = [kiteName, api] unless api
    @kiteName or= 'unknown'
    @localStore = new Store
    @remoteStore = new Store
    @app = express.createServer()
  
  unscrubMessage:(requesterId, scrubbed, callback)->
    # duck-type for dnode protocol
    unless scrubbed.arguments? and scrubbed.callbacks?
      callback [scrubbed, ->] # a vanilla object; callback is noop
    else
      scrubber = new Scrubber @localStore
      unscrubbed = scrubber.unscrub scrubbed, (callbackId)=>
        unless @remoteStore.has(requesterId+callbackId)
          @remoteStore.add requesterId+callbackId, (args...)=>
            @request unscrubbed[0].secretChannelId, callbackId, args
        @remoteStore.get requesterId+callbackId
      callback unscrubbed

  handleRequests:->
    channels = {}
    requesters = {}
    
    @app.get '/', (req, res)=>
      try
        scrubbed = JSON.parse req.query.data
        requesterId = req.query.username
      catch e then return res.send error: 400
      @unscrubMessage requesterId, scrubbed, (unscrubbed)=>
        [data, callback] = unscrubbed
        {toDo, withArgs, secretChannelId, subscriberCount, callbackId} = data
        withArgs or= {}
        withArgs.username = requesterId
        unless requesters[requesterId]?
          @api._connect? {requesterId}
          requesters[requesterId] = {}
        switch toDo
          when '_handleCallback'
            kallback = @localStore.get scrubbed.method
            kallback? withArgs...
            return res.send result: 200
          when '_disconnect'
            if requesters[requesterId]?
              Object.keys(requesters[requesterId]).forEach (channelId)->
                delete channels[channelId] if --channels[channelId] is 0
              @api._disconnect? {
                requesterId
                channels: requesters[requesterId]
              }
              delete requesters[requesterId]
              return res.send result: 200
            else return res.send error: 400
          when '_ping' then return res.send result: 200
          else
            if @api.propertyIsEnumerable(toDo) and 'function' is typeof @api[toDo]
              channels[secretChannelId] ?= 0
              channels[secretChannelId] += 1
              requesters[requesterId][secretChannelId] = yes
              withArgs.requesterId = requesterId
              @api[toDo]? withArgs, (err, msg)=>
                if channels[secretChannelId]?
                  if err
                    pusher.trigger secretChannelId, 'error', err
                  else
                    scrubber = new Scrubber @localStore
                    scrubber.scrub [].slice.call(arguments), ->
                      out = scrubber.toDnodeProtocol()
                      out.method = callback.id
                      pusher.trigger secretChannelId, 'message', out
              return res.send result: 200
            else
              return res.send error: 400
  
  registerSelf:->
    console.log 'registering self with api server'
    request.get {
      uri     : 'https://api.koding.com/1.1/kite/connect'
      qs      : 
        data  : JSON.stringify {
          @kiteName
          uri : @protocol+require('os').hostname()+':'+@port
        }
    }, (err, response, body)->
      console.log body
  
  request:(secretChannelId, callbackId, args)->
    scrubber = new Scrubber @localStore
    scrubber.scrub args, ->
      out = scrubber.toDnodeProtocol()
      out.method = callbackId
      pusher.trigger secretChannelId, 'message', out
  
  run:(config)->
    {port,pidPath,logPath,protocol} = config
    if pidPath
      require("fs").writeFile pidPath,"#{process.pid}",(err)->
        if err?
          console.log "[WARN] Can't write pid to #{pidPath}:  monit can't watch this process. err:#{err.message}"
    @protocol = protocol or 'http://'
    @port = port
    @app.listen port
    
    @handleRequests()
    @registerSelf()
