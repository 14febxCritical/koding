var Kite, Pusher, Scrubber, Store, express, pusher, request, _ref;
var __slice = Array.prototype.slice, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
_ref = require('koding-dnode-protocol'), Scrubber = _ref.Scrubber, Store = _ref.Store;
Pusher = require('node-pusher');
request = require('request');
pusher = new Pusher({
  appId: 18240,
  key: 'a19c8bf6d2cad6c7a006',
  secret: '51f7913fbb446767a9fb'
});
express = require('express');
console.log = function() {};
module.exports = Kite = (function() {
  function Kite(kiteName, api) {
    var _ref2;
    this.kiteName = kiteName;
    this.api = api;
    if (!api) {
      _ref2 = [kiteName, api], this.api = _ref2[0], this.kiteName = _ref2[1];
    }
    this.kiteName || (this.kiteName = 'unknown');
    this.localStore = new Store;
    this.remoteStore = new Store;
    this.app = express.createServer();
  }
  Kite.prototype.unscrubMessage = function(requesterId, scrubbed, callback) {
    var scrubber, unscrubbed;
    if (!((scrubbed.arguments != null) && (scrubbed.callbacks != null))) {
      return callback([scrubbed, function() {}]);
    } else {
      scrubber = new Scrubber(this.localStore);
      unscrubbed = scrubber.unscrub(scrubbed, __bind(function(callbackId) {
        if (!this.remoteStore.has(requesterId + callbackId)) {
          this.remoteStore.add(requesterId + callbackId, __bind(function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return this.request(unscrubbed[0].secretChannelId, callbackId, args);
          }, this));
        }
        return this.remoteStore.get(requesterId + callbackId);
      }, this));
      return callback(unscrubbed);
    }
  };
  Kite.prototype.handleRequests = function() {
    var channels, requesters;
    channels = {};
    requesters = {};
    return this.app.get('/', __bind(function(req, res) {
      var requesterId, scrubbed;
      try {
        scrubbed = JSON.parse(req.query.data);
        requesterId = req.query.username;
      } catch (e) {
        return res.send({
          error: 400
        });
      }
      return this.unscrubMessage(requesterId, scrubbed, __bind(function(unscrubbed) {
        var callback, callbackId, data, kallback, secretChannelId, subscriberCount, toDo, withArgs, _base, _base2, _base3, _ref2;
        data = unscrubbed[0], callback = unscrubbed[1];
        toDo = data.toDo, withArgs = data.withArgs, secretChannelId = data.secretChannelId, subscriberCount = data.subscriberCount, callbackId = data.callbackId;
        withArgs || (withArgs = {});
        withArgs.username = requesterId;
        if (requesters[requesterId] == null) {
          if (typeof (_base = this.api)._connect === "function") {
            _base._connect({
              requesterId: requesterId
            });
          }
          requesters[requesterId] = {};
        }
        switch (toDo) {
          case '_handleCallback':
            kallback = this.localStore.get(scrubbed.method);
            if (typeof kallback === "function") {
              kallback.apply(null, withArgs);
            }
            return res.send({
              result: 200
            });
          case '_disconnect':
            if (requesters[requesterId] != null) {
              Object.keys(requesters[requesterId]).forEach(function(channelId) {
                if (--channels[channelId] === 0) {
                  return delete channels[channelId];
                }
              });
              if (typeof (_base2 = this.api)._disconnect === "function") {
                _base2._disconnect({
                  requesterId: requesterId,
                  channels: requesters[requesterId]
                });
              }
              delete requesters[requesterId];
              return res.send({
                result: 200
              });
            } else {
              return res.send({
                error: 400
              });
            }
            break;
          case '_ping':
            return res.send({
              result: 200
            });
          default:
            if (this.api.propertyIsEnumerable(toDo) && 'function' === typeof this.api[toDo]) {
              if ((_ref2 = channels[secretChannelId]) == null) {
                channels[secretChannelId] = 0;
              }
              channels[secretChannelId] += 1;
              requesters[requesterId][secretChannelId] = true;
              withArgs.requesterId = requesterId;
              if (typeof (_base3 = this.api)[toDo] === "function") {
                _base3[toDo](withArgs, __bind(function(err, msg) {
                  var scrubber;
                  if (channels[secretChannelId] != null) {
                    if (err) {
                      return pusher.trigger(secretChannelId, 'error', err);
                    } else {
                      scrubber = new Scrubber(this.localStore);
                      return scrubber.scrub([].slice.call(arguments), function() {
                        var out;
                        out = scrubber.toDnodeProtocol();
                        out.method = callback.id;
                        return pusher.trigger(secretChannelId, 'message', out);
                      });
                    }
                  }
                }, this));
              }
              return res.send({
                result: 200
              });
            } else {
              return res.send({
                error: 400
              });
            }
        }
      }, this));
    }, this));
  };
  Kite.prototype.registerSelf = function() {
    console.log('registering self with api server');
    return request.get({
      uri: 'https://api.koding.com/1.0/kite/connect',
      qs: {
        env: 'vpn',
        data: JSON.stringify({
          kiteName: this.kiteName,
          uri: this.protocol + require('os').hostname() + ':' + this.port
        })
      }
    }, function(err, response, body) {
      return console.log(body);
    });
  };
  Kite.prototype.request = function(secretChannelId, callbackId, args) {
    var scrubber;
    scrubber = new Scrubber(this.localStore);
    return scrubber.scrub(args, function() {
      var out;
      out = scrubber.toDnodeProtocol();
      out.method = callbackId;
      return pusher.trigger(secretChannelId, 'message', out);
    });
  };
  Kite.prototype.run = function(config) {
    var logPath, pidPath, port, protocol;
    port = config.port, pidPath = config.pidPath, logPath = config.logPath, protocol = config.protocol;
    if (pidPath) {
      require("fs").writeFile(pidPath, "" + process.pid, function(err) {
        if (err != null) {
          return console.log("[WARN] Can't write pid to " + pidPath + ":  monit can't watch this process. err:" + err.message);
        }
      });
    }
    this.protocol = protocol || 'http://';
    this.port = port;
    this.app.listen(port);
    this.handleRequests();
    return this.registerSelf();
  };
  return Kite;
})();