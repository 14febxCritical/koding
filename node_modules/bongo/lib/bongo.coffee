###
Bongo.js
Unfancy models for MongoDB

(c) 2011 Koding, Inc.

@class: bongo
@description: the main klass of the library.
@author: Christopher Thorn <chris@koding.com>
###
module.exports = class bongo
  # core
  url = require 'url'
  fs = require 'fs'
  {EventEmitter}  = require 'events'
  bongo = new EventEmitter
  # client-side boilerplate
  @client = bongoClient = require 'bongo-client'
  dnode           = require 'koding-dnode'
  # contrib
  @mongo          = require 'mongoskin'
  {extend}        = require 'underscore'
  @JsPath         = require 'jspath'
  @Inflector      = require 'inflector'
  # lib
  # the base klass of the library:
  @Base = Base    = require './base'
  # the model klass of the library:
  @Model = Model  = require './model'
  # the rest of the basics:
  @Subcollection  = require './subcollection'
  @ObjectId       = require './objectid'
  @ObjectRef      = require './objectref'
  @Validator      = require './validator'
  @Plugin         = require './plugin'
  @Register       = require './register'
  @Kite = Kite    = require './kite'
  # @KiteServer     = require './kiteserver'
  @util           = require './util'
  
  {@daisy, @dash, @sequence, @race, @future} = require 'sinkrow'
  
  {@asynchronizeOwnMethods} = require './util'
  
  {BongoError}    = require './errortypes'
  
  @throwIt =(it)-> throw it if it?
  
  clientCode_ = null
  # do ->
  #   # this is Koding's special implementation of dnode-protocol
  #   {Scrubber} = require 'koding-dnode-protocol'
  #   Scrubber.use (cursor)->
  #     {node} = cursor
  #     if 'function' is typeof node?.toObjectRef and not node.payload_
  #       cursor.update node.toObjectRef()

  @Client = Client = require './client'

  getDelegatedPrototypeInterface_ =(constructor, methodName, client)->
    invokeMethod =(instance, args, client)->
      if client
        constructor::[methodName].apply instance, [client].concat args
      else
        constructor::[methodName].apply instance, args
    (channelId, _id, data, args...)->
      args.unshift channelId if channelId?
      if _id?
        constructor.one {_id}, (err, instance)->
          if err
            console.log 'There was an error', err
          else
            invokeMethod instance, args, client
      else
        instance = constructor.sharedInstances[data.bongo_?.instanceId] = new constructor data
        invokeMethod instance, args, client

  getClient =(conn)-> new Client conn
  
  api =(remote, conn)->
    conn.on 'end', ->
      Kite.removeById conn.remoteId
      bongo.emit 'clientDidDisconnect', conn
    
    fetchInstance:(constructorName, _id, callback)->
      konstructor = Base.constructors[constructorName]
      if konstructor?.isShared
        konstructor?.one {_id}, (err, node)->
          if err or !node? then callback err
          else
            node.payload_ = yes
            callback null, node
      else callback null
    
    fetchApi:(callback)->
      api = for own name, constructor of Base.sharedConstructors
        {static, instance} = constructor.getSharedMethods()
        staticMethods = {}
        instanceMethods = {}
        rawStaticMethods = []
        rawInstanceMethods = []
        client = getClient conn
        for methodName in static
          do (methodName, constructor)->
            try
              method = constructor[methodName]
              rawStaticMethods.push methodName if method.useMQ
              boundMethod =
                if method.securityIsEnabled
                  (channelId, rest...)->
                    method.apply constructor, [client].concat rest
                else
                  (channelId, rest...)->
                    method.apply constructor, rest
              staticMethods[methodName] = boundMethod
            catch e
              throw new BongoError \
                """
                Shared method #{methodName} could not be bound.
                """
        for methodName in instance
          try
            if constructor::[methodName].useMQ
              rawInstanceMethods.push methodName
            instanceMethods[methodName] =
              getDelegatedPrototypeInterface_ constructor, methodName,
                (client if constructor::[methodName].securityIsEnabled)
          catch e
            throw new BongoError \
              """
              Shared method #{methodName} could not be bound.
              """
        {
          name
          staticMethods, instanceMethods
          rawStaticMethods, rawInstanceMethods
          options: {
            broadcastable: constructor.getBroadcastable()
          }
        }
      callback api
  
  @secure =(fn)->
    fn.securityIsEnabled = yes
    fn
  
  @useMQ =(fn)->
    fn.useMQ = yes
    fn
  
  @setClient =(overload)->
    Model.setClient overload
    @

  @listen =(server, options={})->
    {client} = options
    client or= '/bongo.js'
    delete options.client
    dnode(api).listen server, options, (remote, conn)->
      remote.fetchClientId? (id)-> conn.remoteId = id
    if 'function' is typeof server.listeners
      listeners = server.listeners 'request'
      server.removeAllListeners 'request'
      server.on 'request', (req, res)->
        {pathname} = url.parse req.url
        if pathname is client
          if clientCode_
            res.writeHead 200, 'Content-Type': 'text/javascript'
            res.end clientCode_
          else
            fs.readFile "#{bongoClient.browserPath}#{client}", (err, source)->
              if err
                throw err
                res.writeHead 500
                res.end "500 - browser code could not be loaded."
              else
                res.writeHead 200, 'Content-Type': 'text/javascript'
                res.end clientCode_ = source
        else
          listener.call @, req, res for listener in listeners
    @
  
  @fetchChannel =(name, callback)->
    Channel = require('./channel') bongo.mq
    callback new Channel(name)
    