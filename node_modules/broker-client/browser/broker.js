(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",function(require,module,exports,__dirname,__filename,process,global){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("__browserify_process",function(require,module,exports,__dirname,__filename,process,global){var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
        && window.setImmediate;
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return window.setImmediate;
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    if (name === 'evals') return (require)('vm')
    else throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    process.cwd = function () { return cwd };
    process.chdir = function (dir) {
        if (!path) path = require('path');
        cwd = path.resolve(dir, cwd);
    };
})();

});

require.define("/node_modules/broker-client/lib/broker-client/index.js",function(require,module,exports,__dirname,__filename,process,global){
exports.Broker = require('./broker');

exports.Channel = require('./channel');

if (typeof window !== "undefined" && window !== null) {
  window['Broker'] = require('./broker');
}

});

require.define("/node_modules/broker-client/lib/broker-client/broker.js",function(require,module,exports,__dirname,__filename,process,global){'use strict';

var Broker;

module.exports = Broker = (function() {
  var Channel, EventEmitter, sendWsMessage;

  EventEmitter = require('microemitter').EventEmitter;

  EventEmitter(Broker.prototype);

  Channel = require('./channel');

  sendWsMessage = require('./util').sendWsMessage;

  function Broker(appKey, options) {
    if (options == null) {
      options = {};
    }
    this.sockURL = options.sockURL || "http://" + window.location.hostname + ":8008/subscribe";
    this.channel_auth_endpoint = options.authEndPoint || "http://" + window.location.hostname + ":8008/auth";
    this.vhost = options.vhost || "/";
    this.key = appKey;
    this.autoReconnect = options.autoReconnect || false;
    this.channels = {};
    this.connect();
    if (this.autoReconnect) {
      this.initBackoff(options);
    }
  }

  Broker.prototype.initBackoff = function(options) {
    var backoff, initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref, _ref1, _ref2, _ref3, _ref4,
      _this = this;
    backoff = (_ref = options.backoff) != null ? _ref : {};
    totalReconnectAttempts = 0;
    initalDelayMs = (_ref1 = backoff.initialDelayMs) != null ? _ref1 : 700;
    multiplyFactor = (_ref2 = backoff.multiplyFactor) != null ? _ref2 : 1.4;
    maxDelayMs = (_ref3 = backoff.maxDelayMs) != null ? _ref3 : 1000 * 60 * 15;
    maxReconnectAttempts = (_ref4 = backoff.maxReconnectAttempts) != null ? _ref4 : 10;
    this.clearBackoffTimeout = function() {
      return totalReconnectAttempts = 0;
    };
    return this.setBackoffTimeout = function(fn) {
      if (totalReconnectAttempts < maxReconnectAttempts) {
        setTimeout(fn, Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs));
        return totalReconnectAttempts++;
      } else {
        return _this.emit("connectionFailed");
      }
    };
  };

  Broker.prototype.connect = function(callback) {
    var initialListener,
      _this = this;
    if (callback == null) {
      callback = function() {};
    }
    this.ws = new SockJS(this.sockURL);
    this.ws.addEventListener("open", function() {
      _this.emit("connected");
      _this.clearBackoffTimeout();
      return _this.ws.send(JSON.stringify({
        vhost: _this.vhost
      }));
    });
    this.ws.addEventListener("close", function() {
      _this.emit("disconnected", Object.keys(_this.channels));
      _this.channels = {};
      if (_this.autoReconnect) {
        return _this.setBackoffTimeout(_this.connect.bind(_this));
      }
    });
    initialListener = function(e) {
      var data;
      data = JSON.parse(e.data);
      if (!data.socket_id) {
        return;
      }
      _this.socket_id = data.socket_id;
      return process.nextTick(function() {
        return _this.ws.removeEventListener("message", initialListener);
      });
    };
    this.ws.addEventListener("message", initialListener);
    this.ws.addEventListener("message", function(e) {
      var data, evt;
      data = JSON.parse(e.data);
      if (!data.event) {
        return;
      }
      evt = {};
      evt.type = data.event;
      evt.data = data.payload;
      return _this.ws.dispatchEvent(evt);
    });
    return this;
  };

  Broker.prototype.channel = function(name) {
    return this.channels[name];
  };

  Broker.prototype.disconnect = function(reconnect) {
    reconnect || (reconnect = false);
    if (!reconnect) {
      this.autoReconnect = false;
    }
    return this.ws.close();
  };

  Broker.prototype.subscribe = function(channelName, options) {
    var channel;
    if (this.channels[channelName]) {
      return this.channels[channelName];
    }
    channel = new Channel(this.ws, escape(channelName), options);
    this.channels[escape(channelName)] = channel;
    channel.isPrivate = /^(private-[\w-.]*)/.test(channelName);
    if (!channel.isPrivate) {
      channel.emitter.emit("authorized");
      return channel;
    }
    this.authorize(channelName, function(privName) {
      channel.privateName = privName;
      channel.name = channelName;
      return channel.emitter.emit("authorized");
    });
    return channel;
  };

  Broker.prototype.presenceOn = function(who, where, listener) {
    sendWsMessage(this.ws, "client-presence", where, {
      payload: who
    });
    return this.ws.addEventListener("message", function(e) {
      var data;
      data = JSON.parse(e.data);
      if ((!data.event || !data.channel) || (data.channel !== "KDPresence-" + where) || (data.event !== "broker:presence")) {
        return;
      }
      return listener(data.payload);
    });
  };

  Broker.prototype.presenceOff = function(who, where, listener) {
    return sendWsMessage(this.ws, "client-presence", where, {
      payload: who
    });
  };

  Broker.prototype.authorize = function(channelName, callback) {
    var xhr;
    xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        return callback(xhr.responseText);
      }
    };
    xhr.open('get', "" + this.channel_auth_endpoint + "?channel=" + channelName);
    return xhr.send();
  };

  Broker.prototype.unsubscribe = function(channel) {
    if (typeof channel === "string") {
      channel = this.channels[escape(channel)];
    }
    if (!channel) {
      return;
    }
    delete this.channels[channel.name];
    return sendWsMessage(this.ws, "client-unbind", channel);
  };

  return Broker;

})();

});

require.define("/node_modules/microemitter/package.json",function(require,module,exports,__dirname,__filename,process,global){module.exports = {"main":"index.js"}
});

require.define("/node_modules/microemitter/index.js",function(require,module,exports,__dirname,__filename,process,global){var EventEmitter,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

EventEmitter = (function() {
  var createId, defineProperty, idKey, mixin;

  idKey = 'ಠ_ಠ';

  EventEmitter.listeners = {};

  EventEmitter.targets = {};

  EventEmitter.off = function(listenerId) {
    /*
        Note: @off, but no symmetrical "@on".  This is by design.
          One shouldn't add event listeners directly.  These static
          collections are maintained so that the listeners may be
          garbage collected and removed from the emitter's record.
          To that end, @off provides a handy interface.
    */
    delete this.listeners[listenerId];
    delete this.targets[listenerId];
    return this;
  };

  defineProperty = Object.defineProperty || function(obj, prop, _arg) {
    var value;
    value = _arg.value;
    return obj[prop] = value;
  };

  createId = (function() {
    var counter;
    counter = 0;
    return function() {
      return counter++;
    };
  })();

  mixin = function(obj) {
    var prop, prot, _results;
    prot = EventEmitter.prototype;
    _results = [];
    for (prop in prot) {
      _results.push(obj[prop] = prot[prop]);
    }
    return _results;
  };

  function EventEmitter(obj) {
    if (obj != null) {
      mixin(obj);
    } else {
      obj = this;
    }
    defineProperty(obj, idKey, {
      value: "" + (Math.round(Math.random() * 1e9))
    });
    defineProperty(obj, '_events', {
      value: {},
      writable: true
    });
  }

  EventEmitter.prototype.on = function(evt, listener) {
    var lid, listeners, _base;
    listeners = (_base = this._events)[evt] || (_base[evt] = {});
    if (this[idKey] in listener) {
      lid = listener[this[idKey]];
    } else {
      lid = createId();
      defineProperty(listener, this[idKey], {
        value: lid
      });
    }
    EventEmitter.listeners[lid] = listeners[lid] = listener;
    EventEmitter.targets[lid] = this;
    return lid;
  };

  EventEmitter.prototype.once = function(evt, listener) {
    var wrappedListener,
      _this = this;
    wrappedListener = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.off(evt, wrappedListener);
      return listener.apply(_this, rest);
    };
    return this.on(evt, wrappedListener);
  };

  EventEmitter.prototype.when = function() {};

  EventEmitter.prototype.off = function(evt, listener) {
    var listenerId, listeners;
    switch (arguments.length) {
      case 0:
        this._events = {};
        break;
      case 1:
        this._events[evt] = {};
        break;
      default:
        listeners = this._events[evt];
        listenerId = listener[this[idKey]];
        delete listeners[listenerId];
        EventEmitter.off(listenerId);
    }
    return this;
  };

  EventEmitter.prototype.emit = function() {
    var evt, id, listener, listeners, rest;
    evt = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    listeners = this._events[evt];
    for (id in listeners) {
      if (!__hasProp.call(listeners, id)) continue;
      listener = listeners[id];
      listener.call.apply(listener, [this].concat(__slice.call(rest)));
    }
    if (evt === 'error' && listeners.length === 0) {
      throw rest[0];
    }
    return this;
  };

  return EventEmitter;

})();

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports.EventEmitter = EventEmitter;
} else if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
  define(function() {
    return EventEmitter;
  });
} else {
  this['EventEmitter'] = EventEmitter;
}

});

require.define("/node_modules/broker-client/lib/broker-client/channel.js",function(require,module,exports,__dirname,__filename,process,global){'use strict';

var Channel;

module.exports = Channel = (function() {
  var EventEmitter, getRE, performTask, sendWsMessage, _ref;

  EventEmitter = require('microemitter').EventEmitter;

  _ref = require('./util'), sendWsMessage = _ref.sendWsMessage, performTask = _ref.performTask;

  function Channel(ws, name, options) {
    var onopen, _ref1,
      _this = this;
    this.ws = ws;
    this.name = name;
    this.fineGrained = (_ref1 = options != null ? options.fineGrained : void 0) != null ? _ref1 : false;
    this.emitter = new EventEmitter;
    this.events = {};
    this.wildcards = {};
    onopen = function() {
      var msgListener;
      name = _this.privateName || _this.name;
      if (ws.readyState > 0) {
        if (!_this.fineGrained) {
          sendWsMessage(ws, "client-bind", name);
        }
        msgListener = function(e) {
          var data, evt, exchange, payload;
          data = JSON.parse(e.data);
          if (!data.event || !data.exchange) {
            return;
          }
          exchange = name;
          if (data.exchange !== exchange) {
            return;
          }
          evt = {
            type: exchange + "." + data.event,
            event: data.event
          };
          try {
            payload = JSON.parse(data.payload);
          } catch (ex) {
            payload = data.payload;
          } finally {
            data.payload = payload;
          }
          evt.data = data.payload;
          if (data.event === "broker:subscription_error") {
            _this.emit('error', new Error("Subscription error: " + name));
            return process.nextTick(function() {
              return ws.removeEventListener("message", msgListener);
            });
          } else {
            return _this.dispatchEvent(data.event, evt);
          }
        };
        return ws.addEventListener("message", msgListener);
      } else {
        return ws.addEventListener("open", onopen);
      }
    };
    this.emitter.on("authorized", onopen);
  }

  Channel.prototype.once = function(eventType, listener, ctx) {
    var wrapper,
      _this = this;
    wrapper = function() {
      listener.apply(ctx || _this, [].slice.call(arguments));
      return _this.off(eventType, wrapper);
    };
    this.on(eventType, wrapper);
    return this;
  };

  getRE = (function() {
    var reCache;
    reCache = {};
    return function(eventType) {
      if (reCache[eventType] != null) {
        return reCache[eventType];
      }
      return RegExp("^" + eventType.replace(/(#|\*|\.)/g, function(match, wildcard) {
        switch (wildcard) {
          case "#":
            return "([\\w|\\.]*)";
          case "*":
            return "(\\w*)";
          case ".":
            return "\\.";
        }
      }) + "$");
    };
  })();

  Channel.prototype.dispatchEvent = function(event, evt) {
    var _this = this;
    this.emitter.emit(event, evt);
    return Object.keys(this.wildcards).forEach(function(wildcard) {
      var matchesWildcard;
      matchesWildcard = getRE(wildcard).test(event);
      if (matchesWildcard) {
        return _this.emitter.emit(wildcard, evt);
      }
    });
  };

  Channel.prototype.addWildcardListener = function(routingKey, listener) {
    this.wildcards[routingKey] || (this.wildcards[routingKey] = []);
    return this.wildcards[routingKey].push(listener);
  };

  Channel.prototype.on = function(eventType, listener, ctx) {
    var brokerListener,
      _this = this;
    brokerListener = function(eventObj) {
      return listener.call(ctx || _this, eventObj.data, eventObj.event);
    };
    brokerListener.orig = listener;
    performTask(this, function(channelName) {
      if (_this.fineGrained) {
        sendWsMessage(_this.ws, "client-bind", channelName, {
          routingKey: eventType
        });
      }
      if (/#|\*/.test(eventType)) {
        _this.addWildcardListener(eventType);
      }
      _this.emitter.on(eventType, brokerListener);
      _this.events[eventType] || (_this.events[eventType] = []);
      return _this.events[eventType].push(brokerListener);
    });
    return this;
  };

  Channel.prototype.off = function(eventType, listener) {
    var brokerListener, channel, i, listeners,
      _this = this;
    channel = this.privateName || this.name;
    if (this.fineGrained) {
      sendWsMessage(this.ws, "client-unbind", channel, {
        routingKey: eventType
      });
    }
    listeners = this.events[eventType] || [];
    i = 0;
    while (i < listeners.length) {
      brokerListener = listeners[i];
      if (brokerListener.orig === listener) {
        process.nextTick(function() {
          _this.ws.removeEventListener(channel + "." + eventType, brokerListener);
          return listeners.splice(i, 1);
        });
        break;
      }
      i++;
    }
    return this;
  };

  Channel.prototype.emit = function(eventType, payload, meta) {
    var _this = this;
    if (!this.isPrivate) {
      return false;
    }
    if (!eventType.match(/^(client-[\w-@#]*)/)) {
      return false;
    }
    return performTask(this, function(channelName) {
      sendWsMessage(_this.ws, eventType, channelName, {
        payload: payload,
        meta: meta
      });
      return true;
    });
  };

  Channel.prototype.bind = Channel.prototype.on;

  Channel.prototype.unbind = Channel.prototype.off;

  Channel.prototype.trigger = Channel.prototype.emit;

  return Channel;

})();

});

require.define("/node_modules/broker-client/lib/broker-client/util.js",function(require,module,exports,__dirname,__filename,process,global){'use strict';

module.exports = (function() {
  var performTask, sendWsMessage;
  sendWsMessage = function(ws, event, exchange, options) {
    var subJSON;
    if (options == null) {
      options = {};
    }
    if (ws.readyState > 0) {
      subJSON = {
        event: event,
        exchange: exchange
      };
      if (options.payload != null) {
        subJSON.payload = options.payload;
      }
      if (options.routingKey != null) {
        subJSON.routingKey = options.routingKey;
      }
      if (options.meta != null) {
        subJSON.meta = options.meta;
      }
      return ws.send(JSON.stringify(subJSON));
    } else {
      return ws.addEventListener("open", sendWsMessage.bind(this, ws, routingKey, channel, payload, options));
    }
  };
  performTask = function(channel, readyCallback) {
    var channelName;
    if (channel.ws.readyState > 0) {
      if (!channel.isPrivate || channel.privateName) {
        channelName = channel.privateName || channel.name;
        return readyCallback(channelName);
      } else {
        return channel.emitter.on("authorized", performTask.bind(this, channel, readyCallback));
      }
    } else {
      return channel.ws.addEventListener("open", performTask.bind(this, channel, readyCallback));
    }
  };
  return {
    sendWsMessage: sendWsMessage,
    performTask: performTask
  };
})();

});

require.define("/node_modules/broker-client/index.js",function(require,module,exports,__dirname,__filename,process,global){module.exports = require('./lib/broker-client');
});
require("/node_modules/broker-client/index.js");
})();
