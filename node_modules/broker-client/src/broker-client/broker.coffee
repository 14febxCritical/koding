

module.exports = class Broker

  {EventEmitter} = require 'microemitter'

  EventEmitter Broker::

  Channel = require './channel'
  {sendWsMessage} = require './util'

  constructor:(appKey, options={})->
    @sockURL = options.sockURL or "http://" + window.location.hostname + ":8008/subscribe"
    @channel_auth_endpoint = options.authEndPoint or "http://" + window.location.hostname + ":8008/auth"
    @vhost = options.vhost or "/"
    @key = appKey
    @autoReconnect = options.autoReconnect or false
    @channels = {}
    @connect()
    @initBackoff options  if @autoReconnect
  
  initBackoff:(options)->
    backoff = options.backoff ? {}
    totalReconnectAttempts = 0
    initalDelayMs = backoff.initialDelayMs ? 700
    multiplyFactor = backoff.multiplyFactor ? 1.4
    maxDelayMs = backoff.maxDelayMs ? 1000 * 60 * 15 # 15 seconds
    maxReconnectAttempts = backoff.maxReconnectAttempts ? 10

    @clearBackoffTimeout =->
      totalReconnectAttempts = 0

    @setBackoffTimeout = (fn)=>
      if totalReconnectAttempts < maxReconnectAttempts
        setTimeout fn, Math.min initalDelayMs * Math.pow(
          multiplyFactor, totalReconnectAttempts
        ), maxDelayMs
        totalReconnectAttempts++
      else
        @emit "connectionFailed"

  connect:(callback=->)->
    @ws = new SockJS @sockURL
    @ws.addEventListener "open", =>
      @emit "connected"
      @clearBackoffTimeout()
      @ws.send JSON.stringify(vhost: @vhost)

    @ws.addEventListener "close", =>
      @emit "disconnected", Object.keys(@channels)
      @channels = {}
      @setBackoffTimeout @connect.bind @  if @autoReconnect

    
    # Initial set up to acquire socket_id
    initialListener = (e)=>
      data = JSON.parse(e.data)
      return  unless data.socket_id
      @socket_id = data.socket_id
      process.nextTick =>
        @ws.removeEventListener "message", initialListener

    @ws.addEventListener "message", initialListener
    
    # Dispatch global events on receiving message
    @ws.addEventListener "message", (e)=>
      data = JSON.parse(e.data)
      return  unless data.event
      evt = {}
      evt.type = data.event
      evt.data = data.payload
      @ws.dispatchEvent evt

    return this # chainable

  channel:(name)->
    @channels[name]

  disconnect:(reconnect)->
    reconnect or (reconnect = false)
    @autoReconnect = false  unless reconnect
    @ws.close()

  subscribe:(channelName, options)->
    return @channels[channelName]  if @channels[channelName]
    channel = new Channel @ws, escape(channelName), options
    @channels[escape(channelName)] = channel
    channel.isPrivate = /^(private-[\w-.]*)/.test(channelName)
    unless channel.isPrivate
      channel.emitter.emit "authorized"
      return channel
    @authorize channelName, (privName)->
      channel.privateName = privName
      channel.name = channelName
      channel.emitter.emit "authorized"

    channel

  presenceOn:(who, where, listener)->
    sendWsMessage @ws, "client-presence", where, payload: who
    @ws.addEventListener "message", (e)->
      console.log e
      data = JSON.parse(e.data)
      return  if (not data.event or not data.channel)\
              or (data.channel isnt "KDPresence-" + where)\
              or (data.event isnt "broker:presence")
      listener data.payload

  presenceOff:(who, where, listener)->
    sendWsMessage @ws, "client-presence", where, payload: who

  authorize:(channelName, callback)->
    xhr = new XMLHttpRequest
    xhr.onreadystatechange =->
      callback xhr.responseText  if xhr.readyState is 4
    xhr.open 'get', "#{@channel_auth_endpoint}?channel=#{channelName}"
    xhr.send()

  unsubscribe:(channel)->
    channel = @channels[escape(channel)]  if typeof channel is "string"
    return  unless channel
    delete @channels[channel.name]

    sendWsMessage @ws, "client-unbind", channel