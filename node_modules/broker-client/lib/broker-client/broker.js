'use strict';

var Broker;

module.exports = Broker = (function() {
  var Channel, EventEmitter, sendWsMessage;

  EventEmitter = require('microemitter').EventEmitter;

  EventEmitter(Broker.prototype);

  Channel = require('./channel');

  sendWsMessage = require('./util').sendWsMessage;

  function Broker(appKey, options) {
    if (options == null) {
      options = {};
    }
    this.sockURL = options.sockURL || "http://" + window.location.hostname + ":8008/subscribe";
    this.channel_auth_endpoint = options.authEndPoint || "http://" + window.location.hostname + ":8008/auth";
    this.vhost = options.vhost || "/";
    this.key = appKey;
    this.autoReconnect = options.autoReconnect || false;
    this.channels = {};
    this.connect();
    if (this.autoReconnect) {
      this.initBackoff(options);
    }
  }

  Broker.prototype.initBackoff = function(options) {
    var backoff, initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref, _ref1, _ref2, _ref3, _ref4,
      _this = this;
    backoff = (_ref = options.backoff) != null ? _ref : {};
    totalReconnectAttempts = 0;
    initalDelayMs = (_ref1 = backoff.initialDelayMs) != null ? _ref1 : 700;
    multiplyFactor = (_ref2 = backoff.multiplyFactor) != null ? _ref2 : 1.4;
    maxDelayMs = (_ref3 = backoff.maxDelayMs) != null ? _ref3 : 1000 * 60 * 15;
    maxReconnectAttempts = (_ref4 = backoff.maxReconnectAttempts) != null ? _ref4 : 10;
    this.clearBackoffTimeout = function() {
      return totalReconnectAttempts = 0;
    };
    return this.setBackoffTimeout = function(fn) {
      if (totalReconnectAttempts < maxReconnectAttempts) {
        setTimeout(fn, Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs));
        return totalReconnectAttempts++;
      } else {
        return _this.emit("connectionFailed");
      }
    };
  };

  Broker.prototype.connect = function(callback) {
    var initialListener,
      _this = this;
    if (callback == null) {
      callback = function() {};
    }
    this.ws = new SockJS(this.sockURL);
    this.ws.addEventListener("open", function() {
      _this.emit("connected");
      _this.clearBackoffTimeout();
      return _this.ws.send(JSON.stringify({
        vhost: _this.vhost
      }));
    });
    this.ws.addEventListener("close", function() {
      _this.emit("disconnected", Object.keys(_this.channels));
      _this.channels = {};
      if (_this.autoReconnect) {
        return _this.setBackoffTimeout(_this.connect.bind(_this));
      }
    });
    initialListener = function(e) {
      var data;
      data = JSON.parse(e.data);
      if (!data.socket_id) {
        return;
      }
      _this.socket_id = data.socket_id;
      return process.nextTick(function() {
        return _this.ws.removeEventListener("message", initialListener);
      });
    };
    this.ws.addEventListener("message", initialListener);
    this.ws.addEventListener("message", function(e) {
      var data, evt;
      data = JSON.parse(e.data);
      if (!data.event) {
        return;
      }
      evt = {};
      evt.type = data.event;
      evt.data = data.payload;
      return _this.ws.dispatchEvent(evt);
    });
    return this;
  };

  Broker.prototype.channel = function(name) {
    return this.channels[name];
  };

  Broker.prototype.disconnect = function(reconnect) {
    reconnect || (reconnect = false);
    if (!reconnect) {
      this.autoReconnect = false;
    }
    return this.ws.close();
  };

  Broker.prototype.subscribe = function(channelName, options) {
    var channel;
    if (this.channels[channelName]) {
      return this.channels[channelName];
    }
    channel = new Channel(this.ws, escape(channelName), options);
    this.channels[escape(channelName)] = channel;
    channel.isPrivate = /^(private-[\w-.]*)/.test(channelName);
    if (!channel.isPrivate) {
      channel.emitter.emit("authorized");
      return channel;
    }
    this.authorize(channelName, function(privName) {
      channel.privateName = privName;
      channel.name = channelName;
      return channel.emitter.emit("authorized");
    });
    return channel;
  };

  Broker.prototype.presenceOn = function(who, where, listener) {
    sendWsMessage(this.ws, "client-presence", where, {
      payload: who
    });
    return this.ws.addEventListener("message", function(e) {
      var data;
      data = JSON.parse(e.data);
      if ((!data.event || !data.channel) || (data.channel !== "KDPresence-" + where) || (data.event !== "broker:presence")) {
        return;
      }
      return listener(data.payload);
    });
  };

  Broker.prototype.presenceOff = function(who, where, listener) {
    return sendWsMessage(this.ws, "client-presence", where, {
      payload: who
    });
  };

  Broker.prototype.authorize = function(channelName, callback) {
    var xhr;
    xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        return callback(xhr.responseText);
      }
    };
    xhr.open('get', "" + this.channel_auth_endpoint + "?channel=" + channelName);
    return xhr.send();
  };

  Broker.prototype.unsubscribe = function(channel) {
    if (typeof channel === "string") {
      channel = this.channels[escape(channel)];
    }
    if (!channel) {
      return;
    }
    delete this.channels[channel.name];
    return sendWsMessage(this.ws, "client-unbind", channel);
  };

  return Broker;

})();
