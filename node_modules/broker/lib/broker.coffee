module.exports = class Broker
    amqp = require 'amqp'
    DELIMITER = 'Î»'

    ###
    Quick option to declare a durable auto-delete exchange.
    ###
    createExchange = (connection, name, callback) ->
        options = {durable: true, autoDelete: true}
        connection.exchange name, options, callback

    ###
    Quick option to declare a durable exclusive queue.
    ###
    createQueue = (connection, name, callback) ->
        options = {durable: true, exclusive: true}
        connection.queue name, options, callback

    subscribe = (connection, channel, event, listener) ->
        createQueue connection, '', (queue) ->
            queue.bind channel, event
            queue.on 'queueBindOk', ->
                result = queue.subscribe (payload) ->
                    message = payload.data+""
                    if 'string' is typeof message
                        listener message
                    else
                        try 
                            message = JSON.parse message
                            listener message
                        catch e
                            listener message: 'Parse error!'

    constructor: (options, callback) ->
        @options = options
        @eventMap = {}
        @connection = amqp.createConnection options
        @connection.on 'ready', callback if callback

    emit: (channel, event, payload, options) ->
        createExchange @connection, channel, (exchange) ->
            exchange.publish event, payload, options

    on: (channel, event, listener) ->
        # eventMap = @eventMap
        # key = channel+DELIMITER+event
        # return if eventMap[key]

        unless channel in (@connection.exchanges or [])
            createExchange @connection, channel, =>
                subscribe(@connection, channel, event, listener)
        else
            subscribe(@connection, channel, event, listener)

        # createQueue @connection, '', (queue) ->
        #     queue.bind channel, event
        #     queue.on 'queueBindOk', ->
        #         queue.subscribe (payload) ->
        #             console.log payload
        #             listener payload.data
        #         .addCallback (ok) ->
        #             ctag = ok.consumerTag
        #             eventMap[key] = [queue, ctag]

    off: (channel, event, listener) ->
        key = channel+DELIMITER+event
        [queue, ctag] = @eventMap[key]
        queue.unsubscribe(ctag)
        queue.destroy()

    # Alias
    trigger: @::emit
    bind: @::on
    unbind: @::off