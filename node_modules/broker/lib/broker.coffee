module.exports = class Broker
  amqp = require 'amqp'
  {dash} = require 'sinkrow'
  DELIMITER = 'Î»'

  constructor: (options) ->
    @options = options
    @eventMap = {}
    @connection = amqp.createConnection options
    @connection.on 'ready', => @readyState = 1
    @connection.setMaxListeners(0)
    @readyState = 0
    # @connection.on 'ready', callback if callback

  createExchange: (exchangeName, options, callback) ->
    if typeof options is 'function'
      callback = options
      options = {} 
    @ready =>

      options ?= {}
      options.durable ?= true
      options.autoDelete ?= true

      @connection.exchange exchangeName, options, callback

  createQueue: (queueName, options, callback) ->
    if typeof options is 'function'
      callback = options
      options = {durable:true, exclusive:true} 
    @ready =>
      @connection.queue queueName, options, callback

  funnel:(exchangeName, queueName)->
    @ready =>
      @createExchange exchangeName, (exchange)=>
        @createQueue queueName, {autoDelete:no}, (queue)=>
          queue.bind exchange, '#'
          @createQueue '', (dcQueue)->
            dcQueue.bind exchange, 'disconnected'
            dcQueue.subscribe ->
              queue.unbind exchange, '#'
              dcQueue.destroy()
  ###
  Bind exchange named 'destination' to exchange named 'source' on a
  routing key so that message come to 'source' exchange will flow to
  'destination' exchange if that message has the routing key.
  An auto-delete 'source' exchange will be removed if binding removed,
  but auto-delete 'destination' exchange will not.
  ###
  bindExchange: (destination, source, routingKey) ->
    @ready =>
      destination.options ?= durable: true, autoDelete: false
      source.options ?= durable: true, autoDelete: false

      queue = [
        createDestination = =>
          @createExchange destination.name, destination.options, (exchange) ->
            destination.exchange = exchange
            queue.fin()
        createSource = =>
          @createExchange source.name, source.options, (exchange) ->
            source.exchange = exchange
            queue.fin()
      ]

      dash queue, ->
        destination.exchange.bind source.exchange, routingKey

  unbindExchange: (destination, source, routingKey) ->
    @ready =>
      destinationExchange = (@connection.exchanges or {})[destination]
      sourceExchange = (@connection.exchanges or {})[source]
      return unless destinationExchange? and sourceExchange?

      destinationExchange.unbind sourceExchange, routingKey

  bindQueue: (name, exchange, routing, options, callback) ->
    @ready =>
      if 'function' is typeof options
        callback = options
        options = {}
      options ?= {}
      {exchangeDurable, exchangeAutoDelete, queueDurable, queueExclusive} = options
      queueOptions =
        durable: unless queueDurable? then true else queueDurable 
        exclusive: unless queueExclusive? then true else queueExclusive

      unless exchange of (@connection.exchanges or {})
        exchangeOptions =
          durable: unless exchangeDurable? then true else exchangeDurable
          autoDelete: unless exchangeAutoDelete? then true else exchangeAutoDelete
        
        @createExchange exchange, exchangeOptions, =>
          @createQueue name, queueOptions, (queue) ->
            queue.bind exchange, routing
            queue.on 'queueBindOk', ->
              callback? queue, exchange
      else
        @createQueue name, queueOptions, (queue) ->
          queue.bind exchange, routing
          queue.on 'queueBindOk', ->
            callback? queue, exchange

  subscribe: (queueName, options, listener) ->
    @ready =>
      if 'function' is typeof queueName
        listener = queueName
        queueName = ''

      else if 'function' is typeof options
        listener = options
        options = {durable: true, exclusive: true}

      options ?= {}
      options.durable ?= true
      options.exclusive ?=true

      @createQueue queueName, options, (queue) ->
        result = queue.subscribe (payload, headers, deliveryInfo) ->
          unless payload.data?
            listener payload, headers, deliveryInfo
          else
            message = payload.data+""
            if 'string' is typeof message
              listener message, headers, deliveryInfo
            else
              try 
                message = JSON.parse message
                listener message, headers, deliveryInfo
              catch e
                listener message: 'Parse error!'

  ready:(listener)->
    if @readyState is 1
      listener()
    else
      @connection.on 'ready', -> listener()

  # A wrapper to publish a message to an exchange on a routing key.
  #
  # (String) channel - name of the exchange
  # (String) event - the routing key
  # (Object|String) payload
  # (Object) options - the options for both the exchange and the message.
  # To specify the type of exchange, set `durable` and `autoDelete`.
  #
  # For message options, here are the available:
  #  mandatory: boolean, default false. This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is false, the server silently drops the message.
  #  immediate: boolean, default false. This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is false, the server will queue the message, but with no guarantee that it will ever be consumed.
  #  contentType: default 'application/octet-stream'
  #  contentEncoding: default null.
  #  headers: default {}. Arbitrary application-specific message headers.
  #  deliveryMode: Non-persistent (1) or persistent (2)
  #  priority: The message priority, 0 to 9.
  #  replyTo: Usually used to name a reply queue for a request message.
  #
  # exchange.publish can also take a callback, but for the simplicity of
  # emit signature, it is not used.
  emit: (channel, event, payload, options = {}) ->
    {durable, autoDelete} = options
    exchangeOptions = 
      durable: unless durable? then true else durable
      autoDelete: unless autoDelete? then true else autoDelete

    delete options.durable
    delete options.autoDelete

    @createExchange channel, exchangeOptions, (exchange) ->
      exchange.publish event, payload, options

  on: (channel, event, queueName, listener) ->
    # eventMap = @eventMap
    # key = channel+DELIMITER+event
    # return if eventMap[key]
    [listener, queueName] = [queueName, listener] unless listener?
    queueName ?= ''

    @ready =>
      # bindQueue method ensures existence of exchange and queue
      @bindQueue queueName, channel, event, (queue, exchangeName) =>
        # @subscribe queueName, listener
        queue.subscribe (payload, headers, deliveryInfo) ->
          unless payload.data?
            listener payload, headers, deliveryInfo
          else
            message = payload.data+""
            if 'string' is typeof message
              listener message, headers, deliveryInfo
            else
              try 
                message = JSON.parse message
                listener message, headers, deliveryInfo
              catch e
                listener message: 'Parse error!'

    # createQueue @connection, '', (queue) ->
    #     queue.bind channel, event
    #     queue.on 'queueBindOk', ->
    #         queue.subscribe (payload) ->
    #             console.log payload
    #             listener payload.data
    #         .addCallback (ok) ->
    #             ctag = ok.consumerTag
    #             eventMap[key] = [queue, ctag]

  off: (channel, event, listener) ->
    key = channel+DELIMITER+event
    [queue, ctag] = @eventMap[key]
    queue.unsubscribe(ctag)
    queue.destroy()

  # Alias
  trigger: @::emit
  bind: @::on
  unbind: @::off
