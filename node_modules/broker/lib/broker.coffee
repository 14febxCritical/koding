module.exports = class Broker
  amqp = require 'amqp'
  {dash} = require 'sinkrow'
  DELIMITER = 'Î»'

  ###
  Quick option to declare a durable auto-delete exchange.
  ###
  createExchange = (connection, name, callback) ->
    options = {durable: true, autoDelete: true}
    connection.exchange name, options, callback

  ###
  Quick option to declare a durable exclusive queue.
  ###
  createQueue = (connection, name, callback) ->
    console.log 'create queue is called'
    options = {durable: true, exclusive: true}
    connection.queue name, options, callback

  subscribe = (connection, channel, event, listener) ->
    createQueue connection, '', (queue) ->
      queue.bind channel, event
      queue.on 'queueBindOk', ->
        result = queue.subscribe (payload) ->
          message = payload.data+""
          if 'string' is typeof message
            listener message
          else
            try 
              message = JSON.parse message
              listener message
            catch e
              listener message: 'Parse error!'

  constructor: (options) ->
    @options = options
    @eventMap = {}
    @connection = amqp.createConnection options
    @connection.on 'ready', => @readyState = 1
    @connection.setMaxListeners(0)
    @readyState = 0
    # @connection.on 'ready', callback if callback

  emit: (channel, event, payload, options) ->
    createExchange @connection, channel, (exchange) ->
      exchange.publish event, payload, options

  funnel:(exchangeName, queueName)->
    @ready =>
      createExchange @connection, exchangeName, (exchange)=>
        @connection.queue queueName, {autoDelete:no}, (queue)->
          queue.bind exchange, '#'

  bindExchange: (destination, source, routingKey) ->
    @ready =>
      exchanges = {}
      queue = [
        createDestination = =>
          createExchange @connection, destination, (exchange) =>
            exchanges.destination = exchange
            queue.fin()
        createSource = =>
          createExchange @connection, source, (exchange) =>
            exchanges.source = exchange
            queue.fin()
      ]

      dash queue, =>
        exchanges.destination.bind exchanges.source, routingKey

  unbindExchange: (destination, source, routingKey) ->
    @ready =>
      destinationExchange = (@connection.exchanges or [])[destination]
      sourceExchange = (@connection.exchanges or [])[source]
      return unless destinationExchange? and sourceExchange?

      destinationExchange.unbind sourceExchange, routingKey

  ready:(listener)->
    if @readyState is 1
      listener()
    else
      @connection.on 'ready', -> listener()

  on: (channel, event, listener) ->
    # eventMap = @eventMap
    # key = channel+DELIMITER+event
    # return if eventMap[key]
    @ready =>
      unless channel in (@connection.exchanges or [])
        createExchange @connection, channel, =>
          subscribe(@connection, channel, event, listener)
      else
        subscribe(@connection, channel, event, listener)

    # createQueue @connection, '', (queue) ->
    #     queue.bind channel, event
    #     queue.on 'queueBindOk', ->
    #         queue.subscribe (payload) ->
    #             console.log payload
    #             listener payload.data
    #         .addCallback (ok) ->
    #             ctag = ok.consumerTag
    #             eventMap[key] = [queue, ctag]

  off: (channel, event, listener) ->
    key = channel+DELIMITER+event
    [queue, ctag] = @eventMap[key]
    queue.unsubscribe(ctag)
    queue.destroy()

  # Alias
  trigger: @::emit
  bind: @::on
  unbind: @::off